[{"id":1,"questionText":"Що таке ООП?","answer":"<p>Об'єктно-орієнтоване програмування (ООП) — методологія програмування, яка базується на уявленні програми у вигляді сукупності об'єктів, кожен з яких є екземпляром певного класу, а класи формують ієрархію успадкування.</p>\n\n<ul>\n  <li>Об'єктно-орієнтоване програмування використовує об'єкти, а не процедури (функції), як основні логічні конструктивні елементи;</li>\n  <li>Кожен об'єкт є екземпляром певного класу;</li>\n  <li>Класи формують ієрархії.</li>\n</ul>\n\n<p>Програма вважається об'єктно-орієнтованою лише тоді, коли виконуються всі три вказані вимоги. Зокрема, програмування, яке не використовує успадкування, називається не об'єктно-орієнтованим, а програмуванням з використанням абстрактних типів даних.</p>\n\n<p>Згідно з парадигмою ООП програма складається з об'єктів, які обмінюються повідомленнями. Об'єкти можуть мати стан, ідиний спосіб змінити стан об'єкта — відправити йому повідомлення, на яке об'єкт може змінити свій власний стан у відповідь.</p>","topicName":"Core-1"},{"id":2,"questionText":"Які переваги у ООП?","answer":"<p><strong>Легко читається</strong> — не потрібно шукати в коді функції та з'ясовувати, за що вони відповідають.</p>\n<p><strong>Швидко пишеться</strong> — можна швидко створити сутності, з якими повинна працювати програма.</p>\n<p><strong>Простота реалізації великого функціоналу</strong> — оскільки написання коду забирає менше часу, можна набагато швидше створити додаток з багатьма можливостями.</p>","topicName":"Core-1"},{"id":3,"questionText":"Які недоліки у ООП?","answer":"<p><strong>Споживання пам'яті</strong> — об'єкти споживають більше оперативної пам'яті, ніж примітивні типи даних.</p>\n<p><strong>Знижується продуктивність</strong> — багато речей технічно реалізовані по-іншому, тому вони використовують більше ресурсів.</p>\n<p><strong>Складно почати</strong> — парадигма ООП складніша за функціональне програмування, тому на старті йде більше часу.</p>","topicName":"Core-1"},{"id":4,"questionText":"Які існують принципи ООП ?","answer":"<ul>\n  <li>Інкапсуляція</li>\n  <li>Наслідування</li>\n  <li>Поліморфізм</li>\n  <li>Абстракція</li>\n</ul>","topicName":"Core-1"},{"id":5,"questionText":"Що таке інкапсуляція ?","answer":"<p><strong>Інкапсуляція</strong> — це властивість системи, яка дозволяє об'єднати дані та методи, які працюють з ними, в класі і приховати деталі реалізації від користувача, відкриваючи тільки те, що необхідно при подальшому використанні.</p>\n<p><strong>Мета інкапсуляції</strong> — відокремити зовнішній інтерфейс класу (те, що можуть використовувати інші класи) від реалізації, щоб навіть найменша зміна в класі не призводила до зміни зовнішньої поведінки класу.</p>","topicName":"Core-1"},{"id":6,"questionText":"Що таке спадкування ?","answer":"<p><strong>Спадкування</strong> — це властивість системи, яка дозволяє описати новий клас на основі вже існуючого з частково або повністю взятою функціональністю.</p>\n<p>Клас, від якого відбувається спадкування, називається <em>предком</em>, <em>базовим</em> або <em>батьківським</em>. Новий клас — <em>нащадком</em>, <em>спадкоємцем</em> або <em>похідним класом</em>.</p>","topicName":"Core-1"},{"id":7,"questionText":"Що таке поліморфізм ?","answer":"<p><strong>Поліморфізм</strong> — це властивість системи використовувати об'єкти з однаковим інтерфейсом без інформації про тип та внутрішню структуру об'єкта.</p>\n<p>Перевагою поліморфізму є те, що він допомагає знижувати складність програм, дозволяючи використовувати один і той же інтерфейс для визначення єдиного набору дій.</p>\n<p>Звідси випливає ключова особливість поліморфізму — використання об'єкта похідного класу замість об'єкта базового. Нащадки можуть змінювати батьківську поведінку, навіть якщо звертання до них відбувається за посиланням батьківського типу.</p>","topicName":"Core-1"},{"id":8,"questionText":"Що таке абстрагування ?","answer":"<p><strong>Абстрагування</strong> — це спосіб виділити набір загальних характеристик об'єкта, виключаючи з розгляду конкретні та незначущі.</p>\n<p><strong>Абстракція</strong> — це набір усіх таких характеристик.</p>","topicName":"Core-1"},{"id":9,"questionText":"Що таке клас ?","answer":"<p><strong>Клас</strong> — це спосіб опису сутності, що визначає стан і поведінку, залежну від цього стану, а також правила для взаємодії з даною сутністю (контракт). З точки зору програмування, клас можна розглядати як набір даних (полів, атрибутів, членів класу) та функцій для роботи з ними (методів). З точки зору структури програми, клас є складним типом даних.</p>","topicName":"Core-1"},{"id":10,"questionText":"Що таке об'єкт?","answer":"<p><strong>Об'єкт (екземпляр)</strong> — це окремий представник класу, який має конкретний стан і поведінку, повністю визначену класом. Кожен об'єкт має конкретні значення атрибутів та методи, які працюють з цими значеннями на основі правил, визначених у класі.</p>","topicName":"Core-1"},{"id":11,"questionText":"Що таке інтерфейс?","answer":"<p><strong>Інтерфейс</strong> — це набір методів класу, доступних для використання. Інтерфейсом класу буде набір усіх його публічних методів разом із набором публічних атрибутів. По суті, інтерфейс визначає клас, чітко вказуючи всі можливі дії над ним.</p>","topicName":"Core-1"},{"id":12,"questionText":"Що таке асоціація?","answer":"<p><strong>Асоціація</strong> — це будь-який зв'язок між двома об'єктами. Наприклад, у вас є клас <em>Людина</em> та клас <em>Автомобіль</em> — якщо людина користується автомобілем, між ними існує асоціація.</p>","topicName":"Core-1"},{"id":13,"questionText":"Що таке агрегація?","answer":"<p><strong>Агрегація</strong> — це вид асоціації, коли один об'єкт є частиною іншого, але може існувати самостійно. Наприклад, <em>університет</em> складається з <em>факультетів</em>, але факультет може існувати незалежно від університету (наприклад, перейти в інший університет).</p>","topicName":"Core-1"},{"id":14,"questionText":"Що таке композиція?","answer":"<p><strong>Композиція</strong> — це більш суворий вид агрегації, коли \"частина\" не може існувати без \"цілого\". Наприклад, <em>будинок</em> складається з <em>кімнат</em>, і якщо будинок зруйнується — його кімнати перестають існувати. Кімната не може бути частиною двох будинків одночасно.</p>","topicName":"Core-1"},{"id":15,"questionText":"Що означає принцип \"є\" (is-a) в ООП?","answer":"<p><strong>\"Є\" (is-a)</strong> — це відношення, яке вказує, що один клас є різновидом іншого класу. Використовується при <em>успадкуванні</em>. Наприклад, <em>Кіт</em> — це <em>Тварина</em>. Клас \"Кіт\" успадковує властивості та поведінку класу \"Тварина\".</p>","topicName":"Core-1"},{"id":16,"questionText":"Що означає принцип \"має\" (has-a) в ООП?","answer":"<p><strong>\"Має\" (has-a)</strong> — це відношення, яке вказує, що один клас містить інший як свою частину. Використовується при <em>асоціації</em>, <em>агрегації</em> або <em>композиції</em>. Наприклад, <em>Автомобіль</em> має <em>двигун</em>. Двигун є частиною автомобіля, але може або існувати окремо (агрегація), або існувати тільки в цьому автомобілі (композиція).</p>","topicName":"Core-1"},{"id":17,"questionText":"Що таке статичне та динамічне зв'язування?","answer":"<p><strong>Зв'язування</strong> — це процес, коли програма визначає, який саме метод потрібно викликати у відповідь на виклик.</p>\n\n<p><strong>Статичне (раннє) зв'язування</strong> — відбувається ще до запуску програми, під час компіляції. Компілятор точно знає, який метод буде викликаний. Наприклад, виклик <em>static</em> методів або <em>private</em> методів у Java завжди визначається наперед.</p>\n\n<p><strong>Динамічне (пізнє) зв'язування</strong> — відбувається вже під час виконання програми. Який саме метод буде викликаний, вирішується залежно від реального типу об'єкта, а не типу змінної. Наприклад, якщо змінна типу <em>Тварина</em> насправді зберігає об'єкт <em>Кіт</em>, то при виклику методу буде використаний метод класу <em>Кіт</em>. У Java це працює для всіх методів, крім тих, що оголошені як <em>final</em> або <em>private</em>.</p>\n\n<p>Іншими словами:  \n<ul>\n  <li>Статичне зв'язування — \"вирішуємо заздалегідь\".</li>\n  <li>Динамічне зв'язування — \"вирішуємо під час виконання\".</li>\n</ul>\n</p>","topicName":"Core-1"},{"id":18,"questionText":"Як ти розумієш, що таке SOLID?","answer":"<p><strong>SOLID</strong> — це набір із п'яти принципів об'єктно-орієнтованого програмування, які допомагають створювати гнучкий, зрозумілий і легкий у підтримці код.</p>\n\n<ul>\n  <li><strong>S</strong> — <em>Single Responsibility Principle</em> (Принцип єдиної відповідальності): кожен клас повинен відповідати лише за одну чітко визначену задачу.</li>\n  <li><strong>O</strong> — <em>Open/Closed Principle</em> (Принцип відкритості/закритості): код повинен бути відкритий для розширення, але закритий для зміни.</li>\n  <li><strong>L</strong> — <em>Liskov Substitution Principle</em> (Принцип підстановки Барбари Лісков): об'єкти підкласів мають коректно замінювати об'єкти базових класів без зміни логіки програми.</li>\n  <li><strong>I</strong> — <em>Interface Segregation Principle</em> (Принцип розділення інтерфейсів): краще мати багато маленьких інтерфейсів, ніж один великий з непотрібними методами.</li>\n  <li><strong>D</strong> — <em>Dependency Inversion Principle</em> (Принцип інверсії залежностей): модулі верхнього рівня не повинні залежати від модулів нижчого рівня, обидва повинні залежати від абстракцій.</li>\n</ul>\n\n<p>Простіше кажучи, SOLID допомагає писати код так, щоб його було легко змінювати, розширювати і тестувати, не ламаючи вже існуючу функціональність.</p>","topicName":"Core-1"},{"id":19,"questionText":"Яка основна ідея мови?","answer":"<p><strong>Написано одного разу – працює скрізь</strong> (WORA) — ідея, що ґрунтується на написанні одного коду, який буде працювати на будь-якій платформі.</p>","topicName":"Core-1"},{"id":20,"questionText":"Чим забезпечується кроссплатформовість?","answer":"<p><strong>Кроссплатформовість</strong> була досягнута завдяки створенню віртуальної машини Java.</p>\n<p><strong>Java Virtual Machine</strong> або <strong>JVM</strong> — це програма, яка виступає як прослойка між операційною системою та Java-програмою. У середовищі віртуальної машини виконуються коди Java-програм. Сама JVM реалізована для різних операційних систем.</p>","topicName":"Core-1"},{"id":21,"questionText":"Які переваги у Java?","answer":"<p><strong>Об'єктно-орієнтоване програмування</strong> — структура даних стає об'єктом, яким можна управляти для створення відносин між різними об'єктами.</p>\n\n<p><strong>Мова високого рівня з простим синтаксисом і плавною кривою навчання</strong> — синтаксис Java ґрунтується на C++, тому Java схожа на C. Тим не менш, синтаксис Java є простішим, що дозволяє новачкам швидше навчатися і ефективніше використовувати код для досягнення конкретних результатів.</p>\n\n<p><strong>Стандарт для корпоративних обчислювальних систем</strong> — корпоративні застосунки є головною перевагою Java з 90-х років, коли організації почали шукати надійні інструменти програмування не на C.</p>\n\n<p><strong>Безпека</strong> — завдяки відсутності вказівників і Security Manager (політика безпеки, в якій можна вказати правила доступу, дозволяє запускати застосунки Java в \"пісочниці\").</p>\n\n<p><strong>Незалежність від платформи</strong> — можна створити Java-застосунок на Windows, скомпілювати його в байт-код і запустити його на будь-якій іншій платформі, яка підтримує віртуальну машину Java (JVM). Таким чином, JVM служить рівнем абстракції між кодом і обладнанням.</p>\n\n<p><strong>GC</strong> — garbage collector (сміттєзбирач).</p>\n\n<p><strong>Мова для розподіленого програмування та зручної віддаленої спільної роботи</strong> — специфічна методологія розподілених обчислень для Java називається Remote Method Invocation (RMI). RMI дозволяє використовувати всі переваги Java: безпеку, незалежність від платформи та об'єктно-орієнтоване програмування для розподілених обчислень. Крім того, Java також підтримує програмування сокетів та методологію розподілу CORBA для обміну об'єктами між програмами, написаними на різних мовах.</p>\n\n<p><strong>Автоматичне керування пам'яттю</strong> — розробникам Java не потрібно вручну писати код для керування пам'яттю завдяки автоматичному керуванню пам'яттю (AMM).</p>\n\n<p><strong>Багатопоточність</strong> — потік — найменша одиниця обробки в програмуванні. Щоб максимально ефективно використовувати час процесора, Java дозволяє запускати потоки одночасно, що називається багатозадачністю.</p>\n\n<p><strong>Стабільність і спільнота</strong> — спільнота розробників Java не має собі рівних. Близько 45% респондентів опитування StackOverflow (2018) використовують Java.</p>","topicName":"Core-1"},{"id":22,"questionText":"Які недоліки у Java?","answer":"<p><strong>Платне комерційне використання (з 2019)</strong> — починаючи з 2019 року, для комерційного використання деяких версій Java потрібна оплата ліцензії.</p>\n\n<p><strong>Низька продуктивність</strong> — пов'язана з компіляцією та абстракцією за допомогою віртуальної машини, а також роботою збирача сміття (GC). Це є наслідком кросплатформенності, зворотної сумісності та швидкості розгортання.</p>\n\n<p><strong>Не розвинуті інструменти для створення GUI-додатків</strong> — на чистій Java складно створювати сучасні графічні інтерфейси без додаткових бібліотек або фреймворків.</p>\n\n<p><strong>Багатослівний код</strong> — Java вимагає від програмістів більш детального опису дій англійськими словами. Це робить мову зрозумілішою для неспеціалістів, але менш компактною порівняно з іншими мовами.</p>","topicName":"Core-1"},{"id":23,"questionText":"Що таке JDK? Що входить в нього?","answer":"<p><strong>JDK (Java Development Kit)</strong> — набір інструментів для розробки додатків на Java. Він містить <strong>JRE</strong> (середовище для запуску Java-програм), а також додаткові інструменти для програмістів: компілятор Java, стандартні бібліотеки класів, приклади, документацію та утиліти.</p>\n\n<p><strong>Коротко</strong>: JDK — це середовище для розробки програм на Java, яке включає JRE. JRE, у свою чергу, забезпечує запуск Java-програм і містить JVM — інтерпретатор байт-коду Java.</p>","topicName":"Core-1"},{"id":24,"questionText":"Що таке JRE? Що входить в нього?","answer":"<p><strong>JRE (Java Runtime Environment)</strong> — середовище часу виконання Java, яке забезпечує роботу Java-додатків. Це мінімально необхідна реалізація віртуальної машини Java для запуску програм.</p>\n\n<p>JRE складається з <strong>JVM</strong> (віртуальної машини Java) та стандартного набору бібліотек класів Java.</p>","topicName":"Core-1"},{"id":25,"questionText":"Що таке JVM?","answer":"<p><strong>JVM (Java Virtual Machine)</strong> — віртуальна машина Java, яка є основною частиною середовища часу виконання Java (<strong>JRE</strong>).</p>\n\n<p>JVM виконує <strong>байт-код Java</strong>, що був створений компілятором із вихідного коду Java-програми. Крім того, JVM може виконувати програми, написані на інших мовах програмування, якщо вони були скомпільовані у сумісний байт-код.</p>","topicName":"Core-1"},{"id":26,"questionText":"Що таке байт-код?","answer":"<p><strong>Байт-код Java</strong> — це набір інструкцій, який створює компілятор із вихідного коду Java-програми та який виконується <strong>JVM</strong>.</p>\n\n<p>Він містить приблизно <strong>200 інструкцій</strong>, причому близько <strong>56</strong> залишаються в резерві. Кожна інструкція займає <strong>1 байт</strong>.</p>","topicName":"Core-1"},{"id":27,"questionText":"Що таке завантажувач класів (classloader)?","answer":"<h2>Що таке завантажувач класів (ClassLoader) в Java?</h2>\n\n<p><strong>Завантажувач класів</strong> — це спеціальний Java-об’єкт, який відповідає за пошук та завантаження класів у пам’ять під час роботи програми.</p>\n\n<p>Коли Java-програма запускається, створюються три основні завантажувачі:</p>\n\n<ol>\n  <li>\n    <strong>Базовий завантажувач (Bootstrap ClassLoader)</strong>  \n    <ul>\n      <li>Завантажує основні системні класи Java (пакети <code>java.*</code> з файлів <code>rt.jar</code> та <code>i18n.jar</code>).</li>\n      <li>Є частиною JVM, його неможливо створити вручну в коді.</li>\n    </ul>\n  </li>\n\n  <li>\n    <strong>Завантажувач розширень (Extension ClassLoader)</strong>  \n    <ul>\n      <li>Завантажує додаткові пакети з каталогу <code>&lt;JAVA_HOME&gt;/lib/ext</code> або з іншого місця, вказаного в параметрі <code>java.ext.dirs</code>.</li>\n      <li>Дозволяє додавати нові можливості без змін у коді програми.</li>\n    </ul>\n  </li>\n\n  <li>\n    <strong>Системний завантажувач (System/Application ClassLoader)</strong>  \n    <ul>\n      <li>Завантажує класи, шляхи до яких вказані в змінній середовища <code>CLASSPATH</code> або у параметрах запуску <code>-classpath</code> / <code>-cp</code>.</li>\n    </ul>\n  </li>\n</ol>\n\n<h3>Як працюють завантажувачі?</h3>\n<p>Завантажувачі організовані у вигляді ієрархії. Кожен (крім базового) спочатку звертається до свого \"батьківського\" завантажувача, і тільки якщо той не знайде клас — пробує завантажити його сам.</p>\n\n<p>Такий підхід забезпечує надійність: спочатку шукаються класи у перевірених джерелах (Core API), потім у розширеннях, і лише в кінці — у локальних шляхах.</p>","topicName":"Core-1"},{"id":28,"questionText":"Як відбувається процес завантаження класу в Java і які його особливості?","answer":"<p>Процес завантаження класу в Java проходить у три основні етапи:</p>\n\n<ol>\n  <li>\n    <strong>Завантаження (Loading)</strong> – JVM знаходить файл класу та завантажує його в пам’ять. \n    На цьому етапі програма ще не знає про методи чи поля класу — просто зчитується базова структура.\n  </li>\n  <li>\n    <strong>Зв’язування (Linking)</strong> – складається з трьох кроків:\n    <ul>\n      <li><strong>Перевірка (Verification)</strong> – JVM перевіряє, чи байт-код відповідає правилам безпеки та специфікації.</li>\n      <li><strong>Підготовка (Preparation)</strong> – створюються необхідні структури, виділяється пам’ять під поля та методи.</li>\n      <li><strong>Розв’язування (Resolving)</strong> – JVM підвантажує інші класи, на які посилається даний клас.</li>\n    </ul>\n  </li>\n  <li>\n    <strong>Ініціалізація (Initialization)</strong> – виконуються статичні блоки коду та встановлюються початкові значення полів.\n  </li>\n</ol>\n\n<h3>Особливості завантаження класів у Java:</h3>\n<ul>\n  <li><strong>Відкладене завантаження (Lazy loading)</strong> – класи завантажуються лише тоді, коли вони реально потрібні.</li>\n  <li><strong>Перевірка безпеки (Type safety)</strong> – JVM контролює типи під час завантаження, щоб уникнути помилок та атак.</li>\n  <li><strong>Програмоване завантаження</strong> – можна створити власний завантажувач класів, щоб керувати процесом завантаження.</li>\n  <li><strong>Множинні простори імен</strong> – один і той же байт-код, завантажений різними завантажувачами, вважатиметься різними класами.</li>\n</ul>\n\n<h3>Способи ініціювати завантаження класу:</h3>\n<ul>\n  <li><strong>Явний</strong>: виклик <code>ClassLoader.loadClass()</code> або <code>Class.forName()</code>.</li>\n  <li><strong>Неявний</strong>: JVM автоматично завантажує клас, коли він вперше потрібен програмі.</li>\n</ul>","topicName":"Core-1"},{"id":29,"questionText":"Що таке JIT-компіляція в Java?","answer":"<p>\n  <strong>JIT-компіляція</strong> (англ. <em>Just-In-Time compilation</em>, або «компіляція на льоту») — це спосіб прискорення роботи програм,\n  які виконуються у вигляді байт-коду.\n</p>\n\n<h3>Як це працює:</h3>\n<ol>\n  <li>Звичайно байт-код Java інтерпретується JVM, що трохи повільніше за виконання машинного коду.</li>\n  <li>JIT-компілятор під час виконання програми бере байт-код і перетворює його у <strong>машинний код</strong>, зрозумілий процесору.</li>\n  <li>Отриманий машинний код зберігається і використовується повторно, що значно прискорює наступні виклики того ж коду.</li>\n</ol>\n\n<h3>Переваги JIT-компіляції:</h3>\n<ul>\n  <li>Підвищує швидкість виконання програм.</li>\n  <li>Дозволяє оптимізувати код, враховуючи реальні умови роботи програми.</li>\n  <li>Поєднує зручність кросплатформенності байт-коду та швидкість машинного коду.</li>\n</ul>\n\n<h3>Простими словами:</h3>\n<p>\n  Без JIT — програма перекладається для процесора «поступово, по рядках».\n  З JIT — програма під час роботи переводить часто виконувані частини одразу у швидкий «рідний» код процесора,\n  щоб більше не витрачати час на переклад.\n</p>","topicName":"Core-1"},{"id":30,"questionText":"Які бувають види посилань у Java?","answer":"<p>\n  У Java існує <strong>4 типи посилань</strong>. Вони визначають, як об’єкти поводяться під час роботи\n  <em>Garbage Collector</em> (збірника сміття), тобто коли і як пам’ять під об’єкти буде звільнятися.\n</p>\n\n<h3>1. Сильні посилання (StrongReference)</h3>\n<ul>\n  <li>Це звичайний тип посилання, який ми використовуємо щодня в коді.</li>\n  <li>Об’єкт із сильним посиланням ніколи не буде видалений збирачем сміття, доки на нього існує хоча б одне таке посилання.</li>\n  <li><strong>Приклад:</strong> <code>String text = \"Hello\";</code></li>\n</ul>\n\n<h3>2. М’які посилання (SoftReference)</h3>\n<ul>\n  <li>Використовуються для кешування даних.</li>\n  <li>GC видаляє об’єкт, на який є лише м’які посилання, тільки якщо не вистачає пам’яті.</li>\n  <li><strong>Приклад:</strong> <code>SoftReference&lt;MyObject&gt; ref = new SoftReference<>(new MyObject());</code></li>\n</ul>\n\n<h3>3. Слабкі посилання (WeakReference)</h3>\n<ul>\n  <li>GC видаляє об’єкт одразу, як тільки на нього немає сильних або м’яких посилань.</li>\n  <li>Корисно для структур даних на кшталт <code>WeakHashMap</code>.</li>\n  <li><strong>Приклад:</strong> <code>WeakReference&lt;MyObject&gt; ref = new WeakReference<>(new MyObject());</code></li>\n</ul>\n\n<h3>4. Фантомні посилання (PhantomReference)</h3>\n<ul>\n  <li>Не дають доступу до об’єкта — використовуються лише для відслідковування моменту, коли об’єкт видаляється з пам’яті.</li>\n  <li>Часто застосовуються для роботи з ресурсами, які потрібно очистити перед звільненням пам’яті.</li>\n  <li><strong>Приклад:</strong> <code>PhantomReference&lt;MyObject&gt; ref = new PhantomReference<>(new MyObject(), queue);</code></li>\n</ul>\n\n<h3>Висновок:</h3>\n<p>\n  Тип посилання визначає, як швидко і за яких умов <em>Garbage Collector</em> зможе видалити об’єкт із пам’яті.\n  Сильні — зберігають об’єкт максимально довго, фантомні — лише сигналізують про його знищення.\n</p>","topicName":"Core-1"},{"id":31,"questionText":"Для чого потрібен збирач сміття (Garbage Collector) у Java?","answer":"<p>\n  Збирач сміття відповідає за <strong>автоматичне управління пам’яттю</strong> у Java-програмах.\n  Його основні завдання:\n</p>\n<ul>\n  <li><strong>Виявлення сміття</strong> — визначення об’єктів, які більше не використовуються (на них немає жодних посилань).</li>\n  <li><strong>Звільнення пам’яті</strong> — очищення пам’яті, яку займали ці об’єкти.</li>\n</ul>","topicName":"Core-1"},{"id":32,"questionText":"Як збирач сміття виявляє невикористовувані об’єкти?","answer":"<p>Існують два основні підходи:</p>\n\n<h3>Підрахунок посилань (Reference Counting)</h3>\n<ul>\n  <li>Кожен об’єкт має лічильник кількості посилань на нього.</li>\n  <li>Якщо лічильник стає <code>0</code> — об’єкт можна видаляти.</li>\n  <li><strong>Недоліки:</strong> складно уникнути помилок у підрахунку та важко виявляти циклічні залежності.</li>\n</ul>\n\n<h3>Трасування (Tracing)</h3>\n<p>\n  Використовується в <strong>HotSpot JVM</strong>. Ідея — живими вважаються тільки ті об’єкти,\n  до яких можна дістатися від <strong>кореневих точок (GC Roots)</strong>.\n</p>\n<p>GC Roots бувають:</p>\n<ul>\n  <li>Локальні змінні та параметри методів.</li>\n  <li>Потоки.</li>\n  <li>Статичні змінні.</li>\n  <li>Посилання з JNI.</li>\n</ul>\n<p>\n  Об’єкти, до яких неможливо дістатися від кореневих точок, — це сміття.\n</p>","topicName":"Core-1"},{"id":33,"questionText":"Як відбувається очищення пам’яті?","answer":"<p>Є два основні методи:</p>\n\n<h3>Copying Collectors</h3>\n<ul>\n  <li>Пам’ять ділиться на <code>from-space</code> і <code>to-space</code>.</li>\n  <li>Об’єкти створюються у <code>from-space</code>.</li>\n  <li>Коли пам’ять заповнена, живі об’єкти копіюються в <code>to-space</code>, а <code>from-space</code> очищується.</li>\n  <li>Потім простори міняються місцями.</li>\n  <li><strong>Плюс:</strong> об’єкти розміщуються компактно.</li>\n  <li><strong>Мінуси:</strong> зупинка програми під час копіювання; у гіршому випадку потрібно вдвічі більше пам’яті.</li>\n</ul>\n\n<h3>Mark-and-Sweep</h3>\n<ul>\n  <li>Програма зупиняється.</li>\n  <li>GC позначає живі об’єкти.</li>\n  <li>Непозначені об’єкти видаляються, а пам’ять додається у список вільної пам’яті.</li>\n  <li><strong>Мінуси:</strong> довгі зупинки; можливе фрагментування пам’яті без \"compacting\".</li>\n</ul>","topicName":"Core-1"},{"id":34,"questionText":"Який підхід використовується в Java?","answer":"<p>\n  <strong>HotSpot VM</strong> застосовує <strong>Generational Garbage Collection</strong> — комбінований підхід,\n  який ділить об’єкти на покоління:\n</p>\n<ul>\n  <li>Більшість новостворених об’єктів швидко стають сміттям.</li>\n  <li>Між \"старими\" і \"новими\" об’єктами зазвичай мало зв’язків.</li>\n  <li>Для різних поколінь використовуються різні алгоритми збору сміття, що робить процес ефективнішим.</li>\n</ul>","topicName":"Core-1"},{"id":35,"questionText":"Як працює збирач сміття (Garbage Collector) у Java?","answer":"<p>\n  Збирач сміття — це механізм <strong>автоматичного звільнення пам’яті</strong> у Java. \n  Його головна задача — очищувати <em>кучу</em> (heap) від об’єктів, які більше не використовуються.\n</p>","topicName":"Core-1"},{"id":36,"questionText":"Як створюються та зникають об’єкти?","answer":"<ul>\n  <li>Об’єкти створюються за допомогою оператора <code>new</code>.</li>\n  <li>Щоб об’єкт став непотрібним, достатньо:\n    <ul>\n      <li>Перестати на нього посилатися (присвоїти змінній <code>null</code> або інший об’єкт).</li>\n      <li>Дати методу завершитися, щоб його локальні змінні автоматично зникли.</li>\n    </ul>\n  </li>\n  <li>Об’єкти, на які немає жодного посилання, називаються <strong>сміттям (garbage)</strong>.</li>\n</ul>","topicName":"Core-1"},{"id":37,"questionText":"Що вважається \"живим\" об’єктом?","answer":"<p>\n  Якщо на об’єкт можна дістатися від <strong>кореневих посилань (GC Roots)</strong>, він вважається живим.\n</p>\n<p>GC Roots включають:</p>\n<ul>\n  <li>Локальні змінні та параметри методів.</li>\n  <li>Потоки.</li>\n  <li>Статичні змінні.</li>\n  <li>Посилання з JNI.</li>\n</ul>","topicName":"Core-1"},{"id":38,"questionText":"Коли запускається збирач сміття?","answer":"<ul>\n  <li>Запуск відбувається автоматично, коли JVM вважає це за потрібне.</li>\n  <li>Може пройти вся програма без жодного запуску GC, якщо пам’яті достатньо.</li>\n</ul>","topicName":"Core-1"},{"id":39,"questionText":"Чи можна впливати на ефективність GC?","answer":"<p>\n  Так. Хоча програміст не керує самим процесом збору сміття, \n  <strong>ефективність</strong> можна підвищити, якщо:\n</p>\n<ul>\n  <li>Не створювати надлишкову кількість об’єктів.</li>\n  <li>Повторно використовувати існуючі об’єкти там, де це можливо.</li>\n  <li>Уникати зайвих алокацій у циклах.</li>\n</ul>\n<p>\n  Менше створених об’єктів = менше сміття = рідший запуск GC = вища продуктивність.\n</p>","topicName":"Core-1"},{"id":40,"questionText":"Які види збирачів сміття у JVM HotSpot існують ?","answer":"<p>\n  Віртуальна машина Java HotSpot пропонує 4 основні типи збирачів сміття, \n  кожен з яких має свої особливості та сфери застосування.\n</p>\n\n<hr>\n\n<h3>1. Serial GC (послідовний)</h3>\n<ul>\n  <li>Найпростіший збирач сміття.</li>\n  <li>Підходить для додатків із <strong>невеликим обсягом даних</strong> та низькими вимогами до затримок.</li>\n  <li>Рідко використовується у сучасних системах, але може бути вибраний JVM за замовчуванням на слабких ПК.</li>\n  <li>Активація: <code>-XX:+UseSerialGC</code></li>\n</ul>\n\n<hr>\n\n<h3>2. Parallel GC (паралельний)</h3>\n<ul>\n  <li>Базується на принципах Serial GC, але додає <strong>паралелізм</strong> до деяких етапів роботи.</li>\n  <li>Може автоматично налаштовуватися під вимоги продуктивності.</li>\n  <li>Активація: <code>-XX:+UseParallelGC</code></li>\n</ul>\n\n<hr>\n\n<h3>3. Concurrent Mark Sweep (CMS)</h3>\n<ul>\n  <li>Зменшує <strong>максимальні затримки</strong> завдяки виконанню частини роботи паралельно з основними потоками.</li>\n  <li>Добре підходить для роботи з <strong>великими обсягами даних</strong> у пам’яті.</li>\n  <li>Активація: <code>-XX:+UseConcMarkSweepGC</code></li>\n</ul>\n\n<hr>\n\n<h3>4. Garbage-First (G1)</h3>\n<ul>\n  <li>Сучасний збирач, розроблений як заміна CMS.</li>\n  <li>Оптимізований для <strong>багатоядерних серверів</strong> та систем з великим обсягом даних.</li>\n  <li>Часто використовується у <strong>серверних застосунках</strong>.</li>\n  <li>Активація: <code>-XX:+UseG1GC</code></li>\n</ul>","topicName":"Core-1"},{"id":41,"questionText":"Алгоритм роботи Serial Garbage Collector у JVM HotSpot","answer":"<p>\n  Serial Garbage Collector був одним із перших збирачів сміття у HotSpot VM. \n  Під час його роботи додаток тимчасово <strong>призупиняється</strong> і відновлює роботу лише після завершення збірки сміття. \n  Пам’ять поділяється на три основні області:\n</p>\n\n<ul>\n  <li><strong>Young Generation</strong> – тут створюються нові об’єкти.</li>\n  <li><strong>Old Generation</strong> – сюди переміщуються об’єкти, які пережили <em>minor garbage collection</em>.</li>\n  <li><strong>Permanent Generation</strong> – містить метадані об’єктів, пул рядків (String pool), Class Data Sharing (CDS). Поділяється на область тільки для читання та для читання-запису.</li>\n</ul>\n\n<h3>Молоде покоління (Young Generation)</h3>\n<p>Складається з трьох областей:</p>\n<ul>\n  <li><strong>Eden</strong> – більшість нових об’єктів створюється тут.</li>\n  <li><strong>Survivor Spaces</strong> – <em>From space</em> і <em>To space</em>, куди переміщуються об’єкти, що вижили після хоча б однієї збірки сміття.</li>\n</ul>\n<p>\n  Коли Young Generation заповнюється, відбувається <strong>minor collection</strong>:\n</p>\n<ol>\n  <li>Живі об’єкти з Eden копіюються у To space.</li>\n  <li>Живі об’єкти з From space також копіюються у To space.</li>\n  <li>Об’єкти, що досягли порогу «старості» або не вмістилися в To space, переміщуються в Old Generation.</li>\n  <li>Ролі From і To space міняються, Eden стає порожньою.</li>\n</ol>\n<p>Такий алгоритм називається <strong>копіюючим (copying)</strong>, бо збирач просто копіює живі об’єкти з однієї області пам’яті в іншу.</p>\n\n<h3>Старе покоління (Old Generation)</h3>\n<p>Для Old Generation використовується алгоритм <strong>mark-sweep-compact</strong>:</p>\n<ol>\n  <li><strong>Mark (помітка)</strong> – збирач позначає всі живі об’єкти.</li>\n  <li><strong>Sweep (очищення)</strong> – видаляються всі непозначені об’єкти.</li>\n  <li><strong>Compact (уплотнення)</strong> – живі об’єкти переміщуються на початок Old Generation, щоб уникнути фрагментації.</li>\n</ol>\n<p>Це дозволяє швидко виділяти пам’ять для нових об’єктів за допомогою <em>bump-the-pointer</em>: вказівник початку вільної пам’яті просто зсувається на розмір нового об’єкта.</p>\n\n<h3>Особливості Serial GC</h3>\n<ul>\n  <li>Ідеально підходить для додатків із купою до 200 МБ на клієнтських машинах.</li>\n  <li>Використовує модель <em>stop-the-world</em>, тому при великих обсягах пам’яті паузи можуть бути тривалими.</li>\n  <li>Не оптимально використовує багатоядерні процесори.</li>\n</ul>","topicName":"Core-1"},{"id":42,"questionText":"Що таке <code>finalize()</code>? З чим це пов'язано?","answer":"<p>\n    Метод <code>finalize()</code> у JVM виконує функціональність, схожу на деструктори в C++. \n    Він викликається перед знищенням об'єкта збирачем сміття і дозволяє виконати дії для \n    коректного видалення об'єкта, наприклад:\n  </p>\n  <ul>\n    <li>Закриття мережевих з'єднань</li>\n    <li>Закриття підключень до бази даних</li>\n    <li>Зняття блокувань файлів</li>\n  </ul>\n  <p>\n    Після виклику <code>finalize()</code> об'єкт знову підлягає збору сміття. \n    Це може стати проблемою, оскільки метод <code>finalize()</code> може затримати \n    вивільнення пам'яті.\n  </p>\n  <p>\n    Важливо знати:\n  </p>\n  <ul>\n    <li>Виклик <code>finalize()</code> не гарантований — додаток може завершитися раніше.</li>\n    <li>Об'єкт може \"відродитися\", якщо метод <code>finalize()</code> зберігає посилання на нього. Це вважається антипаттерном.</li>\n    <li>\"Відродити\" об'єкт можна лише один раз.</li>\n  </ul>","topicName":"Core-1"},{"id":43,"questionText":"Що станеться із збирачем сміття, якщо метод <code>finalize()</code> працює довго або викликає виняток?","answer":"<p>\n    Виклик <code>finalize()</code> відбувається в окремому потоці <code>Finalizer</code> \n    (<code>java.lang.ref.Finalizer.FinalizerThread</code>), який створюється під час запуску JVM.\n  </p>\n  <p>\n    Основні моменти роботи цього механізму:\n  </p>\n  <ul>\n    <li>Методи <code>finalize()</code> виконуються послідовно у порядку додавання в чергу збирачем сміття.</li>\n    <li>Якщо <code>finalize()</code> \"зависає\" або працює довго, це впливає лише на потік <code>Finalizer</code>, а не на роботу основного збирача сміття.</li>\n    <li>Об'єкти без <code>finalize()</code> видаляються нормально, незалежно від завантаження потоку <code>Finalizer</code>.</li>\n    <li>Якщо під час виконання <code>finalize()</code> виникає виняток, він ігнорується методом <code>runFinalizer()</code> потоку <code>Finalizer</code>. Це не впливає на збирач сміття.</li>\n  </ul>","topicName":"Core-1"},{"id":44,"questionText":"Що відрізняє <code>final</code>, <code>finally</code> і <code>finalize()</code>?","answer":"<h4>Модифікатор <code>final</code>:</h4>\n  <ul>\n    <li>Клас не може мати нащадків.</li>\n    <li>Метод не може бути перевизначений у класах-нащадках.</li>\n    <li>Поле не може змінити своє значення після ініціалізації.</li>\n    <li>Локальні змінні не можуть змінювати значення після призначення.</li>\n    <li>Параметри методів не можуть змінювати своє значення всередині методу.</li>\n  </ul>\n\n  <h4>Оператор <code>finally</code>:</h4>\n  <p>\n    Гарантує виконання коду в ньому незалежно від того, які винятки виникають і як вони обробляються у блоках <code>try-catch</code>.\n  </p>\n\n  <h4>Метод <code>finalize()</code>:</h4>\n  <p>\n    Викликається перед видаленням об'єкта збирачем сміття для виконання додаткового очищення або ресурсів.\n  </p>","topicName":"Core-1"},{"id":45,"questionText":"Що таке Heap та Stack пам'ять у Java? Яка між ними різниця?","answer":"<h4>Heap (куча):</h4>\n  <p>\n    Використовується JVM для виділення пам'яті під об'єкти та класи. \n    Нові об'єкти створюються в кучі, яка також є областю роботи збирача сміття. \n    Об'єкти в кучі мають глобальний доступ і доступні з будь-якої частини програми.\n  </p>\n\n  <h4>Stack (стек):</h4>\n  <p>\n    Область зберігання даних у RAM, яка використовується для локальних змінних методів. \n    Кожного разу при виклику методу створюється новий блок у стеку, який містить примітиви \n    та посилання на об'єкти в кучі. Після завершення методу блок видаляється. \n    Стек працює за принципом LIFO (останній зайшов – перший вийшов) і значно менший за обсягом за кучу.\n  </p>\n\n  <h4>Основні відмінності Heap і Stack:</h4>\n  <ul>\n    <li>Heap доступна всім потокам програми, Stack – тільки одному потоку.</li>\n    <li>Об'єкти завжди створюються в Heap, в Stack зберігаються лише локальні змінні примітивних типів та посилання на об'єкти.</li>\n    <li>Об'єкти в Heap доступні з будь-якої точки програми, Stack недоступна іншим потокам.</li>\n    <li>Stack існує лише під час виконання методу, Heap – від початку до кінця роботи програми.</li>\n    <li>Переповнення Stack призводить до <code>java.lang.StackOverflowError</code>, переповнення Heap – до <code>java.lang.OutOfMemoryError: Java Heap Space</code>.</li>\n    <li>Розмір Stack значно менший за Heap.</li>\n    <li>Через простоту розподілу пам'яті Stack працює швидше за Heap.</li>\n  </ul>\n\n  <h4>Налаштування розміру пам'яті в JVM:</h4>\n  <ul>\n    <li>Heap: <code>-Xms</code> (початковий розмір), <code>-Xmx</code> (максимальний розмір)</li>\n    <li>Stack: <code>-Xss</code> (розмір стека для одного потоку)</li>\n  </ul>","topicName":"Core-1"},{"id":46,"questionText":"Чи завжди примітивні типи даних зберігаються в стеці, а екземпляри посилальних типів – в кучі?","answer":"<p>\n    Не зовсім. Варто розрізняти локальні змінні та поля об'єктів:\n  </p>\n  <ul>\n    <li>\n      Локальні примітивні змінні методів зазвичай зберігаються в <strong>стеку</strong>.\n    </li>\n    <li>\n      Примітивні поля об'єктів (тобто ті, що належать класу) зберігаються в <strong>кучі</strong>, разом із самим об'єктом.\n    </li>\n    <li>\n      Будь-який об'єкт (що створюється явно або неявно через <code>new</code>) зберігається в <strong>кучі</strong>.\n    </li>\n  </ul>","topicName":"Core-1"},{"id":47,"questionText":"Які ключові слова існують в Java?","answer":"<p>У Java існують наступні ключові слова:</p>\n  <ul>\n    <li>abstract</li>\n    <li>assert</li>\n    <li>break</li>\n    <li>case</li>\n    <li>catch</li>\n    <li>class</li>\n    <li>const* (зарезервоване слово, не використовується)</li>\n    <li>continue</li>\n    <li>default</li>\n    <li>do</li>\n    <li>else</li>\n    <li>enum</li>\n    <li>extends</li>\n    <li>final</li>\n    <li>finally</li>\n    <li>for</li>\n    <li>goto* (зарезервоване слово, не використовується)</li>\n    <li>if</li>\n    <li>implements</li>\n    <li>import</li>\n    <li>instanceof</li>\n    <li>interface</li>\n    <li>native</li>\n    <li>new</li>\n    <li>package</li>\n    <li>return</li>\n    <li>static</li>\n    <li>strictfp</li>\n    <li>super</li>\n    <li>switch</li>\n    <li>synchronized</li>\n    <li>this</li>\n    <li>throw</li>\n    <li>throws</li>\n    <li>transient</li>\n    <li>try</li>\n    <li>void</li>\n    <li>volatile</li>\n    <li>while</li>\n  </ul>\n  <p><em>* – зарезервоване слово, яке не використовується</em></p>","topicName":"Core-1"},{"id":48,"questionText":"Для чого використовується оператор <code>assert</code>?","answer":"<p>\n    <code>assert</code> (ствердження) — це конструкція, яка дозволяє перевіряти \n    припущення про значення даних у будь-якій частині програми. Якщо перевірка \n    не проходить, програма зазвичай аварійно завершується, вказуючи місце помилки.\n  </p>\n  \n  <h4>Навіщо це потрібно?</h4>\n  <ul>\n    <li>Допомагає швидко знаходити помилки у коді.</li>\n    <li>Полегшує перевірку результатів виконання коду під час рефакторингу.</li>\n    <li>Зазвичай використовується під час розробки та тестування, але вимикається у реліз-версії.</li>\n  </ul>\n\n  <h4>Правила використання</h4>\n  <ul>\n    <li>Не можна змінювати стан програми всередині <code>assert</code>.</li>\n    <li>Вилучення <code>assert</code> не повинно впливати на поведінку програми.</li>\n  </ul>\n\n  <h4>Синтаксис</h4>\n  <p>\n    <code>assert [булевий вираз];</code> <br>\n    <code>assert [булевий вираз] : [повідомлення];</code>\n  </p>\n  <p>\n    Якщо вираз <code>false</code>, генерується виняток <code>java.lang.AssertionError</code>. \n    Друга форма дозволяє додати детальне повідомлення, яке буде передано конструктору <code>AssertionError</code>.\n  </p>","topicName":"Core-1"},{"id":49,"questionText":"Які примітивні типи даних існують в Java?","answer":"<table border=\"1\" cellpadding=\"8\" cellspacing=\"0\">\n  <thead>\n    <tr style=\"background-color:#c6e2ff;\">\n      <th>Тип даних</th>\n      <th>Значення за замовчуванням</th>\n      <th>Розмір</th>\n      <th>Діапазон значень</th>\n      <th>Приклад</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>boolean</td>\n      <td>false</td>\n      <td>1 біт</td>\n      <td>true / false</td>\n      <td>boolean b = true;</td>\n    </tr>\n    <tr>\n      <td>char</td>\n      <td>'\\u0000'</td>\n      <td>2 байти (16 біт)</td>\n      <td>0 – 65,535</td>\n      <td>char c = 'a';</td>\n    </tr>\n    <tr>\n      <td>byte</td>\n      <td>0</td>\n      <td>1 байт (8 біт)</td>\n      <td>-128 – 127</td>\n      <td>byte b = 10;</td>\n    </tr>\n    <tr>\n      <td>short</td>\n      <td>0</td>\n      <td>2 байти (16 біт)</td>\n      <td>-32,768 – 32,767</td>\n      <td>short s = 11;</td>\n    </tr>\n    <tr>\n      <td>int</td>\n      <td>0</td>\n      <td>4 байти (32 біт)</td>\n      <td>-2,147,483,648 – 2,147,483,647</td>\n      <td>int i = 10;</td>\n    </tr>\n    <tr>\n      <td>long</td>\n      <td>0L</td>\n      <td>8 байтів (64 біт)</td>\n      <td>-9,223,372,036,854,775,808 – 9,223,372,036,854,775,807</td>\n      <td>long l = 100012;</td>\n    </tr>\n    <tr>\n      <td>float</td>\n      <td>0.0f</td>\n      <td>4 байти (32 біт)</td>\n      <td>1.4e-45 – 3.4e+38</td>\n      <td>float f = 10.3f;</td>\n    </tr>\n    <tr>\n      <td>double</td>\n      <td>0.0d</td>\n      <td>8 байтів (64 біт)</td>\n      <td>4.9e-324 – 1.7e+308</td>\n      <td>double d = 11.123;</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><strong>Примітки:</strong></p>\n<ul>\n  <li>Примітивні числа (byte, short, int, long, float, double) ініціалізуються <code>0</code> або <code>0.0</code>.</li>\n  <li><code>char</code> – ініціалізується символом <code>\\u0000</code>.</li>\n  <li><code>boolean</code> – ініціалізується значенням <code>false</code>.</li>\n  <li>Об'єкти (включаючи <code>String</code>) – ініціалізуються <code>null</code>.</li>\n</ul>","topicName":"Core-1"},{"id":50,"questionText":"Що таке char?","answer":"<p>16-розрядне беззнакове ціле, що представляє собою символ UTF-16 (літери та цифри).</p>","topicName":"Core-1"},{"id":51,"questionText":"Скільки пам'яті займає boolean?","answer":"<p>Тип boolean займає 1 біт, але в JVM він зазвичай виділяє 1 байт для зручності адресації.</p>","topicName":"Core-1"},{"id":52,"questionText":"Логічні оператори в Java","answer":"<h3>Логічні оператори</h3>\n<ul>\n  <li>&amp;: Логічне AND (І);</li>\n  <li>&amp;&amp;: Скорочене AND;</li>\n  <li>|: Логічне OR (АБО);</li>\n  <li>||: Скорочене OR;</li>\n  <li>^: Логічне XOR (виключне OR (АБО));</li>\n  <li>!: Логічне унарне NOT (НІ);</li>\n  <li>&amp;=: AND з присвоєнням;</li>\n  <li>|=: OR з присвоєнням;</li>\n  <li>^=: XOR з присвоєнням;</li>\n  <li>==: Рівно;</li>\n  <li>!=: Не рівно;</li>\n  <li>?:: Тернарний (трійковий) умовний оператор.</li>\n</ul>","topicName":"Core-1"},{"id":53,"questionText":"Тернарний умовний оператор","answer":"<p>Тернарний оператор дозволяє замінити деякі конструкції <code>if-then-else</code>. Його запис має вигляд:</p>\n<pre><code>умова ? вираз1 : вираз2</code></pre>\n<p>Якщо <strong>умова</strong> істинна (<code>true</code>), обчислюється <strong>вираз1</strong>, і його результат стає результатом всього оператора. Якщо <strong>умова</strong> хибна (<code>false</code>), обчислюється <strong>вираз2</strong>, і його результат стає результатом оператора.</p>\n<p>Обидва вирази (<strong>вираз1</strong> і <strong>вираз2</strong>) повинні повертати значення одного або сумісного типу.</p>","topicName":"Core-1"},{"id":54,"questionText":"Операції роботи з бітами","answer":"<ul>\n  <li>~: Побітовий унарний оператор NOT;</li>\n  <li>&amp;: Побітовий AND;</li>\n  <li>&amp;=: Побітовий AND з присвоєнням;</li>\n  <li>|: Побітовий OR;</li>\n  <li>|=: Побітовий OR з присвоєнням;</li>\n  <li>^: Побітовий виключаючий XOR;</li>\n  <li>^=: Побітовий виключаючий XOR з присвоєнням;</li>\n  <li>&gt;&gt;: Зсув вправо (ділення на 2 у ступені зсуву);</li>\n  <li>&gt;&gt;=: Зсув вправо з присвоєнням;</li>\n  <li>&gt;&gt;&gt;: Зсув вправо без урахування знака;</li>\n  <li>&gt;&gt;&gt;=: Зсув вправо без урахування знака з присвоєнням;</li>\n  <li>&lt;&lt;: Зсув вліво (множення на 2 у ступені зсуву);</li>\n  <li>&lt;&lt;=: Зсув вліво з присвоєнням;</li>\n</ul>","topicName":"Core-1"},{"id":55,"questionText":"Що таке обгортки-класи?","answer":"<p>Обгортка – це спеціальний клас, який зберігає всередині себе значення примітивного типу.</p>\n<p>Обгортки потрібні для роботи з дженеріками (наприклад, у колекціях) та іншими об'єктами.</p>","topicName":"Core-1"},{"id":56,"questionText":"Що таке автоупаковка та авторозпакування?","answer":"<p><strong>Автоупаковка</strong> (Autoboxing) – це автоматичне перетворення примітивного типу на відповідний клас-обгортку. Наприклад, присвоєння змінної типу <code>int</code> змінній типу <code>Integer</code> відбувається без явного створення об’єкта класу.</p>\n\n<p><strong>Авторозпакування</strong> (Unboxing) – це автоматичне перетворення об’єкта класу-обгортки назад у примітивний тип. Наприклад, присвоєння значення <code>Integer</code> змінній типу <code>int</code>.</p>\n\n<p>Ці механізми потрібні для зручності роботи з колекціями та дженеріками, де використовуються об’єкти, а не примітиви. Все відбувається автоматично, без необхідності явно створювати об’єкти або викликати методи.</p>\n\n<h4>Особливості автоупаковки:</h4>\n<ul>\n  <li>Автоупаковка відбувається при прямому присвоєнні примітиву класу-обгортці або при передачі примітиву як параметра методу, що приймає об’єкт класу-обгортки.</li>\n  <li>Підтримуються всі стандартні обгортки: <code>Byte, Short, Integer, Long, Float, Double, Character, Boolean</code>.</li>\n  <li>Для змінних примітивних типів типи повинні точно відповідати (наприклад, <code>byte</code> не можна напряму упакувати в <code>Short</code> без приведення).</li>\n  <li>Для констант примітивних типів компілятор може автоматично виконувати розширення/звуження типу, а потім автоупаковку.</li>\n  <li>Цілі об’єкти в діапазоні <code>-128 ... +127</code> кешуються JVM, тобто однакові значення обгорток посилаються на один і той же об’єкт.</li>\n</ul>","topicName":"Core-1"},{"id":57,"questionText":"Явне і неявне приведення типів у Java","answer":"<p>Java є строго типізованою мовою, тобто кожна змінна та вираз мають чітко визначений тип на етапі компіляції. <strong>Приведення типів</strong> (casting) дозволяє перетворювати значення змінної одного типу в значення іншого типу.</p>\n\n<h4>Види приведення типів:</h4>\n\n<ul>\n  <li><strong>Тотожне (identity)</strong> – приведення до того ж самого типу. Завжди допустиме і виконується автоматично.</li>\n  <li><strong>Розширення примітивного типу (widening primitive)</strong> – перехід від менш ємкого типу до більш ємкого (наприклад, <code>byte</code> → <code>int</code>). Безпечне, відбувається автоматично, дані не втрачаються.</li>\n  <li><strong>Спуження примітивного типу (narrowing primitive)</strong> – перехід від більш ємкого типу до менш ємкого (наприклад, <code>int</code> → <code>byte</code>). Може призвести до втрати даних, тому вимагає явного вказання типу:</li>\n</ul>\n<pre><code>int a = 130;\nbyte b = (byte) a; // старші біти відкидаються</code></pre>\n\n<ul>\n  <li><strong>Розширення об'єктного типу (widening reference)</strong> – перехід від нащадка до предка. Відбувається автоматично.</li>\n  <li><strong>Спуження об'єктного типу (narrowing reference)</strong> – перехід від предка до нащадка. Вимагає явного приведення, інакше можливий <code>ClassCastException</code>:</li>\n</ul>\n<pre><code>Parent parent = new Child();\nif (parent instanceof Child) {\n    Child child = (Child) parent;\n}</code></pre>\n\n<ul>\n  <li><strong>Приведення до рядка (to String)</strong> – будь-який тип можна привести до <code>String</code>.</li>\n  <li><strong>Заборонені приведення</strong> – неможливо перетворювати несумісні типи (наприклад, примітив ↔ об’єкт, класи з різних гілок ієрархії).</li>\n</ul>\n\n<h4>Коли потрібно використовувати явне приведення:</h4>\n<ul>\n  <li>При спуженні примітивів (<code>int</code> → <code>byte</code>) або об'єктів (предок → нащадок).</li>\n  <li>Коли типи не сумісні автоматично, і необхідно явно вказати компілятору, що перетворення безпечне.</li>\n</ul>","topicName":"Core-1"},{"id":58,"questionText":"Коли в додатку може бути викинуто виключення <code>ClassCastException</code>?","answer":"<p><strong>ClassCastException</strong> (підклас <code>RuntimeException</code>) виникає, коли відбувається неправильне приведення типів об’єктів. Наприклад, спроба перетворити об’єкт предка на не сумісний об’єкт нащадка:</p>\n\n<pre><code>Object obj = \"Hello\";\nInteger num = (Integer) obj; // ClassCastException\n</code></pre>","topicName":"Core-1"},{"id":59,"questionText":"Що таке пул <code>Integer</code>?","answer":"<p>У класі-обгортці <code>Integer</code> існує внутрішній клас <code>IntegerCache</code>, який реалізує <strong>пул цілих чисел</strong> у діапазоні <code>-128 ... 127</code>. Цей діапазон обрано, оскільки такі значення найчастіше використовуються.</p>\n\n<p>Кешовані об’єкти зберігаються у приватному статичному масиві <code>cache[]</code>. Коли ви вперше використовуєте клас <code>Integer</code>, JVM створює кешовані об’єкти. Надалі, замість створення нового екземпляра (крім використання конструктора), JVM бере об’єкти з цього пулу, що підвищує ефективність пам’яті та продуктивність.</p>","topicName":"Core-1"},{"id":60,"questionText":"Чи можна змінити розмір пула <code>Integer</code>?","answer":"<p>Так, розмір пулу <code>Integer</code> можна змінити не з коду, а за допомогою параметра JVM <code>java.lang.Integer.IntegerCache.high</code>. За замовчуванням пул охоплює числа від -128 до 127, але ви можете збільшити верхню межу, передавши JVM відповідний параметр при запуску:</p>\n\n<pre><code>java -Djava.lang.Integer.IntegerCache.high=200 MyApp</code></pre>\n\n<p>Це дозволить кешувати числа у діапазоні <code>-128 ... 200</code>.</p>","topicName":"Core-1"},{"id":61,"questionText":"Які ще є пули примітивів?","answer":"<p>Пули існують не тільки для <code>Integer</code>, а й для інших цілих чисел (<code>Byte, Short, Long</code>) та <code>Character</code>. Вони кешують об’єкти у певних діапазонах для підвищення ефективності пам’яті та швидкості роботи програми.</p>\n\n<p>Особливості:</p>\n<ul>\n  <li>Для <code>Byte, Short, Long</code> та <code>Character</code> розміри пулу фіксовані і їх не можна змінювати.</li>\n  <li>Для <code>Integer</code> можна змінити верхню межу пулу через параметр JVM <code>java.lang.Integer.IntegerCache.high</code>.</li>\n</ul>","topicName":"Core-1"},{"id":62,"questionText":"Які є особливості класу <code>String</code> ?","answer":"<ul>\n  <li><strong>Незмінний та фіналізований</strong>: об’єкти <code>String</code> є <em>immutable</em>, тобто після створення їхній вміст змінити неможливо. Клас оголошено як <code>final</code>, тому його не можна наслідувати.</li>\n  <li><strong>Пул рядків</strong>: всі об’єкти <code>String</code>, створені в коді за допомогою літералів, JVM зберігає в <em>String Pool</em>. Це дозволяє уникати дублювання однакових рядків і економити пам’ять.</li>\n  <li><strong>Створення рядків</strong>: об’єкт <code>String</code> можна створити за допомогою подвійних лапок, наприклад <code>String s = \"Hello\";</code>. Також можна використовувати конструктор класу <code>new String(\"Hello\")</code>, але в цьому випадку рядок не потрапляє автоматично в пул.</li>\n  <li><strong>Конкатенація рядків</strong>: для об’єктів <code>String</code> можна використовувати оператор <code>+</code> для об’єднання рядків, наприклад <code>\"Hello \" + \"World\"</code>.</li>\n  <li><strong>Використання в switch</strong>: починаючи з Java 7, рядки можна використовувати як вираз у конструкції <code>switch</code>, що робить код більш зручним і читабельним.</li>\n</ul>","topicName":"Core-1"},{"id":63,"questionText":"Що таке «пул рядків»?","answer":"<p><strong>Пул рядків</strong> – це спеціальна область у <em>Heap</em>, де JVM зберігає унікальні об’єкти <code>String</code>, щоб економити пам’ять і уникати дублювання однакових рядків.</p>\n\n<ul>\n  <li>Пул можливий завдяки <strong>незмінності рядків</strong> (immutable) та реалізації ідеї <em>інтернування рядків</em> (string interning).</li>\n  <li>Використання пулу економить пам’ять, але створення нового рядка може займати більше часу через перевірку наявності в пулі.</li>\n  <li>При створенні рядка за допомогою подвійних лапок (\"\") JVM спочатку шукає рядок у пулі. Якщо знайде – повертає посилання на існуючий об’єкт, інакше створює новий рядок у пулі та повертає його посилання.</li>\n  <li>При створенні рядка через <code>new String(\"...\")</code> створюється новий об’єкт у Heap. Метод <code>intern()</code> дозволяє додати цей рядок до пулу або отримати посилання на вже існуючий об’єкт з тим самим значенням.</li>\n  <li>Пул рядків є прикладом патерна <em>Приспособлений (Flyweight)</em>, який дозволяє зменшувати витрати пам’яті на множинні об’єкти з однаковими даними.</li>\n</ul>","topicName":"Core-1"},{"id":64,"questionText":"Чому не рекомендується змінювати рядки в циклі і що використовувати?","answer":"<p>Клас <code>String</code> є <strong>незмінним</strong> (immutable). Це означає, що при кожній зміні рядка насправді створюється новий об’єкт у пам’яті. Якщо редагувати рядки в циклі, кількість створених об’єктів зростає, що веде до підвищеного споживання ресурсів і зниження продуктивності.</p>\n\n<p>Щоб ефективно змінювати рядки в циклах або при частих модифікаціях, рекомендується використовувати <code>StringBuilder</code> або <code>StringBuffer</code>, які дозволяють змінювати рядки без створення нових об’єктів.</p>","topicName":"Core-1"},{"id":65,"questionText":"Чому <code>char[]</code> вважається безпечнішим для зберігання пароля, ніж <code>String</code>?","answer":"<p>Об’єкти <code>String</code> є незмінними та зберігаються в пулі рядків JVM. Після використання пароля рядок може залишатися в пам’яті до того моменту, поки його не видалить збирач сміття. Це створює ризик для безпеки, адже зловмисник, який має доступ до пам’яті, може знайти пароль у вигляді тексту.</p>\n\n<p>Масив символів <code>char[]</code> дозволяє одразу після використання обнулити всі символи пароля, тим самим видаляючи його з пам’яті і зменшуючи ризик витоку даних:</p>\n\n<pre><code>char[] password = getPassword();\n...\nArrays.fill(password, '\\0'); // очищаємо масив після використання\n</code></pre>","topicName":"Core-1"},{"id":66,"questionText":"Чому <code>String</code> є незмінним і фіналізованим класом?","answer":"<p>Клас <code>String</code> у Java оголошено як <strong>final</strong> і <strong>immutable</strong> (незмінний). Це дає кілька важливих переваг:</p>\n\n<ul>\n  <li><strong>Пул рядків</strong>: незмінність дозволяє використовувати пул рядків. Різні змінні можуть посилатися на один об’єкт у пулі, що економить пам’ять. Якби рядок був змінним, інтернування рядків було б неможливим, бо зміна одного рядка вплинула б на всі змінні, які на нього посилаються.</li>\n  \n  <li><strong>Безпека</strong>: незмінність захищає від небезпечних змін. Наприклад, рядки для зберігання імен користувачів, паролів або параметрів з’єднання з базою даних не можуть бути змінені зловмисником під час виконання програми.</li>\n  \n  <li><strong>Багатопоточність</strong>: незмінні рядки не потребують синхронізації, їх можна безпечно використовувати у кількох потоках одночасно.</li>\n  \n  <li><strong>Завантаження класів</strong>: рядки активно використовуються ClassLoader, і їх незмінність гарантує правильність завантаження класів.</li>\n  \n  <li><strong>Оптимізація хеш-кодів</strong>: оскільки рядок незмінний, його <code>hashCode()</code> обчислюється один раз і кешується. Це робить <code>String</code> ідеальним ключем для <code>HashMap</code> та інших хеш-структур.</li>\n</ul>","topicName":"Core-1"},{"id":67,"questionText":"Чому <code>String</code> є популярним ключем у <code>HashMap</code> в Java?","answer":"<p>Рядки є <strong>незмінними</strong> (immutable), тому їх <code>hashCode()</code> обчислюється один раз при створенні і зберігається для подальшого використання. Це дозволяє <code>HashMap</code> ефективно працювати з рядками як ключами, оскільки хеш-код не потребує повторного обчислення, що прискорює пошук і доступ до значень.</p>","topicName":"Core-1"},{"id":68,"questionText":"Що робить метод <code>intern()</code> у класі <code>String</code>?","answer":"<p>Метод <code>intern()</code> дозволяє помістити рядок у <strong>пул рядків</strong> або отримати посилання на існуючий об’єкт у пулі з таким самим значенням. Якщо рядок вже існує в пулі, метод повертає посилання на нього; інакше додає рядок у пул і повертає нове посилання.</p>\n\n<pre><code>String s1 = new String(\"Hello\");\nString s2 = s1.intern(); // s2 посилається на об’єкт з пулу\nString s3 = \"Hello\";     // теж посилається на той самий об’єкт у пулі\nSystem.out.println(s2 == s3); // true\n</code></pre>","topicName":"Core-1"},{"id":69,"questionText":"Чи можна використовувати рядки у конструкції <code>switch</code>?","answer":"<p>Так, починаючи з <strong>Java 7</strong>, рядки можна використовувати у <code>switch</code>. Раніші версії Java цього не підтримували.</p>\n\n<ul>\n  <li>Порівняння рядків чутливе до регістру.</li>\n  <li>Для порівняння значення із <code>case</code> використовується метод <code>equals()</code>, тому необхідно передбачити перевірку на <code>null</code>, щоб уникнути <code>NullPointerException</code>.</li>\n  <li>Компілятор формує більш ефективний байт-код для рядків у <code>switch</code>, ніж при використанні послідовних умов <code>if-else</code>.</li>\n</ul>\n\n<pre><code>String day = \"MONDAY\";\nswitch (day) {\n    case \"MONDAY\":\n        System.out.println(\"Початок тижня\");\n        break;\n    case \"FRIDAY\":\n        System.out.println(\"Кінець тижня\");\n        break;\n    default:\n        System.out.println(\"Інший день\");\n}</code></pre>","topicName":"Core-1"},{"id":70,"questionText":"Основна різниця між <code>String</code>, <code>StringBuffer</code> та <code>StringBuilder</code>","answer":"<ul>\n  <li><strong>String</strong> — незмінний (immutable) клас. Після створення об’єкт <code>String</code> неможливо змінити; будь-яка модифікація створює новий екземпляр рядка.</li>\n  \n  <li><strong>StringBuffer</strong> — змінний (mutable) клас. Використовується, коли потрібно часто модифікувати рядки. Методи класу <code>StringBuffer</code> синхронізовані, тому безпечні для багатопоточності.</li>\n  \n  <li><strong>StringBuilder</strong> — також змінний клас, доданий у Java 5. Він ідентичний <code>StringBuffer</code>, але не синхронізований, тому його методи працюють швидше у однопоточних програмах.</li>\n</ul>","topicName":"Core-1"},{"id":71,"questionText":"Що таке StringJoiner?","answer":"<p>Клас <code>StringJoiner</code> використовується для створення послідовності рядків, розділених роздільником і з можливістю додати до отриманого рядка префікс і суфікс:</p>\n<pre><code>StringJoiner joiner = new StringJoiner(\".\", \"prefix-\", \"-suffix\");\nfor (String s : \"Hello the brave world\".split(\" \")) {\n    joiner.add(s);\n}\nSystem.out.println(joiner); //prefix-Hello.the.brave.world-suffix\n</code></pre>","topicName":"Core-1"},{"id":72,"questionText":"Чи існують в Java багатовимірні масиви?","answer":"<p>Так (спірно). Тип даних масиву – посилальний. Масив передбачає неперервне зберігання в пам'яті, всі вкладені масиви будуть однаковими, для них виділена однакова пам'ять. Це структура, під яку виділяється обсяг пам'яті, тому потрібно знати наперед, який обсяг матиме масив.</p>","topicName":"Core-1"},{"id":73,"questionText":"Які значення ініціюються змінні за замовчуванням?","answer":"<ul>\n  <li>byte, short, int – 0;</li>\n  <li>long – 0L;</li>\n  <li>float – 0.0f;</li>\n  <li>double – 0.0d;</li>\n  <li>char – '\\u0000' (символ кінця рядка);</li>\n  <li>boolean – false (залежить від реалізації, можна встановити true за замовчуванням);</li>\n  <li>об'єкти – null (це посилання нікуди не вказує, спецвказівник);</li>\n  <li>локальні (у методі) змінні не мають значень за замовчуванням, їх мають поля класу;</li>\n  <li>не static-поле класу буде ініціалізовано після створення об'єкта цього класу, а static-поле буде ініціалізовано тоді, коли клас буде завантажено JVM;</li>\n  <li>скільки важить посилання в Java: на 32 біта – 4 байти, на 64 біти – 8 байтів (але вроді як є 4 байти) (залізо + JVM);</li>\n  <li>заголовок об'єкта – 1 біт.</li>\n</ul>","topicName":"Core-1"},{"id":74,"questionText":"Що таке сигнатура методу?","answer":"<p>Сигнатура методу складається з його імені та списку параметрів. Порядок параметрів важливий, особливо якщо використовується варіативний параметр (троєтка), який завжди повинен бути останнім. До сигнатури методу не входить тип повернення та винятки, які метод може кидати.</p>\n\n<p>Якщо додати до сигнатури тип повернення та винятки, що можуть бути викинуті, отримуємо <strong>контракт методу</strong>. Іншими словами, від модифікатора до винятків – це і є контракт методу.</p>","topicName":"Core-1"},{"id":75,"questionText":"Розкажіть про метод main","answer":"<p>Метод <code>main</code> зазвичай є <strong>точкою входу</strong> в програму і викликається JVM. Коли виконання методу <code>main()</code> завершується, програма також припиняє свою роботу.</p>\n<ul>\n  <li><strong>static</strong> – потрібен, щоб JVM могла викликати метод без створення об'єкта класу.</li>\n  <li><strong>public static void main(String[] args)</strong> – обов'язкова сигнатура для запуску програми.</li>\n  <li>У програмі може бути декілька методів <code>main</code> у різних класах, або його може взагалі не бути (у випадку спеціальних сценаріїв, наприклад, бібліотек).</li>\n  <li>Метод <code>main</code> можна <strong>перевантажувати</strong>, створюючи інші варіанти з різними параметрами.</li>\n</ul>","topicName":"Core-1"},{"id":76,"questionText":"Яким чином змінні передаються в методи, за значенням чи за\nпосиланням?","answer":"<p>У Java всі параметри передаються <strong>за значенням</strong>. Це означає, що передається копія значення, а не саме значення оригіналу.</p>\n<ul>\n  <li>Для примітивних типів – копіюється безпосередньо значення змінної.</li>\n  <li>Для об'єктів – копіюється <strong>посилання</strong> на об'єкт. Через цю копію посилання можна змінювати внутрішні поля об'єкта, але не можна змінити саме посилання, щоб воно вказувало на інший об'єкт.</li>\n  <li>Масиви в Java є об'єктами, тому вони передаються за копією посилання.</li>\n</ul>","topicName":"Core-1"},{"id":77,"questionText":"Якщо передати масив і змінити його в методі, чи буде\nзмінюватися поточний масив?","answer":"<p>Так, поточний масив також зміниться.</p>","topicName":"Core-1"},{"id":78,"questionText":"Які типи класів існують в Java?","answer":"ul>\n  <li><strong>Top-level class / Клас верхнього рівня</strong> (звичайний клас):\n    <ul>\n      <li>Abstract class (абстрактний клас)</li>\n      <li>Final class (фіналізований клас)</li>\n    </ul>\n  </li>\n  <li><strong>Interfaces</strong> (інтерфейси)</li>\n  <li><strong>Enum</strong> (перерахування)</li>\n  <li><strong>Nested class</strong> (вкладені класи):\n    <ul>\n      <li>Static nested class (статичний вкладений клас)</li>\n      <li>Member inner class (простий внутрішній клас)</li>\n      <li>Local inner class (локальний клас)</li>\n      <li>Anonymous inner class (анонімний клас)</li>\n    </ul>\n  </li>\n</ul>","topicName":"Core-1"},{"id":79,"questionText":"Розкажіть про внутрішні класи. У яких випадках їх\nвикористовують?","answer":"<h3>Внутрішні (Nested) класи у Java</h3>\n<p>Клас називається <strong>внутрішнім</strong>, якщо він визначений всередині іншого класу. Внутрішній клас зазвичай створюється для обслуговування зовнішнього класу. Якщо клас корисний і в іншому контексті, його слід зробити класом верхнього рівня.</p>\n<p>Внутрішні класи мають доступ до всіх полів і методів зовнішнього класу (включно з приватними), але зовнішній клас не має прямого доступу до внутрішніх членів, що може частково порушувати інкапсуляцію.</p>\n\n<h4>Категорії внутрішніх класів</h4>\n<ol>\n  <li>\n    <strong>Статичні вкладені класи (Static Nested Classes)</strong>\n    <ul>\n      <li>Можуть звертатися лише до статичних полів та методів зовнішнього класу.</li>\n      <li>Об'єкт зовнішнього класу не потрібен для створення об'єкта статичного вкладеного класу.</li>\n      <li>Не можна звертатися до нестатичних членів зовнішнього класу.</li>\n    </ul>\n  </li>\n  <li>\n    <strong>Нестатичні вкладені класи (Inner / Non-static Nested)</strong>\n    <ul>\n      <li>Мають доступ до всіх полів та методів зовнішнього класу.</li>\n      <li>Не можуть містити статичних оголошень всередині.</li>\n      <li>Не можна оголосити перелічення всередині такого класу.</li>\n      <li>Щоб явно отримати посилання на зовнішній клас, використовуйте <code>OuterClass.this</code>.</li>\n    </ul>\n  </li>\n  <li>\n    <strong>Локальні класи (Local Classes)</strong>\n    <ul>\n      <li>Доступні лише в межах блоку, де оголошені.</li>\n      <li>Не можуть мати модифікатори <code>private/public/protected</code> або <code>static</code>.</li>\n      <li>Не можуть містити статичних оголошень, але дозволені константи <code>static final</code>.</li>\n      <li>Мають доступ до полів та методів зовнішнього класу.</li>\n      <li>Можуть використовувати локальні змінні та параметри методу, якщо вони <em>final</em> або <em>effectively final</em>.</li>\n    </ul>\n  </li>\n  <li>\n    <strong>Анонімні класи (Anonymous Classes)</strong>\n    <ul>\n      <li>Локальний клас без імені.</li>\n      <li>Створюється для миттєвого використання у місці оголошення.</li>\n    </ul>\n  </li>\n</ol>\n\n<h4>Використання внутрішніх класів</h4>\n<ul>\n  <li>Якщо внутрішньому класу не потрібне посилання на екземпляр зовнішнього класу, його можна зробити статичним.</li>\n  <li>Статичний внутрішній клас дозволяє створювати об'єкти без зовнішнього класу та не має доступу до нестатичних членів зовнішнього класу.</li>\n</ul>\n\n<h4>Рекомендації щодо вибору типу внутрішнього класу</h4>\n<ul>\n  <li><strong>Нестатичний:</strong> якщо клас має бути видимим поза межами одного методу, або кожному екземпляру потрібне посилання на екземпляр зовнішнього класу.</li>\n  <li><strong>Статичний:</strong> якщо посилання на зовнішній клас не потрібне.</li>\n  <li><strong>Локальний:</strong> якщо клас потрібен лише всередині одного методу.</li>\n  <li><strong>Анонімний:</strong> якщо клас використовується лише в одному місці і вже існує тип, який його описує.</li>\n</ul>","topicName":"Core-1"},{"id":80,"questionText":"Що таке \"статичний клас\"?","answer":"<p>Це вкладений клас, оголошений із ключовим словом static. До класів верхнього рівня модифікатор static не застосовується.</p>","topicName":"Core-1"},{"id":81,"questionText":"Які особливості використання вкладених класів: статичних і\nвнутрішніх? В чому полягає різниця між ними?","answer":"<p>Вкладені класи можуть бути <strong>статичними</strong> або <strong>нестатичними (внутрішніми)</strong>. Основні відмінності між ними:</p>\n\n<ul>\n  <li>Всі вкладені класи мають доступ до всіх членів зовнішнього класу, включаючи приватні поля та методи.</li>\n  <li>\n    <strong>Статичні вкладені класи:</strong>\n    <ul>\n      <li>Для створення об'єкта не потрібен екземпляр зовнішнього класу.</li>\n      <li>Не мають доступу до нестатичних членів зовнішнього класу безпосередньо, тільки через посилання на його екземпляр.</li>\n      <li>Можуть містити статичні методи, блоки ініціалізації та інші класи.</li>\n      <li>Не зберігають посилання на об'єкт зовнішнього класу.</li>\n    </ul>\n  </li>\n  <li>\n    <strong>Нестатичні (внутрішні) класи:</strong>\n    <ul>\n      <li>Завжди пов'язані з екземпляром зовнішнього класу, зберігаючи посилання на нього.</li>\n      <li>Не можуть містити статичних методів, блоків ініціалізації чи класів.</li>\n      <li>Доступ до екземпляра зовнішнього класу можна отримати через <code>OuterClass.this</code>.</li>\n    </ul>\n  </li>\n</ul>","topicName":"Core-1"},{"id":82,"questionText":"Що таке \"локальний клас\"? Які його особливості?","answer":"<p>Локальний клас — це вкладений клас, який можна оголосити в будь-якому блоці, де дозволено оголошувати змінні. На відміну від анонімних класів, локальний клас має власне ім'я і може використовуватися кілька разів. Він має доступ до екземпляра зовнішнього класу, якщо знаходиться в нестатичному контексті.</p>\n\n<h4>Особливості локальних класів:</h4>\n<ul>\n  <li>Видимі лише всередині блоку, у якому оголошені.</li>\n  <li>Не можуть бути оголошені як <code>private</code>, <code>public</code>, <code>protected</code> або <code>static</code>.</li>\n  <li>Не можуть містити статичних полів, методів або класів.</li>\n  <li>Мають доступ до полів та методів зовнішнього (обрамлюючого) класу.</li>\n  <li>Можуть звертатися до локальних змінних та параметрів методу, якщо вони оголошені як <code>final</code> або є <em>effectively final</em>.</li>\n</ul>","topicName":"Core-1"},{"id":83,"questionText":"Що таке \"анонімні класи\"? Де їх застосовують?","answer":"<p>Анонімний клас — це локальний вкладений клас без імені. Його можна оголосити в будь-якому місці зовнішнього класу, що дозволяє розміщувати його прямо у виразах. Екземпляр анонімного класу створюється одночасно з його оголошенням. Залежно від контексту, анонімний клас може поводитися як статичний або як нестатичний вкладений клас. У нестатичному контексті він має доступ до об'єкта, який його оточує.</p>\n\n<h4>Обмеження анонімних класів:</h4>\n<ul>\n  <li>Використовується лише в одному місці, де він створюється.</li>\n  <li>Неможливо зберегти посилання на екземпляр для подальшого використання.</li>\n  <li>Може реалізовувати лише методи свого інтерфейсу або суперкласу; не можна оголошувати нові методи без іменованого типу.</li>\n</ul>\n\n<h4>Застосування анонімних класів:</h4>\n<ul>\n  <li>Створення об'єкта функції (function object), наприклад, реалізація інтерфейсу <code>Comparator</code>.</li>\n  <li>Створення об'єкта процесу (process object), наприклад, екземпляри <code>Thread</code>, <code>Runnable</code> та інших.</li>\n  <li>Використання у статичних методах генерації.</li>\n  <li>Ініціалізація складних <code>final static</code> полів, де для кожного елемента потрібен окремий підклас.</li>\n</ul>","topicName":"Core-1"},{"id":84,"questionText":"Як отримати доступ до поля зовнішнього класу з вкладеного\nкласу?","answer":"<p>Доступ до полів зовнішнього класу залежить від типу вкладеного класу:</p>\n\n<ul>\n  <li>\n    <strong>Статичний вкладений клас:</strong> має прямий доступ тільки до статичних полів зовнішнього класу.\n  </li>\n  <li>\n    <strong>Нестатичний (простий внутрішній) клас:</strong> може звертатися до будь-якого поля зовнішнього класу напряму. \n    <br>Якщо у вкладеного класу є поле з таким самим ім'ям, доступ до поля зовнішнього класу здійснюється через <code>OuterClass.this.field</code>.\n  </li>\n</ul>","topicName":"Core-1"},{"id":85,"questionText":"Що таке переліки (enum)?","answer":"<p><strong>Enum</strong> представляє собою набір логічно пов'язаних констант. Фактично, кожен enum є новим класом, тому можна створювати змінні цього типу та використовувати їх у програмі.</p>\n\n<h4>Особливості enum:</h4>\n<ul>\n  <li>Можуть мати конструктори, поля та методи. Конструктор за замовчуванням є приватним.</li>\n  <li>Можна визначати методи для окремих констант.</li>\n  <li>Геттери/сеттеры можна створювати, вони генеруються на етапі компіляції.</li>\n  <li>Методи enum:\n    <ul>\n      <li><code>valueOf(String name)</code> – повертає конкретний елемент;</li>\n      <li><code>ordinal()</code> – повертає порядковий номер константи (починається з 0);</li>\n      <li><code>values()</code> – повертає масив усіх констант enum;</li>\n      <li><code>name()</code> – повертає ім’я константи, <code>toString()</code> можна перевизначити.</li>\n    </ul>\n  </li>\n  <li>Метод <code>equals()</code> в enum використовує оператор <code>==</code>, тому можна застосовувати обидва варіанти.</li>\n</ul>\n\n<h4>Переваги enum над <code>static final int</code>:</h4>\n<ul>\n  <li>Можна перевіряти тип даних.</li>\n  <li>Обмежують область допустимих значень (наприклад, пори року, дні тижня).</li>\n</ul>\n\n<h4>Недоліки:</h4>\n<ul>\n  <li>Не підтримують оператори <code>&gt;, &lt;, &gt;=, &lt;=</code>.</li>\n  <li>Вимагають більше пам’яті для зберігання, ніж звичайні константи.</li>\n</ul>\n\n<h4>Особливості класів Enum:</h4>\n<ul>\n  <li>Конструктор завжди приватний або за замовчуванням.</li>\n  <li>Можуть реалізовувати інтерфейси, але не можуть успадковувати класи.</li>\n  <li>Можна перевизначити <code>toString()</code>.</li>\n  <li>Немає публічного конструктора – екземпляри створюються лише в середині enum.</li>\n  <li>Порівняння за <code>equals()</code> використовує <code>==</code>.</li>\n  <li><code>ordinal()</code> повертає порядок елементів у оголошенні.</li>\n  <li>Можуть використовуватися в <code>TreeSet</code> та <code>TreeMap</code>, оскільки реалізують <code>Comparable</code>.</li>\n  <li><code>compareTo()</code> відображає порядок елементів згідно з <code>ordinal()</code>.</li>\n  <li>Можна використовувати в <code>switch</code> конструкціях.</li>\n  <li><code>values()</code> повертає масив усіх констант.</li>\n  <li>Дозволяють легко створювати потокобезпечні сінглтони без подвійної перевірки.</li>\n</ul>","topicName":"Core-1"},{"id":86,"questionText":"Що таке ромбовидне успадкування (Diamond Inheritance)?","answer":"<p>Ромбовидне успадкування – це ситуація в об'єктно-орієнтованих мовах програмування, які підтримують багатократне успадкування. Вона виникає, коли:</p>\n<ul>\n  <li>Клас <strong>A</strong> є базовим;</li>\n  <li>Два класи <strong>B</strong> і <strong>C</strong> успадковують від <strong>A</strong>;</li>\n  <li>Клас <strong>D</strong> успадковує одночасно від <strong>B</strong> і <strong>C</strong>.</li>\n</ul>\n\n<p>Проблема ромбовидного успадкування полягає у невизначеності: якщо клас <strong>D</strong> викликає метод, визначений у класі <strong>A</strong> (і не перевизначений у <strong>D</strong>), а класи <strong>B</strong> і <strong>C</strong> перевизначили цей метод по-своєму, то стає невідомо, яку версію методу слід використовувати — від <strong>B</strong> чи <strong>C</strong>?</p>","topicName":"Core-1"},{"id":87,"questionText":"Як вирішено проблему ромбовидного успадкування в Java?","answer":"<p>У Java <strong>немає підтримки багатократного успадкування класів</strong>. Це робить неможливим виникнення невизначеності, яка характерна для ромбовидного успадкування.</p>\n\n<p>Наприклад, якщо:</p>\n<ul>\n  <li><strong>SuperClass</strong> – абстрактний клас з певним методом;</li>\n  <li><strong>ClassA</strong> і <strong>ClassB</strong> – класи, що успадковують SuperClass;</li>\n  <li><strong>ClassC</strong> намагається успадкувати одночасно від ClassA і ClassB;</li>\n</ul>\n\n<p>Тоді виклик методу батьківського класу призведе до невизначеності, оскільки компілятор не знає, яку версію методу слід використовувати. Саме через це багатократне успадкування класів у Java не підтримується.</p>\n\n<p>Натомість Java дозволяє багатократне успадкування <strong>інтерфейсів</strong>. Інтерфейси лише описують методи, а реалізація відбувається у класі, який їх реалізує. Це виключає невизначеність.</p>\n\n<p>Якщо клас реалізує кілька інтерфейсів з <code>default</code>-методами, при конфлікті обов’язково потрібно перевизначити цей метод у класі.</p>","topicName":"Core-1"},{"id":88,"questionText":"Дайте визначення поняття «конструктор»","answer":"<p>Конструктор — це спеціальний метод, який не має повертаємого типу і має ту ж назву, що й клас, в якому він оголошений. Він викликається під час створення нового об'єкта класу і визначає дії, необхідні для його ініціалізації.</p>","topicName":"Core-1"},{"id":89,"questionText":"Що таке конструктор за замовчуванням?","answer":"<p>Якщо у класі не визначено жодного конструктора, компілятор автоматично згенерує <strong>конструктор без аргументів</strong>, який називають \"конструктор за замовчуванням\".</p>\n\n<p>Якщо клас уже має хоча б один конструктор, конструктор за замовчуванням <strong>не створюється автоматично</strong> і його потрібно визначати явно.</p>\n\n<p>У випадку успадкування, якщо конструктор не перевизначений у підкласі, використовується конструктор батьківського класу.</p>","topicName":"Core-1"},{"id":90,"questionText":"Можуть бути приватні конструктори? З якою метою вони\nпотрібні?","answer":"<p><strong>Так, можуть.</strong> Приватний конструктор забороняє створення екземпляра класу поза методами самого класу.</p>\n\n<ul>\n  <li>Фінальні (<code>final</code>) конструктори відсутні.</li>\n  <li>Це необхідно для реалізації патернів, наприклад, <em>singleton</em>.</li>\n  <li>Приватний конструктор запобігає виклику конструктора іншими класами ззовні.</li>\n  <li>У абстрактного класу може бути приватний конструктор (абстрактний клас дозволяє описати певний стан об'єкта).</li>\n</ul>","topicName":"Core-1"},{"id":91,"questionText":"Розкажіть про класи-завантажувачі та динамічне завантаження\nкласів","answer":"<p>При запуску JVM для завантаження додатка використовуються наступні завантажувачі класів:</p>\n\n<ul>\n  <li><strong>Bootstrap ClassLoader</strong> – головний завантажувач, завантажує платформенні класи JDK з архіву <code>rt.jar</code>;</li>\n  <li><strong>AppClassLoader</strong> – системний завантажувач, завантажує класи поточного додатка, визначені в <code>CLASSPATH</code>;</li>\n  <li><strong>SystemClassLoader</strong> – завантажує класи поточного додатка, визначені в <code>CLASSPATH</code>;</li>\n  <li><strong>Extension ClassLoader</strong> – завантажувач розширень, завантажує всі необхідні бібліотеки з директорії <code>java.home</code> (зокрема, з каталогу <code>jre/lib/ext</code>).</li>\n</ul>\n\n<p>Виняток: <code>ClassNotFoundException</code> може виникнути, якщо клас не знайдено.</p>\n\n<h4>Динамічне завантаження класів</h4>\n\n<p>Динамічне завантаження відбувається \"на льоту\" під час виконання програми за допомогою статичного методу:</p>\n\n<pre><code>Class.forName(\"ім'я_класу\");</code></pre>\n\n<p>Навіщо потрібне динамічне завантаження? Наприклад, якщо заздалегідь невідомо, який клас буде потрібен, можна передавати його ім'я у <code>forName()</code> під час виконання програми, і клас буде завантажений у цей момент.</p>","topicName":"Core-1"},{"id":92,"questionText":"Що відрізняє конструктори за замовчуванням, конструктор копіювання та конструктор з параметрами?","answer":"<p>Конструктори відрізняються за призначенням і способом ініціалізації об'єкта:</p>\n\n<ul>\n  <li><strong>Конструктор за замовчуванням:</strong> не приймає жодних аргументів.</li>\n  <li><strong>Конструктор копіювання:</strong> приймає як аргумент вже існуючий об'єкт класу для створення його клону.</li>\n  <li><strong>Конструктор з параметрами:</strong> має аргументи у сигнатурі, які зазвичай використовуються для ініціалізації полів класу.</li>\n</ul>","topicName":"Core-1"},{"id":93,"questionText":"Які модифікатори доступу існують в Java? Які можуть бути застосовані до класів?","answer":"<p>В Java існують такі модифікатори доступу:</p>\n\n<ul>\n  <li><strong>private (приватний):</strong> елементи класу доступні лише всередині цього класу. Позначається ключовим словом <code>private</code>.</li>\n  <li><strong>default / package-private / package level (доступ на рівні пакета):</strong> елементи доступні лише в межах одного пакета. Використовується за замовчуванням, без спеціального ключового слова.</li>\n  <li><strong>protected (захищений):</strong> елементи доступні в межах пакета та у класах-нащадках. Позначається ключовим словом <code>protected</code>.</li>\n  <li><strong>public (відкритий):</strong> елементи доступні всім. Позначається ключовим словом <code>public</code>.</li>\n</ul>\n\n<p><strong>Послідовність рівнів доступу від найменш закритого до найбільш закритого:</strong> \n<code>public → protected → default → private</code>.</p>\n\n<p>При успадкуванні допустимо змінювати модифікатор доступу тільки в бік більшої видимості (принцип підстановки Лісков).  \nКласи можуть бути оголошені з модифікаторами <code>public</code> або <code>default</code>.</p>","topicName":"Core-1"},{"id":94,"questionText":"Чи може об'єкт отримати доступ до члена класу, оголошеного як private? Якщо так, то яким чином?","answer":"<p>Об'єкт може отримати доступ до членів класу, оголошених як <code>private</code>, за наступних умов:</p>\n\n<ul>\n  <li>Всередині самого класу доступ до приватних змінних відкритий без обмежень.</li>\n  <li>Вкладений клас має повний доступ до всіх членів зовнішнього класу, включаючи приватні.</li>\n  <li>Зовнішні методи класу, наприклад <code>getX()</code> та <code>setX()</code>, можуть забезпечувати доступ до приватних змінних.</li>\n  <li>Можливий доступ через механізм відображення <strong>Reflection API</strong>.</li>\n</ul>","topicName":"Core-1"},{"id":95,"questionText":"Що означає модифікатор static?","answer":"<ul>\n  <li><strong>Статична змінна:</strong> належить класу, а не об'єкту.</li>\n  <li><strong>Статичний клас:</strong> вкладений клас, який може звертатися лише до статичних полів зовнішнього класу.</li>\n  <li>Усередині статичного методу не можна викликати нестатичний метод без посилання на екземпляр класу. Статичний метод можна викликати через екземпляр класу.</li>\n</ul>","topicName":"Core-1"},{"id":96,"questionText":"До яких конструкцій Java можна застосовувати модифікатор static?","answer":"<ul>\n  <li>поля;</li>\n  <li>методи;</li>\n  <li>вкладені класи;</li>\n  <li>члени секції імпорту;</li>\n  <li>блоки ініціалізації.</li>\n</ul>","topicName":"Core-1"},{"id":97,"questionText":"У чому різниця між членом екземпляра класу та статичним\nчленом класу?","answer":"<p><strong>Статичні члени класу</strong> (<code>static</code>) належать самому класу і доступні без створення об'єкта. Статичні поля ініціалізуються під час завантаження класу.</p>\n\n<p>Особливості статичних методів:</p>\n<ul>\n  <li>Можуть викликати лише інші статичні методи;</li>\n  <li>Мають доступ тільки до статичних змінних;</li>\n  <li>Не можуть використовувати <code>this</code> або <code>super</code>;</li>\n</ul>\n\n<p><strong>Члени екземпляра класу</strong> належать конкретному об'єкту і можуть мати різні значення для кожного об'єкта. Методи екземпляра можна викликати лише після створення об'єкта класу.</p>","topicName":"Core-1"},{"id":98,"questionText":"Чи може статичний метод бути перевизначений або перевантажений?","answer":"<ul>\n  <li><strong>Перевантаження:</strong> так. Статичні методи можуть мати однакову назву, якщо відрізняються кількістю або типом параметрів, аналогічно звичайним методам.</li>\n  <li><strong>Перевизначення:</strong> ні. Виклик статичного методу визначається під час компіляції (раннє зв'язування), тому завжди виконується метод батьківського класу, навіть якщо синтаксично перевизначення допустиме.</li>\n</ul>\n\n<p>Рекомендується звертатися до статичних полів і методів через ім'я класу, а не через об'єкт.</p>","topicName":"Core-1"},{"id":99,"questionText":"Чи можуть нестатичні методи перевантажити статичні?","answer":"<p>\n  Так. У результаті отримаємо два різних методи. \n  <strong>Статичний</strong> належатиме класу і буде доступний за його іменем, \n  а <strong>нестатичний</strong> належатиме конкретному об'єкту і буде доступний \n  через виклик методу цього об'єкта.\n</p>","topicName":"Core-1"},{"id":100,"questionText":"Як отримати доступ до перевизначених методів батьківського класу?","answer":"<p>\n  За допомогою ключового слова <code>super</code> ми можемо звертатися до будь-якого члена\n  батьківського класу – методу чи полю, якщо вони не визначені як <code>private</code>.\n</p>\n<pre><code>super.method();\n</code></pre>","topicName":"Core-1"},{"id":101,"questionText":"Чи можна обмежити рівень доступу/тип повертаємого значення при перевизначенні методу?","answer":"<p>\n  При перевизначенні методу <strong>неможливо</strong> обмежити модифікатор доступу методу \n  (наприклад, з <code>public</code> на <code>private</code>), але можна його розширити.\n</p>\n<p>\n  Змінити тип повертаємого значення <strong>неможливо</strong>, але можна обмежити повертаєме значення, \n  якщо вони сумісні. Наприклад, якщо метод повертає об'єкт класу, а перевизначений метод повертає похідний клас.\n</p>","topicName":"Core-1"},{"id":102,"questionText":"Що можна змінити в сигнатурі методу під час його перевизначення? Чи можна змінювати модифікатори (throws тощо)?","answer":"<p>\n  При перевизначенні методу діють певні правила:\n</p>\n\n<ul>\n  <li><strong>Модифікатор доступу:</strong> не можна зменшувати рівень доступу (наприклад, з <code>public</code> на <code>protected</code> або <code>private</code>), але можна його розширювати. Це пов’язано з <em>принципом підстановки Лісков</em>.</li>\n  \n  <li><strong>Сигнатура методу:</strong> комбінація <code>ім’я методу + список параметрів</code> має залишатися незмінною, інакше це вже буде не перевизначення, а перевантаження.</li>\n  \n  <li><strong>Тип повертаємого значення:</strong> можна змінити на більш вузький (тобто підклас повертаємого типу батьківського методу), але не на зовсім інший тип.</li>\n  \n  <li><strong>Секція <code>throws</code>:</strong>\n    <ul>\n      <li>можна не вказувати взагалі;</li>\n      <li>можна додавати нові винятки, але лише ті, що є підкласами вже оголошених у батьківському методі, або винятки типу <code>RuntimeException</code>;</li>\n      <li>порядок перелічення винятків значення не має.</li>\n    </ul>\n  </li>\n</ul>","topicName":"Core-1"},{"id":103,"questionText":"Чи можуть класи бути статичними?","answer":"<p>\n  Клас можна оголосити статичним, <strong>за винятком класів верхнього рівня</strong>. \n  Такі класи називаються <strong>вкладеними статичними класами</strong> (nested static class).\n</p>","topicName":"Core-1"},{"id":104,"questionText":"Що означає модифікатор final? До чого він може бути застосований?","answer":"<p>\n  Модифікатор <code>final</code> можна застосовувати до змінних, параметрів методів, полів, методів класу та самого класу. Його вплив залежить від контексту:\n</p>\n<ul>\n  <li><strong>Клас:</strong> не може мати нащадків.</li>\n  <li><strong>Метод:</strong> не може бути перевизначений у класах-нащадках.</li>\n  <li><strong>Поле:</strong> не може змінювати своє значення після ініціалізації.</li>\n  <li><strong>Параметри методів:</strong> не можуть змінювати своє значення всередині методу.</li>\n  <li><strong>Локальні змінні примітивного типу:</strong> присвоєне значення не можна змінити.</li>\n  <li><strong>Змінні-посилання:</strong> після присвоєння об'єкта не можна змінити саме посилання, хоча стан об'єкта можна змінювати.</li>\n</ul>\n<p>\n  <strong>Примітка:</strong> до абстрактних класів <code>final</code> застосувати не можна, оскільки це взаємовиключаючі поняття.\n</p>","topicName":"Core-1"},{"id":105,"questionText":"Що таке абстрактні класи? Чим вони відрізняються від звичайних?","answer":"<p>Абстрактний клас — це звичайний клас, але з абстрактними методами.</p>\n\n<p><strong>Особливості абстрактних класів:</strong></p>\n<ul>\n  <li>Може мати конструктор (зручний для патерну декоратора або для викликів по ланцюжку з успадкованих класів).</li>\n  <li>Може містити як абстрактні, так і звичайні методи.</li>\n  <li>Може мати приватний конструктор, але в такому випадку потрібен ще один конструктор, щоб його можна було успадковувати.</li>\n  <li>Може імплементувати інтерфейси, але не зобов’язаний реалізовувати їх методи.</li>\n  <li>Не може бути <code>final</code>, оскільки спадкоємцями абстрактного класу можуть бути інші абстрактні класи.</li>\n  <li>Може мати статичні методи (абстрактний клас можна використовувати без успадкування).</li>\n  <li>Неможливо створити об’єкт або екземпляр абстрактного класу.</li>\n  <li>Абстрактні методи можуть бути відсутні.</li>\n  <li>Має хоча б один абстрактний метод.</li>\n  <li>Абстрактний метод не може існувати поза межами абстрактного класу.</li>\n  <li>Може містити метод <code>main()</code>.</li>\n</ul>\n\n<p><strong>Приклад:</strong> Якщо існує багато різних абстрактних класів і потрібно підрахувати їх, можна використати статичний метод для інкрементації, щоб порахувати всі методи.</p>","topicName":"Core-1"},{"id":106,"questionText":"Де і для чого використовується модифікатор <code>abstract</code>?","answer":"<p>Модифікатор <code>abstract</code> використовується для створення <strong>абстрактних класів</strong> та <strong>абстрактних методів</strong>.</p>\n\n<p><strong>Абстрактний клас</strong> — це клас, який не можна створити як об’єкт напряму. Його призначення — бути шаблоном для інших класів. Він може містити як повністю реалізовані методи, так і методи без реалізації (абстрактні).</p>\n\n<p><strong>Особливості абстрактного класу:</strong></p>\n<ul>\n  <li>Виступає лише предком для інших класів.</li>\n  <li>Його нащадками можуть бути як інші абстрактні класи, так і звичайні класи.</li>\n  <li>Може містити абстрактні методи або не мати їх взагалі.</li>\n</ul>\n\n<p><strong>Абстрактний метод</strong> — це метод без тіла (без реалізації), який описує лише сигнатуру. Його обов’язково потрібно реалізувати у класі-нащадку. Якщо клас містить хоча б один абстрактний метод, він повинен бути оголошений абстрактним.</p>\n\n<p><strong>Для чого це використовується?</strong></p>\n<ul>\n  <li>Щоб задати загальний «каркас» або шаблон об’єкта.</li>\n  <li>Щоб описати спільну поведінку для всіх нащадків та змусити їх реалізувати певні методи.</li>\n  <li>Щоб структурувати код, дотримуючись принципів ООП.</li>\n</ul>\n\n<p><em>Приклад:</em> Абстрактний клас <code>Shape</code> може містити метод <code>draw()</code> без реалізації. Кожна фігура (коло, квадрат тощо) реалізує свій варіант цього методу.</p>","topicName":"Core-1"},{"id":107,"questionText":"Чи можна оголосити метод абстрактним і статичним одночасно?","answer":"<p>Ні, цього зробити не можна. Якщо спробувати, компілятор видасть помилку:</p>\n<pre><code>Illegal combination of modifiers: ‘abstract’ and ‘static’</code></pre>\n<p>Причина: <code>abstract</code> означає, що метод не має реалізації і повинен бути реалізований у класі-нащадку, тоді як <code>static</code> вказує, що метод належить класу і доступний за його іменем. Поєднання цих модифікаторів логічно суперечливе.</p>","topicName":"Core-1"},{"id":108,"questionText":"Чи може бути абстрактний клас без абстрактних методів?","answer":"<p>Так, клас може бути оголошений абстрактним за допомогою модифікатора <code>abstract</code>, навіть якщо в нього немає жодного абстрактного методу.</p>","topicName":"Core-1"},{"id":109,"questionText":"Чи можуть абстрактні класи мати конструктори? На що вони потрібні?","answer":"<p>Так, абстрактні класи можуть мати конструктори, і вони потрібні для нащадків.</p>\n<p>У абстрактному класі можна оголосити і визначити конструктори. Навіть якщо жодного конструктора не оголошено, компілятор додасть конструктор за замовчуванням без аргументів. Абстрактні конструктори часто використовуються для встановлення обмежень класу або інваріантів, таких як мінімальні поля, необхідні для налаштування класу.</p>","topicName":"Core-1"},{"id":110,"questionText":"Що таке інтерфейси? Які модифікатори за замовчуванням мають поля і методи інтерфейсів?","answer":"<p><strong>Інтерфейс</strong> — це контракт (набір методів і правил), який визначає, як об’єкти повинні взаємодіяти між собою. \nВін схожий на повністю абстрактний клас, але з власними особливостями.</p>\n\n<p>Для створення інтерфейсу використовується ключове слово <code>interface</code>. \nІнтерфейс описує <em>що</em> повинен уміти клас, але не <em>як</em> це робити. \nРеалізація методів відбувається у класі, який цей інтерфейс імплементує.</p>\n\n<h4>Особливості інтерфейсів</h4>\n<ul>\n  <li>Усі методи за замовчуванням <code>public</code> і <code>abstract</code> (крім <code>default</code> і <code>static</code> методів).</li>\n  <li>Поля в інтерфейсі завжди <code>public static final</code> (константи).</li>\n  <li>Методи можуть бути:\n    <ul>\n      <li><strong>Абстрактними</strong> — обов’язкові для реалізації в класі-нащадку.</li>\n      <li><strong>Default</strong> — мають базову реалізацію, яку можна перевизначити (з’явилися з Java 8).</li>\n      <li><strong>Static</strong> — належать самому інтерфейсу, викликаються по імені інтерфейсу.</li>\n    </ul>\n  </li>\n  <li>Інтерфейс не може зберігати стан (окрім констант).</li>\n  <li>Клас може реалізовувати кілька інтерфейсів (на відміну від наслідування класів).</li>\n</ul>\n\n<h4>Приклад</h4>\n<pre><code>interface Drawable {\n    int DEFAULT_SIZE = 10; // public static final\n\n    void draw(); // public abstract\n\n    default void resize() { // метод з реалізацією\n        System.out.println(\"Resizing to default size...\");\n    }\n\n    static void info() {\n        System.out.println(\"Drawable interface v1.0\");\n    }\n}\n</code></pre>\n\n<p><strong>Висновок:</strong> інтерфейси дозволяють описати можливості класу, уникаючи обмежень спадкування, \nі надають механізм стандартної реалізації методів через <code>default</code> та <code>static</code> методи.</p>","topicName":"Core-1"},{"id":111,"questionText":"Чим інтерфейси відрізняються від абстрактних класів? Коли використовувати абстрактний клас, а коли інтерфейс?","answer":"<p>Основні відмінності між інтерфейсами та абстрактними класами:</p>\n\n<ol>\n  <li><strong>Стан об’єкта:</strong> Інтерфейс описує лише поведінку (методи), але не має полів, тоді як абстрактний клас може містити як методи, так і поля (стан).</li>\n  <li><strong>Наслідування:</strong> Клас може успадковувати лише один абстрактний клас, але може реалізовувати будь-яку кількість інтерфейсів. Інтерфейс може наслідувати інші інтерфейси.</li>\n  <li><strong>Відношення \"є\":</strong> Абстрактні класи застосовуються, коли існує чітке відношення \"є\" між класами (підклас є типом абстрактного класу). Інтерфейси дозволяють реалізовувати спільну поведінку для класів, які не пов’язані ієрархією.</li>\n  <li><strong>Реалізація методів:</strong> Абстрактний клас може містити часткову реалізацію методів. Інтерфейс до Java 8 мав лише абстрактні методи, а з Java 8 можуть містити <code>default</code> та <code>static</code> методи з реалізацією.</li>\n  <li><strong>Конструктори:</strong> Інтерфейс не має конструкторів. Абстрактний клас може мати конструктори для ініціалізації стану об’єкта, що успадковується.</li>\n</ol>\n\n<h4>Коли використовувати абстрактний клас:</h4>\n<ul>\n  <li>Коли потрібно створити ієрархію однотипних класів з частковою реалізацією.</li>\n  <li>Коли підкласи мають спільний стан або методи за замовчуванням.</li>\n  <li>Коли необхідно уникнути повторення коду серед схожих класів.</li>\n</ul>\n\n<h4>Коли використовувати інтерфейс:</h4>\n<ul>\n  <li>Коли потрібно визначити контракт (набір методів), який можуть реалізувати різні класи.</li>\n  <li>Коли класи не мають спільної ієрархії.</li>\n  <li>Коли потрібно забезпечити багатократну реалізацію поведінки (один клас може реалізовувати кілька інтерфейсів).</li>\n  <li>Для створення семантики класу та узгодження його можливостей без обмежень ієрархії.</li>\n</ul>\n\n<p><strong>Висновок:</strong> Абстрактні класи застосовуються для створення часткової реалізації ієрархії схожих класів, тоді як інтерфейси описують лише поведінку і дозволяють класам розширювати функціональність без обмежень ієрархії.</p>","topicName":"Core-1"},{"id":112,"questionText":"Що має вищий рівень абстракції – клас, абстрактний клас чи\nінтерфейс?","answer":"<p>Інтерфейс.</p>","topicName":"Core-1"},{"id":113,"questionText":"Можливе успадкування одного інтерфейсу від іншого? А двох інших?","answer":"<p>Так, можливе. Використовується ключове слово extends.</p>","topicName":"Core-1"},{"id":114,"questionText":"Що таке дефолтні методи інтерфейсів? Для чого вони потрібні?","answer":"<p>У Java 8 з'явилися <strong>дефолтні методи</strong> інтерфейсів, позначені ключовим словом <code>default</code>. Вони дозволяють інтерфейсам мати власну реалізацію методів, яка використовується, якщо клас, що реалізує інтерфейс, не перевизначає цей метод.</p>\n\n<p>Призначення дефолтних методів:</p>\n<ul>\n  <li>Забезпечують <strong>зворотну сумісність</strong>: можна додавати нові методи в інтерфейс без потреби змінювати всі його реалізації.</li>\n  <li>Дозволяють інтерфейсу надавати <strong>базову реалізацію</strong> для методів, яку за необхідності можна перевизначити в класі-реалізації.</li>\n</ul>\n\n<p>Таким чином, дефолтні методи ефективно вирішують проблему розширення інтерфейсів без порушення існуючого коду.</p>","topicName":"Core-1"},{"id":115,"questionText":"Чому в деяких інтерфейсах взагалі не визначають методів?","answer":"<p>Такі інтерфейси називаються <strong>маркерними інтерфейсами</strong>. Вони не містять методів і служать лише для того, щоб позначити, що клас належить до певного типу або підтримує певну можливість.</p>\n\n<p>Приклад: <code>Cloneable</code> – маркерний інтерфейс, який вказує, що клас підтримує механізм клонування об'єктів.</p>","topicName":"Core-1"},{"id":116,"questionText":"Що таке статичний метод інтерфейсу?","answer":"<p>Статичні методи інтерфейсу схожі на методи за замовчуванням, але їх не можна перевизначати в класах, які реалізують інтерфейс. Вони належать самому інтерфейсу і не можуть бути викликані через об'єкти класу-реалізації.</p>\n\n<p>Особливості статичних методів інтерфейсу:</p>\n<ul>\n  <li>Належність саме інтерфейсу, а не класу-реалізації.</li>\n  <li>Методи класу <code>java.lang.Object</code> не можна оголосити як статичні.</li>\n  <li>Використовуються для допоміжних операцій, наприклад, перевірки на <code>null</code>, сортування колекцій тощо.</li>\n</ul>","topicName":"Core-1"},{"id":117,"questionText":"Як викликати статичний метод інтерфейсу?","answer":"<p>Використовуючи ім'я інтерфейсу:</p>\n<pre><code>Paper.show();\n</code></pre>","topicName":"Core-1"},{"id":118,"questionText":"Чому неможливо оголосити метод інтерфейсу з модифікатором final?","answer":"<p>У випадку інтерфейсів вказання модифікатора <code>final</code> не має сенсу, оскільки всі методи інтерфейсів неявно оголошуються як <code>abstract</code>. Це означає, що вони не мають реалізації і повинні бути реалізовані у класі, який імплементує інтерфейс. Якщо метод позначити як <code>final</code>, його неможливо буде перевизначити, що суперечить головній меті інтерфейсу.</p>","topicName":"Core-1"},{"id":119,"questionText":"Як вирішується проблема ромбовидної спадковості при успадкуванні інтерфейсів за наявності методів за замовчуванням?","answer":"<p><strong>Відповідь:</strong> Обов'язковим перевизначенням методу за замовчуванням.</p>\n<p>У разі виклику методу за замовчуванням з інтерфейсу його обов'язково доведеться перевизначити.</p>","topicName":"Core-1"},{"id":120,"questionText":"Як відбувається виклик конструкторів ініціалізації з урахуванням ієрархії класів?","answer":"<ol>\n    <li>Спочатку викликаються всі <strong>статичні блоки</strong> у порядку від першого статичного блоку кореневого предка до статичних блоків самого класу.</li>\n    <li>Потім викликаються <strong>нестатичні блоки ініціалізації</strong> кореневого предка, його конструктор, і далі вгору по ієрархії до нестатичних блоків і конструктора поточного класу.</li>\n    <li>При створенні об'єкта похідного класу конструктори викликаються зверху вниз по ієрархії — від базового класу до похідного.</li>\n</ol>","topicName":"Core-1"},{"id":121,"questionText":"Навіщо потрібні і які бувають блоки ініціалізації?","answer":"<p>Блоки ініціалізації — це код, укладений у фігурні дужки і розташований всередині класу поза методами та конструкторами. Вони потрібні для виконання певного коду під час ініціалізації класу або об'єкта.</p>\n<p>Існують два типи блоків ініціалізації:</p>\n<ul>\n    <li><strong>Статичні блоки</strong> – виконуються під час завантаження класу завантажувачем класів.</li>\n    <li><strong>Нестатичні блоки</strong> – виконуються перед конструктором при створенні об'єкта класу.</li>\n</ul>\n<p>Особливості блоків ініціалізації:</p>\n<ul>\n    <li>Кілька блоків виконуються у порядку їх розташування в коді класу.</li>\n    <li>Можуть генерувати винятки, якщо вони оголошені у секції <code>throws</code> для всіх конструкторів класу.</li>\n    <li>Можна створювати навіть у безіменних класах.</li>\n    <li>Використовуються для коду, який повинен виконуватися один раз під час ініціалізації.</li>\n</ul>","topicName":"Core-1"},{"id":122,"questionText":"Для чого використовуються статичні блоки ініціалізації?","answer":"<p>\n  Статичні блоки ініціалізації використовуються для виконання коду, \n  який повинен виконуватися <strong>один раз</strong> при ініціалізації класу \n  завантажувачем класів у момент перед створенням об'єктів цього класу за допомогою конструктора.\n</p>\n<p>\n  Такий блок належить лише самому класу.\n</p>","topicName":"Core-1"},{"id":123,"questionText":"Де дозволена ініціалізація статичних/нестатичних полів?","answer":"<p>\n  <strong>Статичні поля</strong> можна ініціалізувати:\n  <ul>\n    <li>при оголошенні;</li>\n    <li>у статичному блоці ініціалізації;</li>\n    <li>у нестатичному блоці ініціалізації.</li>\n  </ul>\n</p>\n<p>\n  <strong>Нестатичні поля</strong> можна ініціалізувати:\n  <ul>\n    <li>при оголошенні;</li>\n    <li>у нестатичному блоці ініціалізації;</li>\n    <li>у конструкторі.</li>\n  </ul>\n</p>","topicName":"Core-1"},{"id":124,"questionText":"Що станеться, якщо в блоку ініціалізації виникне виключна ситуація?","answer":"<p>\n  Для <strong>нестатичних блоків ініціалізації</strong>, якщо викидання виключення вказано явно,\n  потрібно, щоб оголошення цих виключень були перелічені в операторах викидання всіх конструкторів класу.\n  В іншому випадку виникне помилка компіляції.\n</p>\n<p>\n  У всіх інших випадках взаємодія з виключеннями відбувається так само, як і в будь-якому іншому місці.\n  Клас не буде ініціалізований, якщо помилка відбувається в <strong>статичному блоці</strong>,\n  і об'єкт класу не буде створений, якщо помилка виникає в <strong>нестатичному блоці</strong>.\n</p>\n<p>\n  Для статичного блоку викидання виключення явно призведе до помилки компіляції\n  <strong>ExceptionInInitializerError</strong>.\n</p>","topicName":"Core-1"},{"id":125,"questionText":"Яке виключення викидається при виникненні помилки в блоку ініціалізації класу?","answer":"<p>Якщо виникає виключення, яке є нащадком <code>Error</code>:</p>\n<ul>\n  <li>Для <strong>статичних блоків ініціалізації</strong> буде викинуто \n      <code>java.lang.ExceptionInInitializerError</code>.</li>\n  <li>Для <strong>нестатичних блоків</strong> буде прокинуто виключення-джерело.</li>\n</ul>\n\n<p>Якщо виняток є нащадком <code>Error</code>, то в обох випадках буде викинуто <code>java.lang.Error</code>.</p>\n\n<p>Якщо виняток — це <code>java.lang.ThreadDeath</code> (смерть потоку), тоді жодне виключення не буде викинуто.</p>","topicName":"Core-1"},{"id":126,"questionText":"Що таке клас Object?","answer":"<p>Усі класи в Java є нащадками суперкласу <code>Object</code>. Це не потрібно вказувати явно. В результаті об'єкт <code>Object</code> може посилатися на об'єкт будь-якого іншого класу.</p>","topicName":"Core-1"},{"id":127,"questionText":"Що таке клас Object й які він має методи?","answer":"<p><code>Object</code> — це базовий клас для всіх інших об'єктів у Java. Будь-який клас успадковує <code>Object</code> і, відповідно, його методи:</p>\n\n<ul>\n  <li><code>public boolean equals(Object obj)</code> — порівнює об'єкти за значенням.</li>\n  <li><code>public int hashCode()</code> — повертає хеш-код об'єкта.</li>\n  <li><code>public String toString()</code> — повертає рядкове представлення об'єкта.</li>\n  <li><code>public final Class getClass()</code> — повертає клас об'єкта під час виконання.</li>\n  <li><code>protected Object clone()</code> — створює та повертає копію об'єкта.</li>\n  <li><code>public final void notify()</code> — відновлює один потік, який очікує монітор.</li>\n  <li><code>public final void notifyAll()</code> — відновлює всі потоки, які очікують монітор.</li>\n  <li><code>public final void wait()</code> — зупиняє потік до виклику <code>notify()</code> або <code>notifyAll()</code>.</li>\n  <li><code>public final void wait(long timeout)</code> — зупиняє потік на певний час або до виклику <code>notify()</code>/<code>notifyAll()</code>.</li>\n  <li><code>public final void wait(long timeout, int nanos)</code> — зупиняє потік на певний час з точністю до наносекунд або до виклику <code>notify()</code>/<code>notifyAll()</code>.</li>\n  <li><code>protected void finalize()</code> — викликається збирачем сміття перед видаленням об'єкта.</li>\n</ul>","topicName":"Core-1"},{"id":128,"questionText":"Розкажіть про equals та hashCode","answer":"<p><strong>hashCode()</strong> — це метод, що повертає ціле число (хеш-код) об'єкта. Використовується, зокрема, у колекціях на основі хешування (HashMap, HashSet). \nХеш-код обчислюється нативним методом на основі стану об'єкта.</p>\n\n<p><strong>equals()</strong> — метод класу <code>Object</code>, який служить для порівняння об'єктів. \nПри використанні <code>==</code> порівнюються посилання на об'єкти, а <code>equals()</code> може бути перевизначений для порівняння станів (значень) об'єктів.</p>\n\n<p><em>Важливо:</em> при перевизначенні <code>equals()</code> потрібно також перевизначати <code>hashCode()</code>, щоб зберегти контракт: рівні об'єкти повинні мати однаковий хеш-код.</p>\n\n<h4>Властивості equals():</h4>\n<ul>\n  <li><strong>Рефлексивність</strong> — для будь-якого об'єкта <code>x</code>, <code>x.equals(x)</code> має повертати <code>true</code>.</li>\n  <li><strong>Симетричність</strong> — для об'єктів <code>x</code> і <code>y</code>: якщо <code>x.equals(y)</code> — <code>true</code>, то і <code>y.equals(x)</code> — <code>true</code>.</li>\n  <li><strong>Транзитивність</strong> — якщо <code>x.equals(y)</code> і <code>y.equals(z)</code> повертають <code>true</code>, то і <code>x.equals(z)</code> має повертати <code>true</code>.</li>\n  <li><strong>Непротирічність</strong> — багаторазові виклики <code>x.equals(y)</code> повинні давати один і той самий результат, якщо стан об'єктів не змінюється.</li>\n  <li><strong>Сумісність з hashCode()</strong> — рівні об'єкти (<code>equals() == true</code>) повинні мати однакові значення <code>hashCode()</code>.</li>\n</ul>","topicName":"Core-1"},{"id":129,"questionText":"Яким чином реалізовані методи hashCode() та equals() у класі Object?","answer":"<p><strong>equals()</strong> у класі Object порівнює лише посилання на об'єкти:</p>\n<pre>\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n</pre>\n\n<p><strong>hashCode()</strong> визначений як native-метод, тобто реалізований на рівні JVM, і зазвичай повертає адресу об'єкта в пам'яті:</p>\n<pre>\npublic native int hashCode();\n</pre>","topicName":"Core-1"},{"id":130,"questionText":"Навіщо потрібен метод <code>equals()</code>? Як він відрізняється від операції <code>==</code>?","answer":"<p>Метод <code>equals()</code> визначає відношення еквівалентності між об'єктами.</p>\n<ul>\n  <li>Операція <code>==</code> порівнює лише посилання на об'єкти (чи вказують вони на один і той самий об'єкт у пам'яті).</li>\n  <li>Метод <code>equals()</code>, за замовчуванням або перевизначений розробником, порівнює об'єкти за їх внутрішнім станом, тобто за значеннями полів.</li>\n</ul>","topicName":"Core-1"},{"id":131,"questionText":"Як правильно перевизначити метод <code>Object.equals()</code>?","answer":"<p>Правила перевизначення методу <code>equals()</code>:</p>\n<ul>\n  <li>Спершу використовуйте оператор <code>==</code>, щоб перевірити, чи є аргумент тим самим об'єктом. Якщо так, повертається <code>true</code>. Якщо аргумент <code>null</code>, повертається <code>false</code>.</li>\n  <li>Перевірте тип аргументу за допомогою <code>instanceof</code> або <code>getClass()</code>. Якщо тип не співпадає, повертається <code>false</code>.</li>\n  <li>Приведіть аргумент до потрібного типу. Цей крок безпечний після перевірки типу.</li>\n  <li>Перевірте всі значущі поля класу. Порівняйте значення полів поточного об'єкта з відповідними полями аргументу. Якщо всі збігаються, повертається <code>true</code>, інакше — <code>false</code>.</li>\n  <li>Після перевизначення переконайтеся, що відношення еквівалентності відповідає властивостям: рефлексивність, симетричність, транзитивність і непротирічність. При необхідності метод слід скоригувати.</li>\n</ul>","topicName":"Core-1"},{"id":132,"questionText":"Що станеться, якщо перевизначити <code>equals()</code>, не перевизначаючи <code>hashCode()</code>? Які можуть виникнути проблеми?","answer":"<p>Якщо перевизначити <code>equals()</code>, але не перевизначити <code>hashCode()</code>, класи та методи, які покладаються на контракт <code>equals()</code> і <code>hashCode()</code>, можуть працювати некоректно.</p>\n\n<p>Наприклад, у <code>HashMap</code> це може призвести до ситуації, коли пара \"ключ-значення\", яка була додана до мапи, не буде знайдена при використанні нового екземпляра ключа, навіть якщо <code>equals()</code> повертає <code>true</code>.</p>","topicName":"Core-1"},{"id":133,"questionText":"Який контракт між <code>hashCode()</code> та <code>equals()</code>?","answer":"<ol>\n  <li>Якщо два об'єкти повертають різні значення <code>hashCode()</code>, вони не можуть бути рівні.</li>\n  <li>Якщо <code>equals()</code> між об'єктами повертає <code>true</code>, їхні хеш-коди повинні бути рівні.</li>\n  <li>Перевизначивши <code>equals()</code>, завжди слід перевизначати і <code>hashCode()</code>.</li>\n</ol>","topicName":"Core-1"},{"id":134,"questionText":"Для чого потрібний метод <code>hashCode()</code>?","answer":"<p>Метод <code>hashCode()</code> використовується для обчислення хеш-коду об'єкта, переданого як параметр. У Java хеш-код представлений як ціле число (<code>int</code>), або у більш широкому сенсі — як бітовий рядок фіксованої довжини, отриманий із масиву довільної довжини. Для одного й того ж об'єкта хеш-код завжди буде однаковим.</p>\n\n<p>Варто пам'ятати, що множина можливих хеш-кодів обмежена типом <code>int</code>, а множина об'єктів — ні. Тому можлива ситуація, коли хеш-коди різних об'єктів можуть співпадати:</p>\n<ul>\n  <li>Якщо хеш-коди різні, об'єкти гарантовано різні;</li>\n  <li>Якщо хеш-коди рівні, об'єкти не обов'язково рівні.</li>\n</ul>\n\n<p>Якщо <code>hashCode()</code> не перевизначений, використовується реалізація за замовчуванням з класу <code>Object</code>, яка гарантує різні хеш-коди для різних об'єктів. Значення <code>int</code> може бути як додатнім, так і від'ємним, і при перевизначенні хеш-коду можна використовувати будь-яке допустиме значення.</p>","topicName":"Core-1"},{"id":135,"questionText":"Правила перевизначення методу <code>hashCode()</code>","answer":"<ol>\n  <li>Якщо хеш-коди різні, то об'єкти гарантовано різні.</li>\n  <li>Якщо хеш-коди рівні, об'єкти не обов'язково рівні.</li>\n  <li>При обчисленні хеш-коду слід використовувати ті ж поля, які порівнюються у <code>equals()</code> і які не обчислюються на основі інших значень.</li>\n</ol>","topicName":"Core-1"},{"id":136,"questionText":"Рекомендації щодо вибору полів для <code>hashCode()</code>","answer":"<p>Слід обирати поля, які з великою ймовірністю будуть різнитися між об'єктами. Найкраще використовувати унікальні або примітивні поля, наприклад <code>id</code> або <code>uuid</code>.</p>\n\n<p>Важливо дотримуватися правила: якщо поля використовуються при обчисленні <code>hashCode()</code>, вони повинні бути також задіяні при виконанні <code>equals()</code>.</p>","topicName":"Core-1"},{"id":137,"questionText":"Чи можуть різні об'єкти мати однаковий <code>hashCode()</code>?","answer":"<p>Так, можуть. Метод <code>hashCode()</code> не гарантує унікальність поверненого значення. Ситуація, коли у різних об'єктів однакові хеш-коди, називається колізією.</p>\n\n<p>Ймовірність виникнення колізії залежить від алгоритму генерації хеш-коду.</p>","topicName":"Core-1"},{"id":138,"questionText":"Чому неможливо реалізувати <code>hashCode()</code>, який гарантує унікальність для кожного об'єкта?","answer":"<p>У Java множина можливих хеш-кодів обмежена типом <code>int</code>, тоді як множина об'єктів необмежена. Через це можлива ситуація, коли хеш-коди різних об'єктів можуть збігатися.</p>","topicName":"Core-1"},{"id":139,"questionText":"Чому хеш-код у вигляді <code>31 * x + y</code> вважається кращим за <code>x + y</code>?","answer":"<ul>\n  <li>Множник створює залежність значення хеш-коду від порядку обробки полів, що покращує якість хеш-функції.</li>\n  <li>Число 31 легко зсувається бітовим чином, що оптимізує обчислення.</li>\n  <li>У хеш-коді повинні фігурувати ті поля, які використовуються в <code>equals()</code>.</li>\n</ul>","topicName":"Core-1"},{"id":140,"questionText":"Чим <code>a.getClass().equals(A.class)</code> відрізняється від <code>a instanceof A</code>?","answer":"<p><strong>getClass()</strong> отримує точний клас об'єкта, а оператор <strong>instanceof</strong> перевіряє, чи є об'єкт екземпляром класу або його нащадка.</p>\n\n<ul>\n  <li><code>instanceof</code> – перевіряє, чи є об'єкт екземпляром певного класу, його дочірнього класу або класу, що реалізує зазначений інтерфейс.</li>\n  <li><code>this.getClass() == that.getClass()</code> – порівнює точні класи обох об'єктів, тому для правильного виконання контракту <code>equals()</code> слід використовувати саме <code>getClass()</code>.</li>\n</ul>","topicName":"Core-1"},{"id":141,"questionText":"Що таке виняток?","answer":"<p>Виняток – це помилка (об'єкт), яка виникає під час виконання програми.</p>","topicName":"Core-1"},{"id":142,"questionText":"Опишіть ієрархію винятків","answer":"<p>Всі винятки в Java походять від спільного предка <code>Throwable</code>. Його нащадками є два основні класи:</p>\n<ul>\n  <li><strong>Error</strong> – помилки, що вказують на серйозні проблеми, які зазвичай не слід обробляти в програмі, оскільки вони пов'язані з проблемами на рівні JVM (наприклад, закінчилася пам'ять у віртуальній машині).</li>\n  <li><strong>Exception</strong> – винятки, що виникають через проблеми в програмі, які можна передбачити та обробити. Наприклад, ділення цілого числа на нуль.</li>\n</ul>\n<p>Таким чином, ієрархія винятків виглядає так:</p>\n<pre>\nThrowable\n├── Error\n└── Exception\n</pre>\n<p>Ця структура допомагає розрізняти помилки, які слід ігнорувати на рівні програми, і ті, які потрібно обробляти.</p>","topicName":"Core-1"},{"id":143,"questionText":"Розкажіть про обробляються і необробляються винятки","answer":"<p>У Java всі винятки поділяються на два основні типи:</p>\n<ul>\n  <li><strong>Checked (контрольовані) винятки</strong> – такі винятки повинні обов'язково оброблятися блоком <code>catch</code> або бути зазначеними в сигнатурі методу через <code>throws</code> (наприклад, <code>throws IOException</code>). Наявність обробки перевіряється на етапі компіляції.</li>\n  <li><strong>Unchecked (неконтрольовані) винятки</strong> – це помилки класу <code>Error</code> (наприклад, <code>OutOfMemoryError</code>), які не рекомендується обробляти, та винятки часу виконання (<code>RuntimeException</code> і його нащадки, наприклад <code>NullPointerException</code>), які можуть не оброблятися блоком <code>catch</code> і не бути вказаними в сигнатурі методу.</li>\n</ul>","topicName":"Core-1"},{"id":144,"questionText":"Чи можна обробляти unchecked винятки?","answer":"<p>Так, неперевірені (unchecked) винятки можна обробити, щоб у певних випадках програма не завершила свою роботу. Їх можна перехопити за допомогою блоку <code>try-catch</code>.</p>","topicName":"Core-1"},{"id":145,"questionText":"Який оператор дозволяє примусово викинути виняток?","answer":"<p>Оператор, який дозволяє примусово викинути виняток, — це <code>throw</code>:</p>\n<pre><code>throw new Exception();</code></pre>","topicName":"Core-1"},{"id":146,"questionText":"Про що говорить ключове слово <code>throws</code>?","answer":"<p>Ключове слово <code>throws</code> вказує, що метод потенційно може викинути виняток зазначеного типу. Воно використовується в сигнатурі методу і повідомляє, що обробку винятка можна передати вищестоячому методу. Зазвичай застосовується в методах, конструкторах або класах.</p>","topicName":"Core-1"},{"id":147,"questionText":"Як написати власний виняток?","answer":"<p>Щоб створити власний (користувацький) виняток, потрібно успадкуватися від базового класу відповідного типу винятків, наприклад, <code>Exception</code> або <code>RuntimeException</code>, та при необхідності перевизначити методи.</p>","topicName":"Core-1"},{"id":148,"questionText":"Які існують unchecked exception?","answer":"<p>До неперевірених винятків (unchecked exceptions) відносяться найчастіше такі:</p>\n<ul>\n  <li>ArithmeticException</li>\n  <li>ClassCastException</li>\n  <li>ConcurrentModificationException</li>\n  <li>IllegalArgumentException</li>\n  <li>IllegalStateException</li>\n  <li>IndexOutOfBoundsException</li>\n  <li>NoSuchElementException</li>\n  <li>NullPointerException</li>\n  <li>UnsupportedOperationException</li>\n</ul>","topicName":"Core-1"},{"id":149,"questionText":"Що таке помилки класу Error?","answer":"<p>Помилки класу <strong>Error</strong> представляють собою найбільш серйозні проблеми на рівні JVM. Наприклад, такі винятки виникають, якщо закінчилася пам'ять, доступна віртуальній машині. Обробляти такі помилки не заборонено, але робити це не рекомендується.</p>","topicName":"Core-1"},{"id":150,"questionText":"Що ви знаєте про OutOfMemoryError?","answer":"<p><strong>OutOfMemoryError</strong> виникає, коли віртуальна машина Java не може створити (розмістити) об'єкт через нестачу пам'яті, і збирач сміття не може вивільнити достатню кількість пам'яті.</p>\n\n<p>Залежно від області пам'яті, в якій відбулася нестача місця, існує кілька типів OutOfMemoryError:</p>\n<ul>\n  <li><code>java.lang.OutOfMemoryError: Java heap space</code> – не вистачає місця в \"кучі\" (heap), де зберігаються об'єкти. Зазвичай пов'язано з витоком пам'яті.</li>\n  <li><code>java.lang.OutOfMemoryError: PermGen space</code> (до Java 8) – нестача місця в постійній області (Permanent Generation), розмір якої задається параметрами <code>-XX:PermSize</code> та <code>-XX:MaxPermSize</code>.</li>\n  <li><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> – пам'яті мало, і збирач сміття постійно працює, намагаючись вивільнити її. Можна вимкнути через параметр <code>-XX:-UseGCOverheadLimit</code>.</li>\n  <li><code>java.lang.OutOfMemoryError: unable to create new native thread</code> – неможливо створити нові потоки через нестачу ресурсів.</li>\n</ul>","topicName":"Core-1"},{"id":151,"questionText":"Опишіть роботу блока try-catch-finally","answer":"<p>Блок <strong>try</strong> використовується для позначення початку коду, який потенційно може призвести до помилки.</p>\n<p>Блок <strong>catch</strong> призначений для перехоплення та обробки винятків у випадку їх виникнення.</p>\n<p>Блок <strong>finally</strong> є додатковим і виконується у будь-якому випадку — чи було викинуто виняток, чи ні. Зазвичай використовується для закриття ресурсів або прибирання.</p>\n\n<p>Загальний вигляд конструкції:</p>\n<pre><code>try {\n    // код, який потенційно може призвести до виняткової ситуації\n} catch(SomeException e) { \n    // код обробки виняткової ситуації\n} finally {\n    // необов'язковий блок, код якого виконується у будь-якому випадку\n}</code></pre>","topicName":"Core-1"},{"id":152,"questionText":"Можливе використання блоку try-finally (без catch)?","answer":"<p>Так, така конструкція допустима, але її практична користь обмежена. Зазвичай краще мати блок <strong>catch</strong> для обробки винятків.</p>\n<p>У конструкції <strong>try-finally</strong> після завершення блоку <strong>try</strong> завжди виконується блок <strong>finally</strong>:</p>\n<pre><code>try {\n    // код, який може викликати виняток\n} finally {\n    // код, який виконується у будь-якому випадку\n}</code></pre>","topicName":"Core-1"},{"id":153,"questionText":"Чи може один блок catch виловлювати кілька винятків одночасно?","answer":"<p>У Java 7 з'явилася можливість перехоплювати кілька винятків одним блоком <strong>catch</strong> за допомогою оператора <strong>|</strong>:</p>\n<pre><code>try {\n    // код, який може викликати винятки\n} catch(IOException | SQLException ex) {\n    // обробка будь-якого з перелічених винятків\n}</code></pre>","topicName":"Core-1"},{"id":154,"questionText":"Чи завжди виконується блок finally? Чи існують ситуації, коли блок finally не буде виконаний?","answer":"<p>Блок <strong>finally</strong> зазвичай виконується завжди, але є винятки, коли він може не виконатися:</p>\n<ul>\n  <li>Якщо під час виконання блоку <strong>try</strong> викликається <code>System.exit(0)</code> або <code>Runtime.getRuntime().exit(0)</code>, <code>Runtime.getRuntime().halt(0)</code>;</li>\n  <li>Якщо JVM завершує роботу через критичну помилку або недопустиму операцію;</li>\n  <li>Якщо блок <strong>try</strong> містить безкінечний цикл, і виконання програми ніколи не досягає кінця блоку.</li>\n</ul>","topicName":"Core-1"},{"id":155,"questionText":"Чи може метод <code>main()</code> викинути виняток назовні, і де буде його обробка?","answer":"<p>Так, метод <code>main()</code> може викидати винятки назовні. У цьому випадку виняток буде переданий віртуальній машині Java (JVM), яка за замовчуванням обробляє його та виводить інформацію про помилку у консоль.</p>","topicName":"Core-1"},{"id":156,"questionText":"У якому порядку слід обробляти винятки в блоках <code>catch</code>?","answer":"<p>Винятки слід обробляти від нащадка до предка. Спочатку перехоплюються більш специфічні (похідні) винятки, а потім – більш загальні (батьківські), щоб уникнути конфліктів і помилок компіляції.</p>","topicName":"Core-1"},{"id":157,"questionText":"Що таке механізм <code>try-with-resources</code>?","answer":"<p>Механізм <code>try-with-resources</code>, який з'явився в Java 7, дозволяє використовувати блок <code>try-catch</code> без необхідності явно закривати ресурси. Ресурси оголошуються в дужках після <code>try</code>, і компілятор автоматично створює секцію <code>finally</code>, де відбувається звільнення цих ресурсів.</p>\n<p>Під ресурсами мають на увазі об'єкти, що реалізують інтерфейс <code>java.lang.AutoCloseable</code>.</p>\n<p>Блоки <code>catch</code> і явний <code>finally</code> виконуються після того, як ресурси закриваються неявно в <code>finally</code>.</p>","topicName":"Core-1"},{"id":158,"questionText":"Що станеться, якщо виключення буде викинуто з блоку <code>catch</code>, а потім інше виключення з блоку <code>finally</code>?","answer":"<p>Блок <code>finally</code> може «перетерти» виключення або значення, що повертається (<code>throw</code> / <code>return</code>), іншим виключенням або оператором <code>return</code>, тобто попереднє виключення з <code>catch</code> буде втрачено.</p>","topicName":"Core-1"},{"id":159,"questionText":"Що станеться, якщо виключення буде викинуто з блоку <code>catch</code>, а потім інше виключення з метода <code>close()</code> при використанні try-with-resources?","answer":"<p>У конструкції <code>try-with-resources</code> існує механізм збереження «пригнічених» виключень. Виключення, яке виникає в блоці <code>try</code> або <code>catch</code>, має більший пріоритет, а виключення, що виникає під час закриття ресурсу методом <code>close()</code>, зберігається як «suppressed» (пригнічене) виключення.</p>","topicName":"Core-1"},{"id":160,"questionText":"Припустимо, є метод, який може викинути IOException і FileNotFoundException. У якій послідовності слід розташовувати блоки catch і скільки блоків буде виконано?","answer":"<p>Загальне правило: блоки <code>catch</code> обробляють виключення від більш специфічного (молодшого) до більш загального (старшого). Якщо спершу поставити <code>catch(Exception ex)</code>, усі подальші блоки не зможуть обробити винятки, бо будь-яке виключення підпаде під цей блок.</p>\n<p>Оскільки <code>FileNotFoundException</code> наслідує <code>IOException</code>, правильний порядок блоків:</p>\n<pre><code>void method() {\n    try {\n        // код, який може викликати виняток\n    } catch (FileNotFoundException ex) {\n        // обробка FileNotFoundException\n    } catch (IOException ex) {\n        // обробка інших IOException\n    }\n}</code></pre>\n<p>У цьому випадку буде виконано лише один блок <code>catch</code> для конкретного виключення.</p>","topicName":"Core-1"},{"id":161,"questionText":"Що таке серіалізація і як вона реалізована в Java?","answer":"<p>Серіалізація (Serialization) – це процес перетворення структури даних в послідовність байтів для зберігання або передачі. Серіалізовані об'єкти можна пізніше відновити (десеріалізувати).</p>\n<p>У Java реалізовано два основних способи серіалізації:</p>\n<ul>\n  <li><strong>Стандартна серіалізація</strong> – через інтерфейс <code>java.io.Serializable</code>.</li>\n  <li><strong>Розширена серіалізація</strong> – через інтерфейс <code>java.io.Externalizable</code>.</li>\n</ul>\n<p>Серіалізація дозволяє в певному обсязі змінювати клас без порушення сумісності:</p>\n<ul>\n  <li>додавати нові поля;</li>\n  <li>змінювати поля зі статичних на нестатичні;</li>\n  <li>змінювати поля з транзитних на непередавані.</li>\n</ul>\n<p>Зворотні зміни (з нестатичних полів на статичні, з непередаваних на транзитні) або видалення полів потребують додаткової обробки залежно від вимог до оберненої сумісності.</p>","topicName":"Core-1"},{"id":162,"questionText":"Навіщо потрібна серіалізація?","answer":"<p>Серіалізація потрібна для компактного збереження стану об'єкта та подальшого його відновлення (зчитування стану).</p>","topicName":"Core-1"},{"id":163,"questionText":"Опишіть процес серіалізації/десеріалізації з використанням Serializable","answer":"<p>При використанні інтерфейсу <code>Serializable</code> алгоритм серіалізації за допомогою Reflection API виконує наступне:</p>\n<ul>\n  <li>Запис у потік метаданих про клас, пов'язаний з об'єктом (ім'я класу, ідентифікатор <code>SerialVersionUID</code>, ідентифікатори полів класу).</li>\n  <li>Рекурсивний запис у потік опису суперкласів до <code>java.lang.Object</code> (не включно).</li>\n  <li>Запис примітивних значень полів серіалізованого екземпляра, починаючи з полів самого верхнього суперкласу.</li>\n  <li>Рекурсивний запис об'єктів, які є полями серіалізованого об'єкта. Раніше серіалізовані об'єкти повторно не серіалізуються, що дозволяє коректно працювати з циклічними посиланнями.</li>\n</ul>\n<p>Під час десеріалізації виділяється пам'ять під об'єкт, після чого його поля заповнюються значеннями з потоку. Конструктор об'єкта при цьому не викликається. Однак буде викликаний конструктор без параметрів батьківського несеріалізованого класу, і його відсутність призведе до помилки десеріалізації.</p>","topicName":"Core-1"},{"id":164,"questionText":"Як змінити стандартну поведінку серіалізації/десеріалізації?","answer":"<p>Щоб змінити стандартну поведінку серіалізації/десеріалізації, можна скористатися такими підходами:</p>\n<ul>\n  <li>Реалізувати інтерфейс <code>java.io.Externalizable</code>, який дозволяє застосовувати власну логіку серіалізації. Метод серіалізації описується у <code>writeExternal()</code>, а десеріалізації – у <code>readExternal()</code>. Під час десеріалізації спочатку викликається конструктор без параметрів, а потім на створеному об'єкті виконується <code>readExternal()</code>.</li>\n  <li>Якщо у серіалізованого об'єкта реалізовані наступні методи, механізм серіалізації використовуватиме їх замість стандартних:\n    <ul>\n      <li><code>writeObject()</code> – запис об'єкта в потік;</li>\n      <li><code>readObject()</code> – читання об'єкта з потоку;</li>\n      <li><code>writeReplace()</code> – дозволяє замінити об'єкт іншим перед записом;</li>\n      <li><code>readResolve()</code> – дозволяє замінити об'єкт іншим після читання.</li>\n    </ul>\n  </li>\n</ul>","topicName":"Core-1"},{"id":165,"questionText":"Які поля не будуть серіалізовані при серіалізації? Чи серіалізуються final-поля?","answer":"<ul>\n  <li><strong>Поля з модифікатором <code>transient</code></strong> – такі поля не серіалізуються. Після десеріалізації їх значення буде <code>null</code> або дефолтним для примітивного типу.</li>\n  <li><strong>Статичні поля</strong> – значення статичних полів автоматично не зберігаються під час серіалізації.</li>\n  <li><strong>Final-поля</strong> – серіалізуються як звичайні поля. Але при використанні <code>Externalizable</code> їх неможливо змінити під час десеріалізації через <code>readExternal()</code>, оскільки final-поля повинні бути ініціалізовані в конструкторі. Тому, якщо необхідно серіалізувати об'єкт із final-полем, слід використовувати стандартну серіалізацію через <code>Serializable</code> (рефлексію).</li>\n  <li>Якщо final-поля не є користувацькими, вони будуть десеріалізовуватися нормально.</li>\n</ul>","topicName":"Core-1"},{"id":166,"questionText":"Як створити власний протокол серіалізації?","answer":"<p>Щоб створити власний протокол серіалізації, потрібно реалізувати інтерфейс <code>Externalizable</code> і перевизначити методи <code>writeExternal()</code> та <code>readExternal()</code>. На відміну від стандартної серіалізації, тут нічого не відбувається автоматично – протокол повністю контролюється розробником.</p>\n<p>Інтерфейс <code>Externalizable</code> містить два методи:</p>\n<pre><code>public void writeExternal(ObjectOutput out) throws IOException;\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;\n</code></pre>\n<p>В <code>writeExternal()</code> слід описати, як записувати стан об'єкта у потік, а в <code>readExternal()</code> – як відновлювати об'єкт з потоку.</p>","topicName":"Core-1"},{"id":167,"questionText":"Яка роль поля <code>serialVersionUID</code> у серіалізації?","answer":"<p>Поле <code>serialVersionUID</code> використовується для вказівки версії серіалізованих даних. Воно дозволяє JVM перевіряти сумісність класу під час десеріалізації. Якщо це поле не оголосити явно, середовище виконання Java згенерує його автоматично, але процес генерації чутливий до багатьох метаданих класу, таких як:</p>\n<ul>\n  <li>кількість та типи полів;</li>\n  <li>модифікатори доступу полів;</li>\n  <li>інтерфейси, які реалізовані в класі;</li>\n  <li>інші характеристики класу.</li>\n</ul>\n<p>Рекомендується явно оголошувати <code>serialVersionUID</code>, оскільки при зміні класу (додаванні або видаленні полів) автоматично згенероване значення може змінитися, і під час виконання може бути викинутий виняток <code>InvalidClassException</code>.</p>\n<pre><code>private static final long serialVersionUID = 20161013L;\n</code></pre>","topicName":"Core-1"},{"id":168,"questionText":"Коли варто змінювати значення поля <code>serialVersionUID</code>?","answer":"<p><code>serialVersionUID</code> слід змінювати при внесенні в клас <strong>несумісних змін</strong>, наприклад, при видаленні будь-якого його атрибута.</p>","topicName":"Core-1"},{"id":169,"questionText":"В чому проблема серіалізації Singleton?","answer":"<p>\n    Проблема полягає в тому, що після десеріалізації ми отримаємо інший об'єкт.\n    Таким чином, серіалізація надає можливість створити Singleton ще раз,\n    що неприпустимо.\n  </p>\n\n  <p>Існують два способи уникнути цього:</p>\n\n  <ul>\n    <li>явне заборонення серіалізації;</li>\n    <li>\n      визначення методу з сигнатурою\n      <code>(default|public|private|protected) Object readResolve() throws ObjectStreamException</code>,\n      призначенням якого стане повернення заміщаючого об'єкта замість об'єкта,\n      на якому він викликаний.\n    </li>\n  </ul>","topicName":"Core-1"},{"id":170,"questionText":"Як виключити поля з серіалізації?","answer":"<p>\n    Для управління серіалізацією при визначенні полів можна використовувати\n    ключове слово <code>transient</code>, таким чином виключивши поля з загального процесу серіалізації.\n  </p>","topicName":"Core-1"},{"id":171,"questionText":"Що означає ключове слово transient?","answer":"<p>\n  Поля класу, позначені модифікатором <code>transient</code>, не серіалізуються.\n  Зазвичай в таких полях зберігається проміжний стан об'єкта, який, наприклад,\n  простіше обчислити. Інший приклад такого поля – посилання на екземпляр об'єкта,\n  який не вимагає серіалізації або не може бути серіалізований.\n</p>","topicName":"Core-1"},{"id":172,"questionText":"Який вплив мають на серіалізованість модифікатори полів <code>static</code> і <code>final</code>?","answer":"<p>\n  При стандартній серіалізації поля з модифікатором <code>static</code> не серіалізуються.\n  Відповідно, після десеріалізації це поле не змінює значення. При використанні\n  реалізації <code>Externalizable</code> можна серіалізувати та десеріалізувати статичне поле,\n  але цього не рекомендується робити, оскільки це може супроводжуватися\n  важкозауважуваними помилками.\n</p>\n\n<p>\n  Поля з модифікатором <code>final</code> серіалізуються, як і звичайні. З одним винятком –\n  їх неможливо десеріалізувати при використанні <code>Externalizable</code>, оскільки\n  final-поля повинні бути ініціалізовані в конструкторі, а після цього в\n  <code>readExternal()</code> змінити значення цього поля буде неможливо. Відповідно,\n  якщо необхідно серіалізувати об'єкт з final-полем, слід використовувати лише\n  стандартну серіалізацію.\n</p>","topicName":"Core-1"},{"id":173,"questionText":"Як не допустити серіалізацію?","answer":"<p>\n  Щоб не допустити автоматичну серіалізацію, можна перевизначити приватні методи\n  для створення виняткової ситуації <code>NotSerializableException</code>.\n</p>\n\n<pre><code>\nprivate void writeObject(ObjectOutputStream out) throws IOException {\n    throw new NotSerializableException();\n}\n\nprivate void readObject(ObjectInputStream in) throws IOException {\n    throw new NotSerializableException();\n}\n</code></pre>\n\n<p>\n  Люба спроба записати або прочитати цей об'єкт тепер призведе до виникнення\n  виняткової ситуації.\n</p>","topicName":"Core-1"},{"id":174,"questionText":"Які існують способи контролю за значеннями десеріалізованого об'єкта?","answer":"<p>\n  Якщо є потреба в контролі за значеннями десеріалізованого об'єкта, можна\n  використовувати інтерфейс <code>ObjectInputValidation</code> з перевизначенням методу\n  <code>validateObject()</code>.\n</p>\n\n<p>\n  Якщо викликати метод <code>validateObject()</code> після десеріалізації об'єкта,\n  відбудеться виклик виняткової ситуації <code>InvalidObjectException</code> при значенні\n  віку за межами 39...60.\n</p>\n\n<pre><code>\npublic class Person implements java.io.Serializable, java.io.ObjectInputValidation {\n    @Override\n    public void validateObject() throws InvalidObjectException {\n        if ((age < 39) || (age > 60))\n            throw new InvalidObjectException(\"Invalid age\");\n    }\n}\n</code></pre>\n\n<p>\n  Також існують способи підпису та шифрування, які дозволяють переконатися, що\n  дані не були змінені:\n</p>\n\n<ul>\n  <li>за допомогою опису логіки в методах <code>writeObject()</code> і <code>readObject()</code>;</li>\n  <li>\n    помістити в обгортковий клас <code>javax.crypto.SealedObject</code> і/або\n    <code>java.security.SignedObject</code>. Ці класи є серіалізованими, тому при обгортанні\n    об'єкта в <code>SealedObject</code> створюється аналог \"подарункової упаковки\" навколо\n    вихідного об'єкта. Для шифрування необхідно створити симетричний ключ,\n    управління яким повинно здійснюватися окремо. Аналогічно для перевірки даних можна\n    використовувати клас <code>SignedObject</code>, для роботи з яким також потрібен\n    симетричний ключ, що керується окремо.\n  </li>\n</ul>","topicName":"Core-1"},{"id":175,"questionText":"Розкажіть про клонування об'єктів","answer":"<p>\n  Використання оператора присвоювання лише копіює посилання на об'єкт, а не створює\n  новий об'єкт. Тобто, дві змінні будуть вказувати на один і той же об'єкт у пам'яті.\n  Щоб створити новий об'єкт із таким самим станом, використовується клонування.\n</p>\n\n<h3>Механізм клонування через метод <code>clone()</code></h3>\n\n<p>\n  Клас <code>Object</code> містить захищений метод <code>clone()</code>, який виконує побітове копіювання об'єкта.\n  Щоб його використовувати:\n</p>\n\n<ol>\n  <li>Перевизначте метод <code>clone()</code> як <code>public</code>, щоб його можна було викликати.</li>\n  <li>У перевизначеному методі викликайте <code>super.clone()</code> для фактичного клонування.</li>\n  <li>Клас повинен реалізовувати інтерфейс <code>Cloneable</code>. Це маркерний інтерфейс без методів, який дозволяє <code>clone()</code> повертати точну копію об'єкта.</li>\n</ol>\n\n<p>\n  Якщо клас не реалізує <code>Cloneable</code>, метод <code>clone()</code> згенерує виняток <code>CloneNotSupportedException</code>.\n  Варто зауважити, що при використанні цього механізму конструктор не викликається.\n</p>\n\n<h3>Обмеження та рекомендації</h3>\n\n<p>\n  Механізм ефективний, якщо поля об'єкта є базовими типами, їх обгортками або незмінюваними (immutable) об'єктами.\n  Якщо поле є змінним посилальним типом, його теж потрібно клонувати, інакше копія та оригінал будуть посилатися на один і той же об'єкт.\n</p>\n\n<p>\n  Для коректного клонування змінних об'єктних полів:\n</p>\n\n<ul>\n  <li>Тип поля повинен реалізовувати <code>Cloneable</code> та перевизначати <code>clone()</code>.</li>\n  <li>Якщо клас має суперклас, механізм клонування підкласу повинен підтримувати клонування в суперкласі.</li>\n  <li>Не використовуйте <code>final</code> для об'єктних полів, які потрібно клонувати.</li>\n</ul>\n\n<h3>Альтернативні способи клонування</h3>\n\n<ul>\n  <li>\n    <strong>Конструктор копіювання:</strong> описується конструктор, який приймає об'єкт цього ж класу\n    та ініціалізує новий об'єкт значеннями полів переданого.\n  </li>\n  <li>\n    <strong>Фабричний метод (factory method):</strong> статичний метод, який повертає новий екземпляр класу.\n  </li>\n  <li>\n    <strong>Серіалізація:</strong> збереження та відновлення об'єкта через потік байтів для створення його копії.\n  </li>\n</ul>","topicName":"Core-1"},{"id":176,"questionText":"В чому відмінність між поверхневим і глибоким клонуванням?","answer":"<h3>Поверхневе клонування</h3>\n<p>\n  Поверхневе клонування копіює лише базову інформацію про об'єкт. За замовчуванням\n  клонування в Java є поверхневим, тобто клас <code>Object</code> не знає про структуру\n  класу, який він копіює. Правила поверхневого клонування:\n</p>\n\n<ul>\n  <li>\n    Якщо клас містить лише члени примітивних типів, створюється абсолютно новий об'єкт,\n    і повертається посилання на нього.\n  </li>\n  <li>\n    Якщо клас має члени посилальних типів, копіюються лише посилання на ці об'єкти.\n    В результаті обидва об'єкти будуть містити однакові посилання.\n  </li>\n</ul>\n\n<h3>Глибоке клонування</h3>\n<p>\n  Глибоке клонування створює повну копію об'єкта разом зі всіма його полями та об'єктами, на які посилаються його члени.\n</p>\n\n<ul>\n  <li>Примітивні поля копіюються автоматично.</li>\n  <li>Члени посилального типу повинні підтримувати клонування. Для кожного такого члена\n      при перевизначенні методу <code>clone()</code> слід викликати <code>super.clone()</code>.</li>\n  <li>Якщо який-небудь член класу не підтримує клонування, слід створити новий екземпляр\n      цього класу та скопіювати кожне його поле вручну в новий об'єкт.</li>\n</ul>","topicName":"Core-1"},{"id":177,"questionText":"Який спосіб клонування бажаніший?","answer":"<p>\n  Найбільш безпечним і бажаним методом клонування є використання\n  спеціалізованого конструктора копіювання. Його переваги:\n</p>\n\n<ul>\n  <li>\n    <strong>Відсутність помилок при спадкуванні:</strong> не потрібно турбуватися,\n    що у підкласів з'являться нові поля, які не будуть клоновані через метод <code>clone()</code>.\n  </li>\n  <li>\n    <strong>Явне вказання полів для клонування:</strong> ви точно знаєте, які поля копіюються.\n  </li>\n  <li>\n    <strong>Можливість клонувати <code>final</code>-поля:</strong> конструктор копіювання дозволяє\n    ініціалізувати навіть ті поля, які не можна змінювати через <code>clone()</code>.\n  </li>\n</ul>","topicName":"Core-1"},{"id":178,"questionText":"Чому метод <code>clone()</code> оголошений у класі Object, а не в інтерфейсі Cloneable?","answer":"<p>\n  Метод <code>clone()</code> знаходиться в класі <code>Object</code> з модифікатором <code>native</code>,\n  щоб забезпечити доступ до стандартного механізму поверхневого копіювання об'єктів.\n</p>\n\n<p>\n  Одночасно він оголошений як <code>protected</code>, щоб його не можна було викликати\n  у об'єктів, які не перевизначили цей метод.\n</p>\n\n<p>\n  Інтерфейс <code>Cloneable</code> є маркерним і не містить методів. Його наявність лише позначає,\n  що об'єкт готовий до клонування. Виклик <code>clone()</code> у об'єкта, який не реалізує\n  <code>Cloneable</code>, призведе до виникнення винятку <code>CloneNotSupportedException</code>.\n</p>","topicName":"Core-1"},{"id":179,"questionText":"Як створити глибоку копію об'єкта (2 способи)?","answer":"<h3>Правила глибокого клонування</h3>\n<ul>\n  <li>Примітивні дані копіюються автоматично, додаткових дій не потрібно.</li>\n  <li>\n    Всі поля об'єктного типу повинні підтримувати клонування. Для кожного такого поля\n    при перевизначенні методу <code>clone()</code> слід викликати <code>super.clone()</code>.\n  </li>\n  <li>\n    Якщо поле не підтримує клонування, створіть новий екземпляр цього класу\n    і скопіюйте всі його атрибути по одному в новий об'єкт.\n  </li>\n</ul>\n\n<h3>Спосіб 1: Серіалізація</h3>\n<p>\n  Серіалізація є ще одним способом глибокого копіювання. Для цього об'єкт повинен\n  реалізовувати інтерфейс <code>Serializable</code>. Об'єкт зберігається у масив байт,\n  а потім відновлюється через десеріалізацію, створюючи повну копію.\n</p>\n\n<h3>Спосіб 2: Рефлексія (Reflection)</h3>\n<p>\n  Reflection – це механізм отримання інформації про програму під час виконання.\n  Java Reflection API (класи пакетів <code>java.lang</code> і <code>java.lang.reflect</code>) дозволяє:\n</p>\n<ul>\n  <li>визначити клас об'єкта;</li>\n  <li>отримати інформацію про модифікатори класу, полів, методів, конструкторів і суперкласів;</li>\n  <li>визначити інтерфейси, які реалізує клас;</li>\n  <li>створювати екземпляри класу;</li>\n  <li>отримувати та встановлювати значення полів об'єкта;</li>\n  <li>викликати методи об'єкта;</li>\n  <li>створювати новий масив.</li>\n</ul>\n\n<h3>Клас Optional</h3>\n<p>\n  <code>Optional</code> – це контейнер для об'єкта, який може містити або не містити\n  значення <code>null</code>. Цей механізм допомагає уникати <code>NullPointerException</code>\n  та дозволяє використовувати функції вищого порядку без постійних перевірок <code>if null</code>.\n</p>","topicName":"Core-1"},{"id":180,"questionText":"Що таке Generics?","answer":"<p>\n  <strong>Generics</strong> – це особливість мови програмування Java, яка дозволяє\n  створювати узагальнені типи та методи з параметризованими типами. Вони відрізняються\n  від звичайних тим, що дозволяють працювати з різними типами даних, зберігаючи\n  типобезпеку на етапі компіляції.\n</p>\n\n<h3>Приклад використання</h3>\n<p>\n  У Java Collection Framework багато класів використовують Generics. Наприклад,\n  клас <code>LinkedList&lt;E&gt;</code> є узагальненим типом, де параметр <code>E</code>\n  представляє тип елементів, які будуть зберігатися в списку.\n</p>\n\n<p>\n  Створення об'єктів узагальнених типів відбувається шляхом заміни параметра\n  конкретним типом даних:\n</p>\n\n<ul>\n  <li><code>LinkedList&lt;String&gt;</code> – список рядків;</li>\n  <li><code>LinkedList&lt;Integer&gt;</code> – список цілих чисел;</li>\n  <li>і так далі для інших типів.</li>\n</ul>\n\n<p>\n  Це дозволяє уникати небезпечних приведень типів і забезпечує контроль типів\n  вже на етапі компіляції.\n</p>","topicName":"Core-2"},{"id":181,"questionText":"Що таке raw type (сирі типи)?","answer":"<p>\n  <strong>Raw type</strong> – це використання узагальненого класу або інтерфейсу\n  без зазначення параметра типу. Іншими словами, це ім'я класу або інтерфейсу\n  без конкретизації типу даних.\n</p>\n\n<h3>Приклади</h3>\n<ul>\n  <li>\n    <code>List list = new ArrayList();</code> – сирий тип (raw type), параметр типу не вказано.\n  </li>\n  <li>\n    <code>List&lt;Integer&gt; listIntegers = new ArrayList&lt;&gt;();</code> – параметризований тип,\n    де явно вказано тип елементів.\n  </li>\n</ul>\n\n<p>\n  Використання сирих типів не рекомендується, оскільки це призводить до втрати\n  контролю типів і може спричинити помилки під час виконання програми.\n</p>","topicName":"Core-2"},{"id":182,"questionText":"Що таке стирання типів?","answer":"<p>\n  <strong>Стирання типів (Type Erasure)</strong> – це процес, за яким інформація\n  про параметри узагальнених типів не зберігається у класі під час виконання програми.\n</p>\n\n<p>\n  Іншими словами, тип-параметр доступний лише на етапі компіляції для забезпечення\n  типобезпеки, а під час виконання ця інформація стирається і стає недоступною.\n</p>","topicName":"Core-2"},{"id":183,"questionText":"В чому полягає різниця між IO та NIO?","answer":"<p>\n  <strong>Java IO</strong> (Input-Output) орієнтована на потік (stream-oriented), а\n  <strong>Java NIO</strong> (New/Non-blocking IO) – на буфер (buffer-oriented). Різниця полягає в підході до обробки даних.\n</p>\n\n<h3>Java IO (потокове введення/виведення)</h3>\n<ul>\n  <li>Дані читаються або записуються послідовно, по одному або кількох байтів за раз.</li>\n  <li>Інформація не кешується, тому неможливо переміщатися по потоку вперед або назад.</li>\n  <li>Потоки блокуючі: виклик <code>read()</code> або <code>write()</code> зупиняє потік виконання до завершення операції.</li>\n</ul>\n\n<h3>Java NIO (буферне та неблокуюче введення/виведення)</h3>\n<ul>\n  <li>Дані спочатку читаються у буфер, що дозволяє гнучкіше обробляти їх.</li>\n  <li>Потоки неблокуючі: потік може запитати дані з каналу або записати їх, не чекаючи завершення операції.</li>\n  <li>Існують селектори, які дозволяють одному потоку моніторити кілька каналів одночасно:\n    <ul>\n      <li>Можна зареєструвати декілька каналів у селекторі.</li>\n      <li>Потік обробляє лише ті канали, де є доступні дані або можливість запису.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>\n  Таким чином, NIO дозволяє ефективніше використовувати ресурси та обслуговувати багато каналів одним потоком, тоді як IO орієнтована на просту послідовну обробку потоків.\n</p>","topicName":"Core-2"},{"id":184,"questionText":"Які класи підтримують читання та запис потоків у\nстиснутому форматі?","answer":"<p>У Java існують класи, що підтримують стиск та розпаковку даних у різних форматах:</p>\n\n<ul>\n  <li><strong>DeflaterOutputStream</strong> – стиск даних у форматі <code>deflate</code>;</li>\n  <li><strong>Deflater</strong> – стиск даних у форматі <code>ZLIB</code>;</li>\n  <li><strong>ZipOutputStream</strong> – нащадок <code>DeflaterOutputStream</code> для стискання у форматі <code>Zip</code>;</li>\n  <li><strong>GZIPOutputStream</strong> – нащадок <code>DeflaterOutputStream</code> для стискання у форматі <code>GZIP</code>;</li>\n  <li><strong>InflaterInputStream</strong> – декомпресія даних у форматі <code>deflate</code>;</li>\n  <li><strong>Inflater</strong> – декомпресія даних у форматі <code>ZLIB</code>;</li>\n  <li><strong>ZipInputStream</strong> – нащадок <code>InflaterInputStream</code> для декомпресії у форматі <code>Zip</code>;</li>\n  <li><strong>GZIPInputStream</strong> – нащадок <code>InflaterInputStream</code> для декомпресії у форматі <code>GZIP</code>.</li>\n</ul>","topicName":"Core-2"},{"id":185,"questionText":"Що таке \"канали\"?","answer":"<p>\n  <strong>Канали (channels)</strong> – це логічні (не фізичні) портали, які\n  виступають абстракцією об'єктів низького рівня файлової системи, наприклад\n  відображених у пам'яті файлів або блокувань файлів. Через канали здійснюється\n  введення та виведення даних.\n</p>\n\n<p>\n  <strong>Буфери</strong> є джерелами або приймачами даних, що передаються через канали.\n  При організації виводу дані спочатку поміщаються у буфер, який потім передається в канал.\n  При вводі дані з каналу потрапляють у заздалегідь підготовлений буфер.\n</p>\n\n<p>\n  Канали можна уявити як трубопроводи для ефективної передачі даних між буферами\n  та зовнішніми об’єктами. Вони слугують шлюзами для доступу до служб введення/виведення\n  операційної системи з мінімальними накладними витратами, тоді як буфери – це внутрішні\n  кінцеві точки цих шлюзів, які забезпечують передачу та отримання даних.\n</p>","topicName":"Core-2"},{"id":186,"questionText":"Назвіть основні класи потоків введення/виведення?","answer":"<p>В Java існують два види потоків введення/виведення:</p>\n\n<ul>\n  <li><strong>Байтові потоки:</strong> <code>java.io.InputStream</code>, <code>java.io.OutputStream</code> – для роботи з даними у вигляді байтів;</li>\n  <li><strong>Символьні потоки:</strong> <code>java.io.Reader</code>, <code>java.io.Writer</code> – для роботи з текстовими даними.</li>\n</ul>","topicName":"Core-2"},{"id":187,"questionText":"В яких пакетах розташовані класи потоків\nвведення/виведення?","answer":"<p>Класи потоків введення/виведення в Java знаходяться у наступних пакетах:</p>\n\n<ul>\n  <li><code>java.io</code> – стандартні потоки для роботи з файлами та даними;</li>\n  <li><code>java.nio</code> – канали та буфери для неблокуючого введення/виведення;</li>\n  <li><code>java.util.zip</code> – класи для роботи з потоками стиснутих даних.</li>\n</ul>","topicName":"Core-2"},{"id":188,"questionText":"Які підкласи класу <code>InputStream</code> ви знаєте і на що вони\nпризначені?","answer":"<ul>\n  <li><strong>InputStream</strong> – абстрактний клас, який описує потік введення;</li>\n  <li><strong>BufferedInputStream</strong> – буферизований вхідний потік для підвищення ефективності читання;</li>\n  <li><strong>ByteArrayInputStream</strong> – використовує масив байтів у пам'яті як джерело даних для потоку;</li>\n  <li><strong>DataInputStream</strong> – вхідний потік для байтових даних з методами для читання стандартних типів Java;</li>\n  <li><strong>FileInputStream</strong> – вхідний потік для читання даних з файлу;</li>\n  <li><strong>FilterInputStream</strong> – абстрактний клас для потоків-набудов, які додають корисні властивості існуючим потокам;</li>\n  <li><strong>ObjectInputStream</strong> – потік для читання об'єктів;</li>\n  <li><strong>StringBufferInputStream</strong> – перетворює рядок (<code>String</code>) у вхідний потік даних;</li>\n  <li><strong>PipedInputStream</strong> – реалізує поняття вхідного каналу;</li>\n  <li><strong>PrintStream</strong> – вихідний потік з методами <code>print()</code> та <code>println()</code>;</li>\n  <li><strong>PushbackInputStream</strong> – буферизація, яка дозволяє \"повернути\" байт назад у потік для подальшого читання;</li>\n  <li><strong>SequenceInputStream</strong> – використовується для злиття двох або більше потоків <code>InputStream</code> в один.</li>\n</ul>","topicName":"Core-2"},{"id":189,"questionText":"Для чого використовується <code>PushbackInputStream</code>?","answer":"<p>\n  <code>PushbackInputStream</code> – це вид буферизації, який дозволяє читати байт з потоку\n  з можливістю повернути його назад у потік. Такий механізм дозволяє \"заглянути\" у\n  вхідний потік і передбачити, які дані надійдуть наступними, не вилучаючи їх.\n</p>\n\n<p>\n  Для цього клас надає додатковий метод <code>unread()</code>, який повертає байт назад\n  у потік для повторного читання.\n</p>","topicName":"Core-2"},{"id":190,"questionText":"Для чого використовується SequenceInputStream?","answer":"<p>\n    Клас <strong>SequenceInputStream</strong> дозволяє об'єднувати декілька екземплярів класу\n    <code>InputStream</code>.\n</p>\n<p>\n    Конструктор приймає в якості аргумента або пару об'єктів класу\n    <code>InputStream</code>, або інтерфейс <code>Enumeration</code>.\n</p>\n<p>\n    Під час роботи клас виконує запити на читання з першого об'єкта класу\n    <code>InputStream</code> і до кінця, а потім перемикається на другий. При використанні\n    інтерфейса робота продовжиться для всіх об'єктів класу <code>InputStream</code>.\n</p>\n<p>\n    При досягненні кінця пов'язаний з ним потік закривається. Закриття потоку, створеного\n    об'єктом класу <code>SequenceInputStream</code>, призводить до закриття всіх відкритих потоків.\n</p>","topicName":"Core-2"},{"id":191,"questionText":"Який клас дозволяє читати дані з вхідного байтового потоку у форматі примітивних типів даних?","answer":"<p>\n    Клас <strong>DataInputStream</strong> представляє потік введення і призначений для читання даних\n    примітивних типів, таких як <code>int</code>, <code>double</code> та інші.\n</p>\n<p>\n    Для кожного примітивного типу визначений свій метод для зчитування:\n</p>\n<ul>\n    <li><code>boolean readBoolean()</code> — зчитує з потоку булеве однобайтове значення;</li>\n    <li><code>byte readByte()</code> — зчитує з потоку 1 байт;</li>\n    <li><code>char readChar()</code> — зчитує з потоку значення <code>char</code>;</li>\n    <li><code>double readDouble()</code> — зчитує з потоку 8-байтове значення <code>double</code>;</li>\n    <li><code>float readFloat()</code> — зчитує з потоку 4-байтове значення <code>float</code>;</li>\n    <li><code>int readInt()</code> — зчитує з потоку ціле значення <code>int</code>;</li>\n    <li><code>long readLong()</code> — зчитує з потоку значення <code>long</code>;</li>\n    <li><code>short readShort()</code> — зчитує з потоку значення <code>short</code>;</li>\n    <li><code>String readUTF()</code> — зчитує з потоку рядок у кодуванні UTF-8.</li>\n</ul>","topicName":"Core-2"},{"id":192,"questionText":"Класи-нащадки класу OutputStream, які ви знаєте, і для чого вони призначені?","answer":"<h2>Класи-нащадки класу OutputStream та їх призначення</h2>\n<ul>\n    <li><strong>OutputStream</strong> — абстрактний клас, який визначає байтовий вихідний потік.</li>\n    <li><strong>BufferedOutputStream</strong> — буферизований вихідний потік.</li>\n    <li><strong>ByteArrayOutputStream</strong> — усі дані, відправлені у цей потік, зберігаються у заздалегідь створеному буфері.</li>\n    <li><strong>DataOutputStream</strong> — вихідний потік байт з методами для запису стандартних типів даних Java.</li>\n    <li><strong>FileOutputStream</strong> — запис даних у файл на фізичному носії.</li>\n    <li><strong>FilterOutputStream</strong> — абстрактний клас, що надає інтерфейс для класів-надбудов.</li>\n    <li><strong>ObjectOutputStream</strong> — вихідний потік для запису об'єктів.</li>\n    <li><strong>PipedOutputStream</strong> — реалізує поняття вихідного каналу.</li>\n</ul>","topicName":"Core-2"},{"id":193,"questionText":"Класи-нащадки класу Reader, які ви знаєте, і для чого вони призначені?","answer":"<h2>Класи-нащадки класу Reader та їх призначення</h2>\n<ul>\n    <li><strong>Reader</strong> — абстрактний клас, який описує символьний ввід.</li>\n    <li><strong>BufferedReader</strong> — буферизований вхідний символьний потік.</li>\n    <li><strong>CharArrayReader</strong> — вхідний потік, що читає з символьного масиву.</li>\n    <li><strong>FileReader</strong> — вхідний потік для читання з файлу.</li>\n    <li><strong>FilterReader</strong> — абстрактний клас, який надає інтерфейс для класів-надбудов.</li>\n    <li><strong>InputStreamReader</strong> — вхідний потік, який перетворює байти у символи.</li>\n    <li><strong>LineNumberReader</strong> — вхідний потік, що підраховує кількість рядків.</li>\n    <li><strong>PipedReader</strong> — реалізує вхідний канал.</li>\n    <li><strong>PushbackReader</strong> — вхідний потік, який дозволяє повертати символи назад у потік.</li>\n    <li><strong>StringReader</strong> — вхідний потік, що читає дані з рядка.</li>\n</ul>","topicName":"Core-2"},{"id":194,"questionText":"Класи-нащадки класу Writer, які ви знаєте, і для чого вони призначені?","answer":"<h2>Класи-нащадки класу Writer та їх призначення</h2>\n<ul>\n    <li><strong>Writer</strong> — абстрактний клас, який описує символьний вивід.</li>\n    <li><strong>BufferedWriter</strong> — буферизований вихідний символьний потік.</li>\n    <li><strong>CharArrayWriter</strong> — вихідний потік, що записує в символьний масив.</li>\n    <li><strong>FileWriter</strong> — вихідний потік для запису у файл.</li>\n    <li><strong>FilterWriter</strong> — абстрактний клас, який надає інтерфейс для класів-надбудов.</li>\n    <li><strong>OutputStreamWriter</strong> — вихідний потік, який перетворює байти у символи.</li>\n    <li><strong>PipedWriter</strong> — реалізує вихідний канал.</li>\n    <li><strong>PrintWriter</strong> — вихідний потік символів з методами <code>print()</code> та <code>println()</code>.</li>\n    <li><strong>StringWriter</strong> — вихідний потік, що записує дані у рядок.</li>\n</ul>","topicName":"Core-2"},{"id":195,"questionText":"У чому відмінність класу PrintWriter від PrintStream?","answer":"<h2>Відмінність між класами PrintWriter та PrintStream</h2>\n<ul>\n    <li><strong>PrintWriter</strong> — підтримує покращену роботу з символами Unicode та має інший механізм буферизації.</li>\n    <li><strong>PrintStream</strong> — виводить буфер кожного разу при виклику <code>print()</code> або <code>println()</code>.</li>\n    <li>У <strong>PrintWriter</strong> є можливість відмовитися від автоматичного скидання буфера та робити це вручну за допомогою <code>flush()</code>.</li>\n    <li>Методи <strong>PrintWriter</strong> ніколи не генерують винятків — для перевірки помилок потрібно викликати <code>checkError()</code>.</li>\n</ul>","topicName":"Core-2"},{"id":196,"questionText":"Чим відрізняються і що спільного у InputStream, OutputStream, Reader, Writer?","answer":"<h2>Відмінності та спільні риси InputStream, OutputStream, Reader, Writer</h2>\n<ul>\n    <li><strong>InputStream</strong> та його нащадки — набір класів для отримання <em>байтових</em> даних з різних джерел.</li>\n    <li><strong>OutputStream</strong> та його нащадки — набір класів для потокового <em>байтового</em> виводу.</li>\n    <li><strong>Reader</strong> та його нащадки — визначають потоковий ввід символів <em>Unicode</em>.</li>\n    <li><strong>Writer</strong> та його нащадки — визначають потоковий вивід символів <em>Unicode</em>.</li>\n</ul>","topicName":"Core-2"},{"id":197,"questionText":"Які класи дозволяють перетворювати байтові потоки в символьні та навпаки?","answer":"<ul>\n    <li><strong>OutputStreamWriter</strong> — \"міст\" між класом <em>OutputStream</em> і класом <em>Writer</em>, символи, записані в потік, перетворюються в байти.</li>\n    <li><strong>InputStreamReader</strong> — аналог для читання: за допомогою методів класу <em>Reader</em> читаються байти з потоку <em>InputStream</em> і перетворюються в символи.</li>\n</ul>","topicName":"Core-2"},{"id":198,"questionText":"Які класи дозволяють прискорити читання/запис за рахунок використання буфера?","answer":"<ul>\n    <li><strong>BufferedInputStream</strong>(InputStream in) / <strong>BufferedInputStream</strong>(InputStream in, int size)</li>\n    <li><strong>BufferedOutputStream</strong>(OutputStream out) / <strong>BufferedOutputStream</strong>(OutputStream out, int size)</li>\n    <li><strong>BufferedReader</strong>(Reader r) / <strong>BufferedReader</strong>(Reader in, int sz)</li>\n    <li><strong>BufferedWriter</strong>(Writer out) / <strong>BufferedWriter</strong>(Writer out, int sz)</li>\n</ul>","topicName":"Core-2"},{"id":199,"questionText":"Існує можливість перенаправлення потоків стандартного вводу/виводу?","answer":"<p>Клас <strong>System</strong> дозволяє перенаправляти стандартний ввід, вивід і потік виведення помилок за допомогою статичних методів:</p>\n<ul>\n    <li><strong>setIn(InputStream)</strong> – для вводу</li>\n    <li><strong>setOut(PrintStream)</strong> – для виводу</li>\n    <li><strong>setErr(PrintStream)</strong> – для виводу помилок</li>\n</ul>","topicName":"Core-2"},{"id":200,"questionText":"Який клас призначений для роботи з елементами файлової системи?","answer":"<p>Клас <strong>File</strong> працює безпосередньо з файлами та каталогами. Він дозволяє створювати нові елементи та отримувати інформацію про існуючі, таку як:</p>\n<ul>\n    <li>розмір</li>\n    <li>права доступу</li>\n    <li>час та дата створення</li>\n    <li>шлях до батьківського каталогу</li>\n</ul>","topicName":"Core-2"},{"id":201,"questionText":"Які методи класу File ви знаєте?","answer":"<p>Найбільш використовувані методи класу <strong>File</strong>:</p>\n<ul>\n    <li><strong>boolean createNewFile()</strong>: намагається створити новий файл;</li>\n    <li><strong>boolean delete()</strong>: намагається видалити каталог або файл;</li>\n    <li><strong>boolean mkdir()</strong>: намагається створити новий каталог;</li>\n    <li><strong>boolean renameTo(File dest)</strong>: намагається перейменувати файл або каталог;</li>\n    <li><strong>boolean exists()</strong>: перевіряє, чи існує файл або каталог;</li>\n    <li><strong>String getAbsolutePath()</strong>: повертає абсолютний шлях для шляху, переданого в конструктор об'єкта;</li>\n    <li><strong>String getName()</strong>: повертає коротке ім'я файлу або каталогу;</li>\n    <li><strong>String getParent()</strong>: повертає ім'я батьківського каталогу;</li>\n    <li><strong>boolean isDirectory()</strong>: повертає true, якщо за вказаним шляхом розташований каталог;</li>\n    <li><strong>boolean isFile()</strong>: повертає true, якщо за вказаним шляхом знаходиться файл;</li>\n    <li><strong>boolean isHidden()</strong>: повертає true, якщо каталог або файл є прихованими;</li>\n    <li><strong>long length()</strong>: повертає розмір файлу в байтах;</li>\n    <li><strong>long lastModified()</strong>: повертає час останньої зміни файлу або каталогу;</li>\n    <li><strong>String[] list()</strong>: повертає масив файлів і підкаталогів у певному каталозі;</li>\n    <li><strong>File[] listFiles()</strong>: повертає масив файлів і підкаталогів у певному каталозі.</li>\n</ul>","topicName":"Core-2"},{"id":202,"questionText":"Що ви знаєте про інтерфейс FileFilter?","answer":"<p>Інтерфейс <strong>FileFilter</strong> використовується для перевірки, чи об'єкт <strong>File</strong> відповідає певній умові. Інтерфейс містить єдиний метод:</p>\n<pre><code>boolean accept(File pathName)</code></pre>\n<p>Цей метод необхідно перевизначити та реалізувати. Наприклад:</p>\n<pre><code>public boolean accept(final File file) {\n    return file.exists() &amp;&amp; file.isDirectory();\n}</code></pre>","topicName":"Core-2"},{"id":203,"questionText":"Як вибрати всі елементи певного каталогу за певним критерієм?","answer":"<p>Метод <strong>File.listFiles()</strong> повертає масив об'єктів <strong>File</strong>, що містяться в каталозі. Метод може приймати об'єкт класу, який реалізує <strong>FileFilter</strong>. Це дозволяє включити до списку лише ті елементи, для яких метод <code>accept</code> повертає <code>true</code>. Критерієм може бути, наприклад, довжина імені файлу або його розширення.</p>","topicName":"Core-2"},{"id":204,"questionText":"Що ви знаєте про RandomAccessFile?","answer":"<p>Клас <strong>java.io.RandomAccessFile</strong> забезпечує читання і запис даних у довільному місці файлу. Він не є частиною ієрархії <code>InputStream</code> або <code>OutputStream</code> і працює як самостійний клас зі своїми власними методами.</p>\n\n<p>RandomAccessFile дозволяє переміщатися вперед і назад у межах файлу і має специфічні методи:</p>\n<ul>\n  <li><code>getFilePointer()</code> – визначення поточного місця в файлі;</li>\n  <li><code>seek()</code> – переміщення на нову позицію в файлі;</li>\n  <li><code>length()</code> – визначення розміру файлу;</li>\n  <li><code>setLength()</code> – встановлення розміру файлу;</li>\n  <li><code>skipBytes()</code> – пропуск певної кількості байтів;</li>\n  <li><code>getChannel()</code> – робота з унікальним файловим каналом, пов'язаним із файлом;</li>\n  <li>Методи для читання: <code>read()</code>, <code>readInt()</code>, <code>readLine()</code>, <code>readUTF()</code> і т. п.;</li>\n  <li>Методи для запису: <code>write()</code>, <code>writeBoolean()</code>, <code>writeByte()</code> і т. п.</li>\n</ul>\n\n<p>Конструктори <strong>RandomAccessFile</strong> вимагають другий аргумент, який вказує режим доступу до файлу: тільки читання (\"r\"), читання і запис (\"rw\") або інший відповідний режим.</p>","topicName":"Core-2"},{"id":205,"questionText":"Які режими доступу є у RandomAccessFile?","answer":"<ul>\n  <li><strong>\"r\"</strong> – відкриває файл лише для читання. Виклик будь-яких методів запису даних призведе до викидання винятку IOException.</li>\n  <li><strong>\"rw\"</strong> – відкриває файл для читання і запису. Якщо файл ще не створений, здійснюється спроба його створити.</li>\n  <li><strong>\"rws\"</strong> – відкриває файл для читання і запису подібно до \"rw\", але вимагає від системи синхронно записувати зміни вмісту файлу та метаданих на фізичний носій.</li>\n  <li><strong>\"rwd\"</strong> – відкриває файл для читання і запису подібно до \"rws\", але синхронно записуються лише зміни вмісту файлу; зміни метаданих синхронно не записуються.</li>\n</ul>","topicName":"Core-2"},{"id":206,"questionText":"Який символ є роздільником при вказівці шляху в файловій системі?","answer":"<p>Для різних операційних систем символ роздільника відрізняється:</p>\n<ul>\n  <li>Windows – \\</li>\n  <li>Linux – /</li>\n</ul>\n<p>У Java отримати роздільник для поточної операційної системи можна через статичне поле <strong>File.separator</strong>.</p>","topicName":"Core-2"},{"id":207,"questionText":"Що таке «абсолютний шлях» та «відносний шлях»?","answer":"<p><strong>Абсолютний (повний) шлях</strong> – це шлях, який вказує на одне й те саме місце в файловій системі незалежно від поточного робочого каталогу чи інших обставин. Абсолютний шлях завжди починається з кореневого каталогу.</p>\n<p><strong>Відносний шлях</strong> – це шлях, який визначається відносно поточного робочого каталогу користувача або активного додатка.</p>","topicName":"Core-2"},{"id":208,"questionText":"Що таке «символьна посилання»?","answer":"<p><strong>Символьна (символічна) посилання</strong> (також \"симлінк\", Symbolic link) – це спеціальний файл у файловій системі, який замість користувацьких даних містить шлях до файлу, що має бути відкритий при зверненні до цього посилання.</p>\n<p>Метою посилання може бути будь-який об'єкт: інше посилання, файл, каталог чи навіть неіснуючий файл (у цьому випадку при спробі відкриття буде повідомлення про відсутність файлу).</p>\n<p>Символьні посилання використовуються для зручнішої організації структури файлів, оскільки:</p>\n<ul>\n  <li>дозволяють для одного файла чи каталогу мати кілька імен і різних атрибутів;</li>\n  <li>вільні від обмежень, що притаманні жорстким посиланням (жорсткі посилання діють тільки в межах однієї файлової системи і не можуть посилатися на каталоги).</li>\n</ul>","topicName":"Core-2"},{"id":209,"questionText":"Що таке default-методи інтерфейсу?","answer":"<p>У Java 8 з'явилася можливість додавати реалізацію методів безпосередньо в інтерфейс, використовуючи ключове слово <code>default</code>:</p>\n<pre><code>interface Приклад {\n    int обробити(int a);\n    default void показати() {\n        System.out.println(\"За замовчуванням показати()\");\n    }\n}</code></pre>\n\n<p>Особливості default-методів:</p>\n<ul>\n  <li>Клас, який реалізує інтерфейс, може використовувати методи за замовчуванням без необхідності їх перевизначати.</li>\n  <li>Якщо клас реалізує кілька інтерфейсів з однаковим default-методом, клас повинен самостійно реалізувати цей метод.</li>\n  <li>Якщо один інтерфейс має метод за замовчуванням, а інший той самий метод є абстрактним, реалізація за замовчуванням не успадковується.</li>\n  <li>Метод за замовчуванням не може перевизначити методи класу <code>java.lang.Object</code>.</li>\n</ul>\n\n<p>Переваги default-методів:</p>\n<ul>\n  <li>Дозволяють реалізовувати інтерфейси без ризику порушити роботу вже існуючих класів.</li>\n  <li>Уникають необхідності створювати допоміжні класи, оскільки всі потрібні методи можуть бути безпосередньо в інтерфейсі.</li>\n  <li>Дає класам свободу вибору, які методи перевизначати.</li>\n  <li>Основне застосування – підтримка лямбда-виразів у колекціях Java 8.</li>\n</ul>","topicName":"Core-2"},{"id":210,"questionText":"Як викликати default-метод інтерфейсу в класі, що реалізує цей інтерфейс?","answer":"<p>Щоб викликати default-метод інтерфейсу з класу, який реалізує цей інтерфейс, використовуйте комбінацію <code>super</code> та імені інтерфейсу:</p>\n<pre><code>Paper.super.show();</code></pre>\n<p>Тут <code>Paper</code> – назва інтерфейсу, а <code>show()</code> – default-метод, який потрібно викликати.</p>","topicName":"Core-2"},{"id":211,"questionText":"Що таке static-метод інтерфейсу?","answer":"<p>Статичні методи інтерфейсу схожі на default-методи, але їх неможливо перевизначити в класах, що реалізують інтерфейс. Вони є частиною інтерфейсу та викликаються тільки через ім'я інтерфейсу, а не через об'єкт класу реалізації.</p>\n<p>Особливості static-методів інтерфейсу:</p>\n<ul>\n  <li>Не можуть бути перевизначені в класах, що реалізують інтерфейс.</li>\n  <li>Не можна зробити статичним метод класу <code>java.lang.Object</code>.</li>\n  <li>Використовуються для допоміжних функцій, наприклад, перевірки на <code>null</code>, сортування колекцій тощо.</li>\n</ul>","topicName":"Core-2"},{"id":212,"questionText":"Як викликати статичний метод інтерфейсу?","answer":"<p>Статичний метод інтерфейсу викликається через ім'я інтерфейсу, а не через об'єкт класу реалізації. Наприклад:</p>\n<pre><code>Paper.show();</code></pre>","topicName":"Core-2"},{"id":213,"questionText":"Що таке «лямбда»? Яка структура та особливості\nвикористання лямбда-виразу?","answer":"<p>Лямбда-вираз — це набір інструкцій, який можна зберегти в змінну і викликати кілька разів у різних місцях програми.</p>\n\n<p>Основою лямбда-виразу є лямбда-оператор <code>-></code>, який розділяє вираз на дві частини:</p>\n<ul>\n  <li><strong>ліва частина</strong> — список параметрів;</li>\n  <li><strong>права частина</strong> — тіло лямбда-виразу, де виконуються дії.</li>\n</ul>\n\n<p>Лямбда-вираз сам по собі не виконується, а створює реалізацію методу функціонального інтерфейсу, який повинен містити лише один абстрактний метод.</p>\n\n<p>Лямбда-вирази — це скорочена форма анонімних класів, які раніше використовувалися в Java. Вони дозволяють визначити виконання один раз і викликати його будь-яку кількість разів у будь-якому місці програми.</p>\n\n<h4>Приклади синтаксису лямбда-виразів</h4>\n<pre><code>// Типи параметрів можна вказати або опустити\noperation = (int x, int y) -> x + y;\n(x, y) -> x + y;\n\n// Якщо параметрів немає, використовують порожні дужки\n() -> 30 + 20;\n\n// Один параметр — дужки можна опустити\nn -> n * n;\n</code></pre>\n\n<h4>Блочні лямбда-вирази</h4>\n<p>Блочні вирази оточуються фігурними дужками і можуть містити цикли, умови, вкладені блоки, створення змінних. Якщо потрібно повертати значення, використовується <code>return</code>:</p>\n<pre><code>\nOperationable operation = (int x, int y) -> {\n    if (y == 0) {\n        return 0;\n    } else {\n        return x / y;\n    }\n};\n</code></pre>\n\n<h4>Передача лямбда-виразу як параметра методу</h4>\n<pre><code>\ninterface Condition {\n    boolean isAppropriate(int n);\n}\n\nprivate static int sum(int[] numbers, Condition condition) {\n    int result = 0;\n    for (int i : numbers) {\n        if (condition.isAppropriate(i)) {\n            result += i;\n        }\n    }\n    return result;\n}\n\npublic static void main(String[] args) {\n    System.out.println(sum(new int[] {0,1,0,3,0,5,0,7,0,9}, (n) -> n != 0));\n}\n</code></pre>","topicName":"Core-2"},{"id":214,"questionText":"До яких змінних має доступ лямбда-вираз?","answer":"<p>Лямбда-вираз може звертатися до змінних зовнішньої області дії, схожим чином як анонімні класи. Доступ можливий до:</p>\n<ul>\n  <li><strong>локальних змінних</strong>, які є незмінними (effective final) — не обов'язково оголошені як <code>final</code>;</li>\n  <li><strong>полів класу</strong>;</li>\n  <li><strong>статичних змінних</strong>.</li>\n</ul>\n\n<p>Звернення до методів за замовчуванням функціонального інтерфейсу всередині лямбда-виразу заборонене.</p>","topicName":"Core-2"},{"id":215,"questionText":"Як відсортувати список рядків за допомогою лямбда-виразу?","answer":"<p>Приклад сортування списку рядків за допомогою лямбда-виразу:</p>\n\n<pre><code>\npublic static List&lt;String&gt; sort(List&lt;String&gt; list) {\n    Collections.sort(list, (a, b) -&gt; a.compareTo(b));\n    return list;\n}\n</code></pre>\n\n<p>Пояснення:</p>\n<ul>\n  <li>Метод <code>Collections.sort</code> приймає список та компаратор.</li>\n  <li>Лямбда-вираз <code>(a, b) -&gt; a.compareTo(b)</code> визначає, як порівнювати рядки між собою.</li>\n  <li>Цей спосіб дозволяє швидко передати логіку порівняння без створення окремого класу-компаратора.</li>\n</ul>","topicName":"Core-2"},{"id":216,"questionText":"Що таке \"посилання на метод\"?","answer":"<p>Посилання на метод дозволяє безпосередньо передати вже існуючий метод як аргумент, замість того щоб писати лямбда-вираз, який його викликає. Це робиться за допомогою трьох основних форматів:</p>\n\n<ul>\n  <li><code>ім'я_класу::ім'я_статичного_методу</code> — для статичних методів;</li>\n  <li><code>об'єкт_класу::ім'я_методу</code> — для методів екземпляра;</li>\n  <li><code>назва_класу::new</code> — для конструктора.</li>\n</ul>\n\n<p>Приклад використання посилання на метод:</p>\n\n<pre><code>\nprivate interface Measurable {\n    int length(String string);\n}\n\npublic static void main(String[] args) {\n    Measurable a = String::length;\n    System.out.println(a.length(\"abc\")); // Виведе 3\n}\n</code></pre>\n\n<p>Переваги посилань на метод:</p>\n<ul>\n  <li>Більш ефективні, ніж лямбда-вирази.</li>\n  <li>Надають компілятору точнішу інформацію про тип.</li>\n  <li>Завжди варто віддавати перевагу посиланню на існуючий метод, якщо він вже реалізує необхідну логіку.</li>\n</ul>","topicName":"Core-2"},{"id":217,"questionText":"Які види посилань на методи ви знаєте?","answer":"<ul>\n  <li>Посилання на статичний метод;</li>\n  <li>Посилання на метод екземпляру;</li>\n  <li>Посилання на конструктор.</li>\n</ul>","topicName":"Core-2"},{"id":218,"questionText":"Поясніть вираз <code>System.out::println</code>","answer":"<p>Даний вираз ілюструє механізм посилання на метод екземпляра: він передає посилання на метод <code>println()</code> об'єкта <code>out</code> класу <code>System</code>. Це дозволяє використовувати метод без прямого виклику, наприклад, у лямбда-виразах чи колекціях для обробки елементів.</p>","topicName":"Core-2"},{"id":219,"questionText":"Що таке Stream?","answer":"<p>Інтерфейс <code>java.util.Stream</code> представляє собою послідовність елементів, над якою можна виконувати різні операції.</p>\n\n<p>Операції над стрімами бувають двох типів:</p>\n<ul>\n  <li><strong>Проміжні (intermediate)</strong> – повертають той самий стрім, що дозволяє створювати ланцюжки операцій.</li>\n  <li><strong>Кінцеві (terminal)</strong> – повертають результат певного типу та завершують роботу стріму.</li>\n</ul>\n\n<p>У стріму може бути будь-яка кількість проміжних операцій, останньою завжди є кінцева операція. Проміжні операції виконуються <em>ліниво</em>, тобто фактичні дії відбуваються лише після виклику кінцевої операції.</p>\n\n<p>Стріми створюються на основі джерел, таких як колекції з <code>java.util.Collection</code>. Асоціативні масиви (наприклад, <code>HashMap</code>) безпосередньо не підтримуються.</p>\n\n<p>Операції над стрімами можуть виконуватися послідовно або паралельно. Потоки не можна використовувати повторно: після виклику кінцевої операції стрім закривається.</p>\n\n<p>Окрім універсальних об'єктних стрімів, існують спеціалізовані стріми для примітивних типів даних:</p>\n<ul>\n  <li><code>IntStream</code> для <code>int</code></li>\n  <li><code>LongStream</code> для <code>long</code></li>\n  <li><code>DoubleStream</code> для <code>double</code></li>\n</ul>\n\n<p>Особливості примітивних стрімів:</p>\n<ul>\n  <li>Використовують спеціалізовані лямбда-вирази, наприклад, <code>IntFunction</code> або <code>IntPredicate</code> замість <code>Function</code> і <code>Predicate</code>;</li>\n  <li>Підтримують додаткові кінцеві операції: <code>sum()</code>, <code>average()</code>, <code>mapToObj()</code>.</li>\n</ul>","topicName":"Core-2"},{"id":220,"questionText":"Які існують способи створення стріму?","answer":"<ul>\n  <li><strong>З колекції:</strong> \n    <code>Stream<String> fromCollection = Arrays.asList(\"x\", \"y\", \"z\").stream();</code>\n  </li>\n  <li><strong>З набору значень:</strong> \n    <code>Stream<String> fromValues = Stream.of(\"x\", \"y\", \"z\");</code>\n  </li>\n  <li><strong>З масиву:</strong> \n    <code>Stream<String> fromArray = Arrays.stream(new String[]{\"x\", \"y\", \"z\"});</code>\n  </li>\n  <li><strong>З файлу</strong> (кожен рядок у файлі буде окремим елементом у стрімі):\n    <code>Stream<String> fromFile = Files.lines(Paths.get(\"input.txt\"));</code>\n  </li>\n  <li><strong>З рядка:</strong> \n    <code>IntStream fromString = \"0123456789\".chars();</code>\n  </li>\n  <li><strong>За допомогою Stream.builder():</strong> \n    <code>Stream<String> fromBuilder = Stream.builder().add(\"z\").add(\"y\").add(\"z\").build();</code>\n  </li>\n  <li><strong>За допомогою Stream.iterate() (безкінечний):</strong> \n    <code>Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);</code>\n  </li>\n  <li><strong>За допомогою Stream.generate() (безкінечний):</strong> \n    <code>Stream<String> fromGenerate = Stream.generate(() -> \"0\");</code>\n  </li>\n</ul>","topicName":"Core-2"},{"id":221,"questionText":"В чому різниця між Collection та Stream?","answer":"<p>Колекції дозволяють працювати з елементами окремо, тоді як стріми не надають такої можливості. Замість цього стріми дозволяють виконувати функції над даними як над цілісністю.</p>\n\n<p>Основна концептуальна відмінність:</p>\n<ul>\n  <li><strong>Collection</strong> – це передусім структура даних. Наприклад, <code>Set</code> зберігає унікальні елементи та реалізує ідею множини.</li>\n  <li><strong>Stream</strong> – це абстракція для реалізації конвеєру обчислень. Результатом роботи конвеєра можуть бути інші структури даних, результати перевірок, пошуку тощо.</li>\n</ul>","topicName":"Core-2"},{"id":222,"questionText":"Для чого потрібний метод <code>collect()</code> у стрімах?","answer":"<p>Метод <code>collect()</code> є кінцевою операцією стріму і використовується для представлення результату у вигляді колекції або іншої структури даних. Він приймає на вхід <code>Collector&lt;Тип_джерела, Тип_акумулятора, Тип_результату&gt;</code>, який містить кілька етапів:</p>\n<ul>\n  <li><strong>supplier</strong> – ініціалізація акумулятора;</li>\n  <li><strong>accumulator</strong> – обробка кожного елемента;</li>\n  <li><strong>combiner</strong> – з'єднання двох акумуляторів при паралельному виконанні;</li>\n  <li><strong>finisher</strong> (необов’язково) – остання обробка акумулятора.</li>\n</ul>\n\n<p>У Java 8 в класі <code>Collectors</code> реалізовано багато поширених колекторів:</p>\n<ul>\n  <li><code>toList(), toCollection(), toSet()</code> – представляють стрім у вигляді списку, колекції або множини;</li>\n  <li><code>toMap(), toConcurrentMap()</code> – перетворюють стрім у <code>Map</code>;</li>\n  <li><code>averagingInt(), averagingDouble(), averagingLong()</code> – обчислюють середнє значення;</li>\n  <li><code>summingInt(), summingDouble(), summingLong()</code> – обчислюють суму;</li>\n  <li><code>summarizingInt(), summarizingDouble(), summarizingLong()</code> – повертають <code>SummaryStatistics</code> з різними агрегатними значеннями;</li>\n  <li><code>partitioningBy()</code> – розділяє колекцію на дві частини за умовою і повертає <code>Map&lt;Boolean, List&gt;</code>;</li>\n  <li><code>groupingBy()</code> – групує елементи за ключем і повертає <code>Map&lt;N, List&lt;T&gt;&gt;</code>;</li>\n  <li><code>mapping()</code> – дозволяє виконувати додаткові перетворення значень для складних колекторів.</li>\n</ul>\n\n<p>Також можна створювати власні колектори за допомогою <code>Collector.of()</code>:</p>\n<pre>\nCollector&lt;String, List&lt;String&gt;, List&lt;String&gt;&gt; toList = Collector.of(\n    ArrayList::new,\n    List::add,\n    (l1, l2) -&gt; { l1.addAll(l2); return l1; }\n);\n</pre>","topicName":"Core-2"},{"id":223,"questionText":"Для чого в стрімах застосовуються методи <code>forEach()</code> та <code>forEachOrdered()</code>?","answer":"<ul>\n  <li><code>forEach()</code> – застосовує функцію до кожного елемента стріму. При паралельному виконанні порядок обробки елементів не гарантується.</li>\n  <li><code>forEachOrdered()</code> – застосовує функцію до кожного елемента стріму з дотриманням порядку елементів, незалежно від того, чи виконується стрім послідовно чи паралельно.</li>\n</ul>","topicName":"Core-2"},{"id":224,"questionText":"Для чого в стрімах призначені методи <code>map()</code> та <code>mapToInt()</code>, <code>mapToDouble()</code>, <code>mapToLong()</code>?","answer":"<p><code>map()</code> – проміжна операція, яка перетворює кожен елемент стріму відповідно до заданої функції.</p>\n\n<p><code>mapToInt()</code>, <code>mapToDouble()</code>, <code>mapToLong()</code> – аналоги <code>map()</code>, які повертають числовий стрім (IntStream, DoubleStream, LongStream) з відповідними примітивними типами:</p>\n\n<pre><code>Stream.of(\"12\", \"22\", \"4\", \"444\", \"123\")\n      .mapToInt(Integer::parseInt)\n      .toArray(); // результат: [12, 22, 4, 444, 123]\n</code></pre>","topicName":"Core-2"},{"id":225,"questionText":"Яка мета методу <code>filter()</code> у стрімах?","answer":"<p>Метод <code>filter()</code> – проміжна операція, яка приймає предикат (умову) і відбирає лише ті елементи стріму, які задовольняють цю умову.</p>\n\n<pre><code>Stream.of(1, 2, 3, 4, 5)\n      .filter(n -> n % 2 == 0)\n      .forEach(System.out::println); // виведе: 2, 4\n</code></pre>","topicName":"Core-2"},{"id":226,"questionText":"Для чого в стрімах призначений метод <code>limit()</code>?","answer":"<p>Метод <code>limit()</code> – проміжна операція, яка обмежує стрім певною кількістю перших елементів.</p>\n\n<pre><code>Stream.of(1, 2, 3, 4, 5)\n      .limit(3)\n      .forEach(System.out::println); // виведе: 1, 2, 3\n</code></pre>","topicName":"Core-2"},{"id":227,"questionText":"Для чого в стрімах призначений метод <code>sorted()</code>?","answer":"<p>Метод <code>sorted()</code> – проміжна операція, яка дозволяє сортувати елементи стріма. Сортування може відбуватися:</p>\n<ul>\n  <li>у природному порядку (за замовчуванням);</li>\n  <li>за допомогою вказаного <code>Comparator</code>.</li>\n</ul>\n\n<p>Вихідна колекція залишається незмінною – <code>sorted()</code> лише створює відсортоване представлення стріма.</p>\n\n<pre><code>Stream.of(5, 3, 1, 4, 2)\n      .sorted()\n      .forEach(System.out::println); // виведе: 1, 2, 3, 4, 5\n</code></pre>","topicName":"Core-2"},{"id":228,"questionText":"Для чого в стрімах призначені методи <code>flatMap()</code>, <code>flatMapToInt()</code>, <code>flatMapToDouble()</code>, <code>flatMapToLong()</code>?","answer":"<p>Метод <code>flatMap()</code> схожий на <code>map()</code>, але дозволяє створювати з одного елемента кілька. Кожен елемент перетворюється у нуль, один або кілька інших елементів, що підтримуються стрімом. Найпоширеніший випадок використання – перетворення елементів контейнера за допомогою функцій, які повертають інші контейнери.</p>\n\n<pre><code>Stream.of(\"H e l l o\", \"w o r l d !\")\n      .flatMap(p -> Arrays.stream(p.split(\" \")))\n      .toArray(String[]::new); \n// Результат: [\"H\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\", \"!\"]\n</code></pre>\n\n<p>Методи <code>flatMapToInt()</code>, <code>flatMapToDouble()</code>, <code>flatMapToLong()</code> – це аналоги <code>flatMap()</code>, але повертають відповідний числовий стрім.</p>","topicName":"Core-2"},{"id":229,"questionText":"Розкажіть про паралельну обробку в Java 8","answer":"<p>Стріми можуть бути послідовними або паралельними. Послідовні стріми виконуються в одному потоці, паралельні – у кількох потоках процесора через <code>ForkJoinPool.commonPool()</code>. Паралельні стріми ділять дані на частини, обробляють їх паралельно і об'єднують для кінцевих операцій.</p>\n\n<p>Створення паралельного стріму:</p>\n<ul>\n  <li>З колекції: <code>collection.parallelStream()</code></li>\n  <li>З існуючого стріму: <code>stream.parallel()</code></li>\n  <li>Перевірка: <code>stream.isParallel()</code></li>\n</ul>\n\n<p>Методи <code>parallel()</code> і <code>sequential()</code> дозволяють змінювати режим виконання для окремих операцій у стрімі.</p>\n\n<p>Порядок елементів зазвичай зберігається, крім <code>forEach()</code>. Для збереження порядку використовують <code>forEachOrdered()</code>. Метод <code>unordered()</code> може підвищити продуктивність, якщо порядок не важливий.</p>\n\n<p>Фактори продуктивності:</p>\n<ul>\n  <li>Розмір даних та кількість ядер процесора.</li>\n  <li>Структура даних: <code>ArrayList</code> ефективніший за <code>LinkedList</code>.</li>\n  <li>Примітивні типи обробляються швидше, ніж об'єкти.</li>\n  <li>Не варто використовувати паралельні стріми для тривалих операцій (мережа, I/O).</li>\n</ul>","topicName":"Core-2"},{"id":230,"questionText":"Які кінцеві методи роботи зі стрвмами ви знаєте?","answer":"<ul>\n  <li><code>findFirst()</code> – повертає перший елемент;</li>\n  <li><code>findAny()</code> – повертає будь-який відповідний елемент;</li>\n  <li><code>collect()</code> – представляє результат у вигляді колекцій або інших структур даних;</li>\n  <li><code>count()</code> – повертає кількість елементів;</li>\n  <li><code>anyMatch()</code> – повертає true, якщо умова виконується хоча б для одного елемента;</li>\n  <li><code>noneMatch()</code> – повертає true, якщо умова не виконується жодного елемента;</li>\n  <li><code>allMatch()</code> – повертає true, якщо умова виконується для всіх елементів;</li>\n  <li><code>min()</code> – повертає мінімальний елемент, використовуючи <code>Comparator</code>;</li>\n  <li><code>max()</code> – повертає максимальний елемент, використовуючи <code>Comparator</code>;</li>\n  <li><code>forEach()</code> – застосовує функцію до кожного об'єкта (порядок при паралельному виконанні не гарантується);</li>\n  <li><code>forEachOrdered()</code> – застосовує функцію до кожного об'єкта зі збереженням порядку;</li>\n  <li><code>toArray()</code> – повертає масив значень;</li>\n  <li><code>reduce()</code> – виконує агрегатні функції і повертає один результат;</li>\n</ul>\n\n<p>Для числових стрімів додатково доступні:</p>\n<ul>\n  <li><code>sum()</code> – повертає суму всіх чисел;</li>\n  <li><code>average()</code> – повертає середнє арифметичне всіх чисел.</li>\n</ul>","topicName":"Core-2"},{"id":231,"questionText":"Які проміжні методи роботи зі стрімами ви знаєте?","answer":"<ul>\n  <li><code>filter()</code> – фільтрує записи, повертаючи лише ті, які відповідають умові;</li>\n  <li><code>skip()</code> – пропускає певну кількість елементів на початку;</li>\n  <li><code>distinct()</code> – повертає стрім без дублікатів (за методом <code>equals()</code>);</li>\n  <li><code>map()</code> – перетворює кожен елемент;</li>\n  <li><code>peek()</code> – застосовує функцію до кожного елемента, повертаючи той же стрім;</li>\n  <li><code>limit()</code> – обмежує вибірку певною кількістю перших елементів;</li>\n  <li><code>sorted()</code> – сортує значення або в природньому порядку, або за допомогою <code>Comparator</code>;</li>\n  <li><code>mapToInt(), mapToDouble(), mapToLong()</code> – аналоги <code>map()</code>, що повертають стрім числових примітивів;</li>\n  <li><code>flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong()</code> – схожі на <code>map()</code>, але можуть створювати з одного елемента декілька;</li>\n</ul>","topicName":"Core-2"},{"id":232,"questionText":"Як вивести на екран 10 випадкових чисел, використовуючи forEach()?","answer":"<pre><code>(new Random())\n.ints()\n.limit(10)\n.forEach(System.out::println);\n</code></pre>","topicName":"Core-2"},{"id":233,"questionText":"Як можна вивести на екран унікальні квадрати чисел, використовуючи метод map()?","answer":"<pre><code>Stream\n.of(1, 2, 3, 2, 1)\n.map(s -> s * s)\n.distinct()\n.forEach(System.out::println);\n</code></pre>","topicName":"Core-2"},{"id":234,"questionText":"Як вивести на екран кількість порожніх рядків за допомогою метода filter()?","answer":"<pre><code>System.out.println(\n    Stream\n        .of(\"Hello\", \"\", \", \", \"world\", \"!\")\n        .filter(String::isEmpty)\n        .count()\n);\n</code></pre>","topicName":"Core-2"},{"id":235,"questionText":"Як вивести на екран 10 випадкових чисел у порядку зростання?","answer":"<pre><code>(new Random())\n    .ints()\n    .limit(10)\n    .sorted()\n    .forEach(System.out::println);\n</code></pre>","topicName":"Core-2"},{"id":236,"questionText":"Як знайти максимальне число в наборі?","answer":"<pre><code>Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -> a)\n    .max()\n    .getAsInt(); // 55\n</code></pre>","topicName":"Core-2"},{"id":237,"questionText":"Як знайти мінімальне число в наборі?","answer":"<pre><code>Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -> a)\n    .min()\n    .getAsInt(); // 2\n</code></pre>","topicName":"Core-2"},{"id":238,"questionText":"Як отримати суму всіх чисел в наборі?","answer":"<pre><code>Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -> a)\n    .sum(); // 69\n</code></pre>","topicName":"Core-2"},{"id":239,"questionText":"Як отримати середнє значення всіх чисел?","answer":"<pre><code>Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -> a)\n    .average()\n    .getAsDouble(); // 13.8\n</code></pre>","topicName":"Core-2"},{"id":240,"questionText":"Які додаткові методи для роботи з асоціативними масивами (maps) з'явилися в Java 8?","answer":"<ul>\n  <li><strong>putIfAbsent()</strong> – додає пару «ключ-значення», лише якщо ключ був відсутній:\n    <pre><code>map.putIfAbsent(\"a\", \"Aa\");</code></pre>\n  </li>\n  <li><strong>forEach()</strong> – виконує функцію над кожним елементом:\n    <pre><code>map.forEach((k, v) -&gt; System.out.println(v));</code></pre>\n  </li>\n  <li><strong>compute()</strong> – створює або оновлює поточне значення через обчислення:\n    <pre><code>map.compute(\"a\", (k, v) -&gt; String.valueOf(k).concat(v)); // [\"a\", \"aAa\"]</code></pre>\n  </li>\n  <li><strong>computeIfPresent()</strong> – оновлює значення, якщо ключ існує:\n    <pre><code>map.computeIfPresent(\"a\", (k, v) -&gt; k.concat(v));</code></pre>\n  </li>\n  <li><strong>computeIfAbsent()</strong> – створює ключ із значенням, якщо його немає:\n    <pre><code>map.computeIfAbsent(\"a\", k -&gt; \"A\".concat(k)); // [\"a\",\"Aa\"]</code></pre>\n  </li>\n  <li><strong>getOrDefault()</strong> – повертає значення за замовчуванням, якщо ключа немає:\n    <pre><code>map.getOrDefault(\"a\", \"not found\");</code></pre>\n  </li>\n  <li><strong>merge()</strong> – об’єднує передане і поточне значення, або додає нове:\n    <pre><code>map.merge(\"a\", \"z\", (value, newValue) -&gt; value.concat(newValue)); // [\"a\",\"Aaz\"]</code></pre>\n  </li>\n</ul>","topicName":"Core-2"},{"id":241,"questionText":"Що таке LocalDateTime?","answer":"<p>LocalDateTime об'єднує <strong>LocalDate</strong> і <strong>LocalTime</strong>, містить дату та час у календарній системі ISO-8601 без прив'язки до часового поясу. Час зберігається з точністю до наносекунди.</p>\n<p>Надає багато зручних методів, наприклад:</p>\n<ul>\n  <li><code>plusMinutes()</code> – додає хвилини</li>\n  <li><code>plusHours()</code> – додає години</li>\n  <li><code>isAfter()</code> – перевіряє, чи йде дата після іншої</li>\n  <li><code>toSecondOfDay()</code> – повертає кількість секунд від початку дня</li>\n</ul>","topicName":"Core-2"},{"id":242,"questionText":"Що таке ZonedDateTime?","answer":"<p><code>java.time.ZonedDateTime</code> – це аналог <code>java.util.Calendar</code>, який містить повну інформацію про часовий контекст у календарній системі ISO-8601. Він включає <strong>часовий пояс</strong>, тому всі операції зі зміщенням часу виконуються з урахуванням цього поясу.</p>","topicName":"Core-2"},{"id":243,"questionText":"Як отримати поточну дату за допомогою Date Time API з Java 8?","answer":"<p>Використовуйте метод <code>LocalDate.now()</code>:</p>\n<pre><code>LocalDate currentDate = LocalDate.now();</code></pre>","topicName":"Core-2"},{"id":244,"questionText":"Як додати 1 тиждень, 1 місяць, 1 рік, 10 років до поточної дати за допомогою Date Time API?","answer":"<p>Використовуються методи <code>plusWeeks</code>, <code>plusMonths</code>, <code>plusYears</code> та <code>plus</code> з <code>ChronoUnit</code>:</p>\n<pre><code>LocalDate.now().plusWeeks(1);       // додає 1 тиждень\nLocalDate.now().plusMonths(1);      // додає 1 місяць\nLocalDate.now().plusYears(1);       // додає 1 рік\nLocalDate.now().plus(1, ChronoUnit.DECADES); // додає 10 років</code></pre>","topicName":"Core-2"},{"id":245,"questionText":"Як отримати наступний вівторок, використовуючи Date Time API?","answer":"<pre><code>LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.TUESDAY));</code></pre>","topicName":"Core-2"},{"id":246,"questionText":"Як отримати другу суботу поточного місяця, використовуючи Date Time API?","answer":"<pre><code>LocalDate\n    .of(LocalDate.now().getYear(), LocalDate.now().getMonth(), 1)\n    .with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY))\n    .with(TemporalAdjusters.next(DayOfWeek.SATURDAY));</code></pre>","topicName":"Core-2"},{"id":247,"questionText":"Як отримати поточний час з точністю до мілісекунд, використовуючи Date Time API?","answer":"<pre><code>new Date().toInstant();</code></pre>","topicName":"Core-2"},{"id":248,"questionText":"Як отримати поточний час за місцевим часом з точністю до мілісекунд, використовуючи Date Time API?","answer":"<pre><code>LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());</code></pre>","topicName":"Core-2"},{"id":249,"questionText":"Що таке \"функціональні інтерфейси\"?","answer":"<p>Функціональний інтерфейс — це інтерфейс, який містить лише один абстрактний метод. Для точного визначення інтерфейсу як функціонального використовується анотація <code>@FunctionalInterface</code>, яка не дозволяє додавати другий абстрактний метод. Інтерфейс може містити будь-яку кількість <code>default</code>-методів і залишатися функціональним, оскільки <code>default</code>-методи не є абстрактними.</p>","topicName":"Core-2"},{"id":250,"questionText":"Для чого потрібні функціональні інтерфейси Function&lt;T, R&gt;, DoubleFunction&lt;R&gt;, IntFunction&lt;R&gt; і LongFunction&lt;R&gt;?","answer":"<p><strong>Function&lt;T, R&gt;</strong> — інтерфейс для функцій, які приймають об'єкт типу <code>T</code> і повертають об'єкт типу <code>R</code>. Мають default-методи <code>compose</code> і <code>andThen</code> для побудови ланцюжків викликів.</p>\n<pre><code>Function&lt;String, Integer&gt; toInteger = Integer::valueOf;\nFunction&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);\nbackToString.apply(\"123\"); // \"123\"\n</code></pre>\n<p><strong>DoubleFunction&lt;R&gt;</strong> — приймає <code>Double</code> і повертає <code>R</code>.<br>\n<strong>IntFunction&lt;R&gt;</strong> — приймає <code>Integer</code> і повертає <code>R</code>.<br>\n<strong>LongFunction&lt;R&gt;</strong> — приймає <code>Long</code> і повертає <code>R</code>.</p>","topicName":"Core-2"},{"id":251,"questionText":"Для чого потрібні функціональні інтерфейси UnaryOperator&lt;T&gt;, DoubleUnaryOperator, IntUnaryOperator і LongUnaryOperator?","answer":"<p><strong>UnaryOperator&lt;T&gt;</strong> — оператор, який приймає об'єкт типу <code>T</code>, виконує над ним операції і повертає результат того ж типу <code>T</code>:</p>\n<pre><code>UnaryOperator&lt;Integer&gt; operator = x -&gt; x * x;\nSystem.out.println(operator.apply(5)); // 25\n</code></pre>\n<p><strong>DoubleUnaryOperator</strong> — приймає <code>Double</code> і повертає <code>Double</code>.<br>\n<strong>IntUnaryOperator</strong> — приймає <code>Integer</code> і повертає <code>Integer</code>.<br>\n<strong>LongUnaryOperator</strong> — приймає <code>Long</code> і повертає <code>Long</code>.</p>","topicName":"Core-2"},{"id":252,"questionText":"Для чого потрібні функціональні інтерфейси BinaryOperator&lt;T&gt;, DoubleBinaryOperator, IntBinaryOperator і LongBinaryOperator?","answer":"<p><strong>BinaryOperator&lt;T&gt;</strong> — бінарний оператор, який приймає два об'єкти типу <code>T</code> і повертає результат того ж типу <code>T</code>:</p>\n<pre><code>BinaryOperator&lt;Integer&gt; operator = (a, b) -&gt; a + b;\nSystem.out.println(operator.apply(1, 2)); // 3\n</code></pre>\n<p><strong>DoubleBinaryOperator</strong> — приймає два <code>Double</code> і повертає <code>Double</code>.<br>\n<strong>IntBinaryOperator</strong> — приймає два <code>Integer</code> і повертає <code>Integer</code>.<br>\n<strong>LongBinaryOperator</strong> — приймає два <code>Long</code> і повертає <code>Long</code>.</p>","topicName":"Core-2"},{"id":253,"questionText":"Для чого потрібні функціональні інтерфейси Predicate&lt;T&gt;, DoublePredicate, IntPredicate і LongPredicate?","answer":"<p><strong>Predicate&lt;T&gt;</strong> — предикат, який приймає об'єкт типу <code>T</code> і повертає <code>boolean</code>. Містить методи <code>and</code>, <code>or</code>, <code>negate</code> для комбінування умов:</p>\n<pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\npredicate.test(\"foo\"); // true\npredicate.negate().test(\"foo\"); // false\n</code></pre>\n<p><strong>DoublePredicate</strong> — приймає <code>Double</code> і повертає <code>boolean</code>.<br>\n<strong>IntPredicate</strong> — приймає <code>Integer</code> і повертає <code>boolean</code>.<br>\n<strong>LongPredicate</strong> — приймає <code>Long</code> і повертає <code>boolean</code>.</p>","topicName":"Core-2"},{"id":254,"questionText":"Для чого потрібні функціональні інтерфейси Consumer&lt;T&gt;, DoubleConsumer, IntConsumer і LongConsumer?","answer":"<p><strong>Consumer&lt;T&gt;</strong> — споживач, який приймає об'єкт типу <code>T</code>, виконує над ним дію і нічого не повертає:</p>\n<pre><code>Consumer&lt;String&gt; hello = (name) -&gt; System.out.println(\"Hello, \" + name);\nhello.accept(\"world\"); // Hello, world\n</code></pre>\n<p><strong>DoubleConsumer</strong> — споживач, який приймає <code>Double</code>.<br>\n<strong>IntConsumer</strong> — споживач, який приймає <code>Integer</code>.<br>\n<strong>LongConsumer</strong> — споживач, який приймає <code>Long</code>.</p>","topicName":"Core-2"},{"id":255,"questionText":"Для чого потрібні функціональні інтерфейси Supplier&lt;T&gt;, BooleanSupplier, DoubleSupplier, IntSupplier і LongSupplier?","answer":"<p><strong>Supplier&lt;T&gt;</strong> — постачальник, який не приймає аргументів, але повертає об'єкт типу <code>T</code>:</p>\n<pre><code>Supplier&lt;LocalDateTime&gt; now = LocalDateTime::now;\nnow.get(); // повертає поточний LocalDateTime\n</code></pre>\n<p><strong>DoubleSupplier</strong> — постачальник, що повертає <code>Double</code>.<br>\n<strong>IntSupplier</strong> — постачальник, що повертає <code>Integer</code>.<br>\n<strong>LongSupplier</strong> — постачальник, що повертає <code>Long</code>.</p>","topicName":"Core-2"},{"id":256,"questionText":"Для чого потрібен функціональний інтерфейс BiConsumer&lt;T, U&gt;?","answer":"<p><strong>BiConsumer&lt;T, U&gt;</strong> — інтерфейс, який представляє операцію, що приймає два аргументи типів <code>T</code> і <code>U</code>, виконує з ними певну дію і нічого не повертає.</p>","topicName":"Core-2"},{"id":257,"questionText":"Для чого потрібен функціональний інтерфейс BiFunction&lt;T, U, R&gt;?","answer":"<p><strong>BiFunction&lt;T, U, R&gt;</strong> — інтерфейс, який представляє операцію, що приймає два аргументи типів <code>T</code> і <code>U</code> та повертає результат типу <code>R</code>.</p>","topicName":"Core-2"},{"id":258,"questionText":"Для чого потрібен функціональний інтерфейс BiPredicate&lt;T, U&gt;?","answer":"<p><strong>BiPredicate&lt;T, U&gt;</strong> — інтерфейс, який представляє операцію, що приймає два аргументи типів <code>T</code> і <code>U</code> та повертає результат типу <code>boolean</code>.</p>","topicName":"Core-2"},{"id":259,"questionText":"Для чого потрібні функціональні інтерфейси вигляду <em>_To_Function</em>?","answer":"<ul>\n  <li><strong>DoubleToIntFunction</strong> – приймає <code>Double</code> і повертає <code>Integer</code>;</li>\n  <li><strong>DoubleToLongFunction</strong> – приймає <code>Double</code> і повертає <code>Long</code>;</li>\n  <li><strong>IntToDoubleFunction</strong> – приймає <code>Integer</code> і повертає <code>Double</code>;</li>\n  <li><strong>IntToLongFunction</strong> – приймає <code>Integer</code> і повертає <code>Long</code>;</li>\n  <li><strong>LongToDoubleFunction</strong> – приймає <code>Long</code> і повертає <code>Double</code>;</li>\n  <li><strong>LongToIntFunction</strong> – приймає <code>Long</code> і повертає <code>Integer</code>.</li>\n</ul>","topicName":"Core-2"},{"id":260,"questionText":"Для чого потрібні функціональні інтерфейси ToDoubleBiFunction&lt;T, U&gt;, ToIntBiFunction&lt;T, U&gt; і ToLongBiFunction&lt;T, U&gt;?","answer":"<ul>\n  <li><strong>ToDoubleBiFunction&lt;T, U&gt;</strong> – приймає два аргументи класів T і U, повертає <code>Double</code>;</li>\n  <li><strong>ToIntBiFunction&lt;T, U&gt;</strong> – приймає два аргументи класів T і U, повертає <code>Integer</code>;</li>\n  <li><strong>ToLongBiFunction&lt;T, U&gt;</strong> – приймає два аргументи класів T і U, повертає <code>Long</code>.</li>\n</ul>","topicName":"Core-2"},{"id":261,"questionText":"Для чого потрібні функціональні інтерфейси ToDoubleFunction&lt;T&gt;, ToIntFunction&lt;T&gt; і ToLongFunction&lt;T&gt;?","answer":"<ul>\n  <li><strong>ToDoubleFunction&lt;T&gt;</strong> – приймає аргумент класу T і повертає <code>Double</code>;</li>\n  <li><strong>ToIntFunction&lt;T&gt;</strong> – приймає аргумент класу T і повертає <code>Integer</code>;</li>\n  <li><strong>ToLongFunction&lt;T&gt;</strong> – приймає аргумент класу T і повертає <code>Long</code>.</li>\n</ul>","topicName":"Core-2"},{"id":262,"questionText":"Для чого потрібні функціональні інтерфейси ObjDoubleConsumer&lt;T&gt;, ObjIntConsumer&lt;T&gt; і ObjLongConsumer&lt;T&gt;?","answer":"<ul>\n  <li><strong>ObjDoubleConsumer&lt;T&gt;</strong> – приймає аргументи класів T і Double, виконує дію і нічого не повертає;</li>\n  <li><strong>ObjIntConsumer&lt;T&gt;</strong> – приймає аргументи класів T і Integer, виконує дію і нічого не повертає;</li>\n  <li><strong>ObjLongConsumer&lt;T&gt;</strong> – приймає аргументи класів T і Long, виконує дію і нічого не повертає.</li>\n</ul>","topicName":"Core-2"},{"id":263,"questionText":"Як визначити повторювану анотацію?","answer":"<p>Щоб визначити повторювану анотацію, необхідно створити анотацію-контейнер для списку повторюваних анотацій і позначити повторювану мета-анотацією <code>@Repeatable</code>:</p> <pre><code>@interface Schedulers { Scheduler[] value(); } @Repeatable(Schedulers.class) @interface Scheduler { String birthday() default \"Jan 8 1935\"; } </code></pre>","topicName":"Core-2"},{"id":264,"questionText":"Що таке колекція?","answer":"<p>Колекція – це структура даних, набір якихось об'єктів. Дані (об'єкти у наборі) можуть бути числами, рядками, об'єктами користувальницьких класів і т.д.</p>","topicName":"Core-2"},{"id":265,"questionText":"Назвіть основні інтерфейси Java Collections Framework та їх реалізації","answer":"<p>На вершині ієрархії в Java Collection Framework розташовані два інтерфейси: <strong>Collection</strong> і <strong>Map</strong>. Ці інтерфейси розділяють всі колекції у фреймворку на дві частини за типом зберігання даних: прості послідовні набори елементів і набори пар \"ключ – значення\" відповідно.</p> <h4>Інтерфейс Collection розширюють інтерфейси:</h4> <ul> <li><strong>List (список)</strong> – колекція, в якій дозволено дублювання значень. Елементи такої колекції пронумеровані, починаючи з нуля, до них можна звертатися за індексом. Реалізації: <ul> <li><strong>ArrayList</strong> – інкапсулює звичайний масив, довжина якого автоматично збільшується при додаванні нових елементів.</li> <li><strong>LinkedList</strong> – двонаправлений зв'язаний список, складається з вузлів, кожен з яких містить як дані, так і посилання на наступний і попередній вузол.</li> <li><strong>Vector</strong> – реалізація динамічного масиву об'єктів, методи якої синхронізовані.</li> <li><strong>Stack</strong> – реалізація стека LIFO (останній прийшов – перший вийшов).</li> </ul> </li> <li><strong>Set (множина)</strong> – неупорядкована колекція, яка не містить повторюючихся елементів. Реалізації: <ul> <li><strong>HashSet</strong> – використовує HashMap для зберігання даних. Як ключ і значення використовується додаваний елемент. Порядок елементів не гарантується.</li> <li><strong>LinkedHashSet</strong> – гарантує, що порядок елементів при обходженні колекції буде ідентичний порядку додавання елементів.</li> <li><strong>TreeSet</strong> – дозволяє керувати порядком елементів за допомогою Comparator або natural ordering.</li> </ul> </li> <li><strong>Queue (черга)</strong> – призначена для зберігання елементів із передбаченим способом вставки та вилучення FIFO (перший прийшов – перший вийшов). Реалізації: <ul> <li><strong>PriorityQueue</strong> – керує порядком елементів за допомогою Comparator або natural ordering.</li> <li><strong>ArrayDeque</strong> – реалізація інтерфейсу Deque, який розширює Queue методами для LIFO (останній прийшов – перший вийшов).</li> </ul> </li> </ul>","topicName":"Core-2"},{"id":266,"questionText":"Розташуйте у вигляді ієрархії наступні інтерфейси: List, Set,\nMap, SortedSet, SortedMap, Collection, Iterable, Iterator,\nNavigableSet, NavigableMap","answer":"<strong>Iterable</strong> <ul> <li><strong>Iterator</strong></li> <li><strong>Collection</strong> <ul> <li><strong>List</strong></li> <li><strong>Set</strong> <ul> <li><strong>SortedSet</strong> <ul> <li><strong>NavigableSet</strong></li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li><strong>Map</strong> <ul> <li><strong>SortedMap</strong> <ul> <li><strong>NavigableMap</strong></li> </ul> </li> </ul> </li> </ul>","topicName":"Core-2"},{"id":267,"questionText":"Чому Map – це не Collection, а List і Set є Collection?","answer":"<p><strong>Collection</strong> представляє собою сукупність деяких елементів. Елементи зберігаються як окремі об’єкти, до яких можна звертатися або перебирати їх послідовно. Тому <strong>List</strong> і <strong>Set</strong> є підтипами Collection.</p> <p><strong>Map</strong> зберігає дані у вигляді пар «ключ–значення». Це не просто набір елементів, а асоціативна структура, де доступ до значення здійснюється через ключ. Тому Map не є підтипом Collection, хоча має власні методи для перебору і роботи з елементами.</p>","topicName":"Core-2"},{"id":268,"questionText":"Stack вважається \"застарілим\". Чим його рекомендують заміняти і чому?","answer":"<p><strong>Stack</strong> був доданий у Java 1.0 як реалізація стеку LIFO (last-in-first-out) і є розширенням колекції <strong>Vector</strong>. Це трохи порушує поняття стеку, оскільки Vector дозволяє звертатися до будь-якого елементу за індексом. Крім того, Stack є частково синхронізованою колекцією (за винятком методу <code>push()</code>), що може впливати на продуктивність.</p> <p>Після введення інтерфейсу <strong>Deque</strong> у Java 1.6 рекомендується використовувати реалізації цього інтерфейсу, наприклад, <strong>ArrayDeque</strong>, для реалізації стеку LIFO. Це більш сучасний і продуктивний підхід.</p>","topicName":"Core-2"},{"id":269,"questionText":"Яка різниця між List та Set","answer":"<p>Відмінність між списком та множиною в Java:</p> <ul> <li><strong>Порядок елементів:</strong> List – впорядкована послідовність елементів; Set – окремий набір елементів без гарантованого порядку.</li> <li><strong>Дублювання:</strong> List допускає дублювання елементів; Set – не допускає повторюваних елементів.</li> <li><strong>Null-значення:</strong> List дозволяє будь-яку кількість null-значень; Set дозволяє лише одне null-значення.</li> <li><strong>Перегляд елементів:</strong> List можна переглядати як у прямому, так і в зворотному напрямку за допомогою <code>ListIterator</code>; Set можна переглядати лише в прямому напрямку за допомогою ітератора.</li> </ul>","topicName":"Core-2"},{"id":270,"questionText":"Які класи реалізують інтерфейс Map?","answer":"<p><strong>Інтерфейс Map</strong> реалізований класами:</p> <ul> <li><strong><code>Hashtable</code></strong> — хеш-таблиця, методи якої синхронізовані. Не дозволяє використовувати <code>null</code> як значення або ключ і не є впорядкованою.</li> <li><strong><code>HashMap</code></strong> — хеш-таблиця. Дозволяє використовувати <code>null</code> як значення або ключ і не є впорядкованою.</li> <li><strong><code>LinkedHashMap</code></strong> — впорядкована реалізація хеш-таблиці (порядок ітерації відповідає порядку додавання або доступу).</li> <li><strong><code>TreeMap</code></strong> — реалізація на основі червоно-чорних дерев. Є впорядкованою і надає можливість керувати порядком елементів за допомогою об’єкта <code>Comparator</code> або зберігає елементи з використанням «natural ordering».</li> <li><strong><code>WeakHashMap</code></strong> — хеш-таблиця, організована з використанням weak references для ключів (збірник сміття автоматично видалить елемент під час наступного збирання, якщо для ключа немає жорстких посилань).</li> </ul>","topicName":"Core-2"},{"id":271,"questionText":"В чому різниця між класами <code>java.util.Collection</code> і <code>java.util.Collections</code>?","answer":"<ul> <li><strong><code>java.util.Collections</code></strong> – це утилітний клас, що містить набір <em>статичних методів</em> для роботи з колекціями (наприклад, сортування, пошук, створення синхронізованих колекцій тощо).</li> <li><strong><code>java.util.Collection</code></strong> – один із основних <em>інтерфейсів</em> Java Collections Framework, який визначає базові операції над колекціями елементів.</li> </ul>","topicName":"Core-2"},{"id":272,"questionText":"Чим відрізняється <code>ArrayList</code> від <code>LinkedList</code>? В яких випадках краще використовувати перший, а в яких другий?","answer":"<p><strong>ArrayList</strong> – це список, реалізований на основі масиву, тоді як <strong>LinkedList</strong> – це класичний двоспрямований список, заснований на об'єктах із посиланнями між ними.</p> <h4>ArrayList:</h4> <ul> <li>Доступ до довільного елемента за індексом – константний час <code>O(1)</code>.</li> <li>Доступ до елементів за значенням – лінійний час <code>O(N)</code>.</li> <li>Вставка в кінець – у середньому <code>O(1)</code>.</li> <li>Видалення довільного елемента – повільне, оскільки всі елементи праворуч зсуваються на одну позицію вліво (реальний розмір масиву <em>capacity</em> не змінюється).</li> <li>Вставка елемента у довільне місце – повільна, оскільки всі елементи праворуч зсуваються вправо.</li> <li>Мінімальні накладні витрати при зберіганні.</li> </ul> <h4>LinkedList:</h4> <ul> <li>Отримання елемента за індексом чи значенням – лінійний час <code>O(N)</code>.</li> <li>Додавання і видалення на початку чи в кінці списку – константний час <code>O(1)</code>.</li> <li>Вставка чи видалення у довільне місце – лінійний час <code>O(N)</code>.</li> <li>Потребує більше пам’яті для зберігання, оскільки зберігає посилання на попередній і наступний елементи.</li> </ul> <h4>Висновок:</h4> <p><strong>ArrayList</strong> швидший та ефективніший за використанням пам’яті у більшості випадків. <strong>LinkedList</strong> доцільно застосовувати, коли потрібні часті вставки або видалення елементів, особливо на початку чи в кінці списку, або коли важливий гарантований час додавання елемента.</p>","topicName":"Core-2"},{"id":273,"questionText":"Що працює швидше: ArrayList чи LinkedList?","answer":"<p><strong>ArrayList</strong> зазвичай працює швидше, ніж <strong>LinkedList</strong>, у більшості випадків.</p>\n\n<ul>\n  <li><strong>ArrayList</strong>:\n    <ul>\n      <li>Швидкий доступ до елементів за індексом (O(1)).</li>\n      <li>Додавання в кінець списку також ефективне (амортизовано O(1)).</li>\n      <li>Вставка чи видалення в середині списку повільні (O(n)), бо потрібно пересунути елементи.</li>\n    </ul>\n  </li>\n  <li><strong>LinkedList</strong>:\n    <ul>\n      <li>Вставка та видалення в середині списку швидші (O(1)), якщо є посилання на вузол.</li>\n      <li>Доступ до елементів за індексом повільний (O(n)), бо потрібно пройти список.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>Висновок:</strong> Якщо потрібен швидкий доступ до елементів — краще використовувати <strong>ArrayList</strong>. \nЯкщо часто вставляються чи видаляються елементи в середині — <strong>LinkedList</strong> може бути ефективнішим.</p>","topicName":"Core-2"},{"id":274,"questionText":"Який найгірший час роботи методу <code>contains()</code> для елемента, який є в <code>LinkedList</code>?","answer":"<p><strong>O(N)</strong> – час пошуку елемента лінійно пропорційний кількості елементів у списку.</p>","topicName":"Core-2"},{"id":275,"questionText":"Який найгірший час роботи методу <code>contains()</code> для елемента, який є в <code>ArrayList</code>?","answer":"<p><strong>O(N)</strong> – час пошуку елемента лінійно пропорційний кількості елементів у списку.</p>","topicName":"Core-2"},{"id":276,"questionText":"Який найгірший час роботи методу <code>add()</code> для <code>LinkedList</code>?","answer":"<p><strong>O(N)</strong> – якщо потрібно додати елемент у довільне місце списку, час лінійно пропорційний кількості елементів. Додавання в початок або кінець списку виконується за <strong>O(1)</strong>.</p>","topicName":"Core-2"},{"id":277,"questionText":"Який найгірший час роботи методу <code>add()</code> для <code>ArrayList</code>?","answer":"<p><strong>O(N)</strong> – вставка елемента в кінець списку зазвичай виконується за <strong>O(1)</strong>, але якщо місткість масиву недостатня, створюється новий масив з більшим розміром і всі елементи копіюються зі старого масиву в новий, що займає лінійний час.</p>","topicName":"Core-2"},{"id":278,"questionText":"Необхідно додати 1 млн. елементів, яку структуру ви використовуєте?","answer":"<p>Однозначну відповідь можна дати тільки на основі інформації про:</p>\n<ul>\n  <li>В яку частину списку відбувається додавання елементів;</li>\n  <li>Що буде відбуватися з елементами списку після додавання;</li>\n  <li>Чи існують обмеження щодо пам'яті або швидкості виконання.</li>\n</ul>\n\n<p>Детальніше див. <a href=\"#\">чим відрізняється <code>ArrayList</code> від <code>LinkedList</code></a>.</p>","topicName":"Core-2"},{"id":279,"questionText":"Як відбувається видалення елементів з <code>ArrayList</code>? Як змінюється розмір ArrayList у цьому випадку?","answer":"<p>При видаленні будь-якого елемента зі списку всі елементи, які знаходяться «праворуч», зсуваються на одну позицію ліворуч, а реальний розмір масиву (<em>capacity</em>) не змінюється. Механізм автоматичного «розширення» масиву існує, але автоматичного «стискання» немає; можна лише явно виконати «стискання» командою <code>trimToSize()</code>.</p>","topicName":"Core-2"},{"id":280,"questionText":"Ефективний алгоритм видалення кількох поруч стоячих елементів із середини <code>ArrayList</code>","answer":"<p>Припустимо, потрібно видалити <strong>n</strong> елементів із позиції <strong>m</strong> у списку. Замість видалення одного елемента <em>n</em> разів (що викликає багато зсувів елементів), ефективніше виконати наступне:</p>\n\n<ul>\n  <li>Зсунути всі елементи, які знаходяться праворуч від позиції <code>m + n - 1</code>, на <strong>n</strong> позицій ліворуч до початку списку.</li>\n  <li>Таким чином, всі потрібні елементи видаляються за один прохід, без повторних зсувів для кожного елемента.</li>\n</ul>\n\n<p>Цей підхід значно підвищує ефективність видалення елементів із середини <code>ArrayList</code>.</p>","topicName":"Core-2"},{"id":281,"questionText":"Скільки додаткової пам'яті виділяється при виклику <code>ArrayList.add()</code>?","answer":"<p>Якщо в масиві є достатньо місця для розміщення нового елемента, додаткової пам'яті не потрібно. В іншому випадку створюється новий масив розміром у 1,5 рази більший за існуючий (це вірно для JDK 1.7 і вище; у більш ранніх версіях розмір збільшення може відрізнятися).</p>","topicName":"Core-2"},{"id":282,"questionText":"Скільки додаткової пам'яті виділяється при виклику <code>LinkedList.add()</code>?","answer":"<p>Створюється один новий екземпляр вкладеного класу <code>Node</code>.</p>","topicName":"Core-2"},{"id":283,"questionText":"Оцінка пам'яті для зберігання одного примітиву типу <code>byte</code> в <code>LinkedList</code>","answer":"<p>Кожен елемент <code>LinkedList</code> представлений об'єктом <code>Node</code>, який містить:</p>\n<ul>\n  <li>посилання на попередній елемент (<code>prev</code>),</li>\n  <li>посилання на наступний елемент (<code>next</code>),</li>\n  <li>посилання на дані (<code>item</code>).</li>\n</ul>\n\n<pre>\nprivate static class Node&lt;E&gt; {\n    E item;\n    Node&lt;E&gt; next;\n    Node&lt;E&gt; prev;\n    //...\n}\n</pre>\n\n<h4>32-бітна JVM:</h4>\n<ul>\n  <li>Кожне посилання займає 4 байти, об'єкт <code>Node</code> має заголовок 8 байт.</li>\n  <li>Підсумок: 4 + 4 + 4 + 8 = 20 байт → округляється до 24 байт (Java об'єкти кратні 8 байтам).</li>\n  <li>Примітив <code>byte</code> у Java упаковується в об'єкт <code>Byte</code>, який займає 16 байт (8 байт заголовок + 1 байт поле + 7 байт для кратності 8).</li>\n  <li>Всього на один елемент списку: 24 + 16 = 40 байт.</li>\n</ul>\n\n<h4>64-бітна JVM:</h4>\n<ul>\n  <li>Кожне посилання займає 8 байт, заголовок об'єкта <code>Node</code> – 16 байт.</li>\n  <li>Підсумок: 8 + 8 + 8 + 16 = 40 байт → округляється до 40 або 48 байт, залежно від JVM alignment.</li>\n  <li>Об'єкт <code>Byte</code> займає 24 байти.</li>\n  <li>Всього на один елемент списку: 40 + 24 = 64 байти.</li>\n</ul>\n\n<p>Таким чином, <strong>зберігання одного примітиву <code>byte</code> у LinkedList</strong> потребує приблизно 40 байт на 32-бітній JVM і 64 байти на 64-бітній JVM.</p>","topicName":"Core-2"},{"id":284,"questionText":"Оцінка пам'яті для зберігання одного примітиву типу <code>byte</code> в <code>ArrayList</code>","answer":"<p><code>ArrayList</code> базується на масиві об'єктів. Для примітивних типів відбувається автоматична упаковка у відповідний об'єкт (<code>Byte</code>), тому витрачається пам'ять на два компоненти:</p>\n\n<ul>\n  <li><strong>Посилання на об'єкт у масиві:</strong> 4 байти для 32-бітної JVM, 8 байт для 64-бітної JVM.</li>\n  <li><strong>Упакований об'єкт <code>Byte</code>:</strong> 16 байт для 32-бітної JVM (8 байт заголовок + 1 байт поле + 7 байт вирівнювання), 24 байти для 64-бітної JVM.</li>\n</ul>\n\n<p>Таким чином:</p>\n<ul>\n  <li>32-бітна JVM: 4 + 16 = 20 байт на один елемент.</li>\n  <li>64-бітна JVM: 8 + 24 = 32 байти на один елемент.</li>\n</ul>","topicName":"Core-2"},{"id":285,"questionText":"Для <code>ArrayList</code> або <code>LinkedList</code> операція додавання елемента в середину повільніше?","answer":"<p>Розглянемо операцію <code>list.add(list.size()/2, newElement)</code>:</p>\n\n<h4>ArrayList:</h4>\n<ul>\n  <li>Перевірка масиву на вмістимість; якщо місця недостатньо, створюється новий масив і всі елементи копіюються в нього (<code>O(N)</code>).</li>\n  <li>Копіювання всіх елементів праворуч від позиції вставки на одну позицію вправо (<code>O(N)</code>).</li>\n  <li>Вставка елемента (<code>O(1)</code>).</li>\n</ul>\n\n<h4>LinkedList:</h4>\n<ul>\n  <li>Пошук позиції вставки (<code>O(N)</code>).</li>\n  <li>Вставка елемента (<code>O(1)</code>).</li>\n</ul>\n\n<p><strong>Висновок:</strong> у найгіршому випадку вставка в середину ефективніша для <code>LinkedList</code>. У більшості інших випадків швидше може бути <code>ArrayList</code>, оскільки копіювання елементів виконується через швидкий системний метод <code>System.arraycopy()</code>.</p>","topicName":"Core-2"},{"id":286,"questionText":"Чому в <code>ArrayList</code> зберігають окремо <code>size</code>, якщо можна використати <code>elementData.length</code>?","answer":"<p>Поле <code>elementData.length</code> відображає <strong>вмістимість (capacity)</strong> масиву, тобто максимальну кількість елементів, яку можна зберігати без збільшення масиву. Воно завжди більше або дорівнює реальній кількості елементів.</p>\n\n<p>Поле <code>size</code> відображає фактичну кількість елементів, що зберігаються в <code>ArrayList</code>. Завдяки цьому можна швидко дізнатися реальний розмір списку без додаткових перевірок.</p>\n\n<p>При необхідності <code>ArrayList</code> автоматично збільшує вмістимість масиву, але <code>size</code> залишається точною кількістю доданих елементів.</p>","topicName":"Core-2"},{"id":287,"questionText":"Чому <code>LinkedList</code> реалізує і <code>List</code>, і <code>Deque</code>?","answer":"<p><code>LinkedList</code> дозволяє додавати елементи в початок і кінець списку за константний час (<code>O(1)</code>), що повністю відповідає поведінці інтерфейсу <code>Deque</code>. Крім того, він зберігає порядок елементів і підтримує доступ за індексом, як того вимагає інтерфейс <code>List</code>. Тому реалізація обох інтерфейсів є природною для цього класу.</p>","topicName":"Core-2"},{"id":288,"questionText":"LinkedList – це однонапрямлений, двонапрямлений чи чотиринапрямлений список?","answer":"<p><strong>Двонапрямлений:</strong> кожен елемент <code>LinkedList</code> зберігає посилання на попередній і наступний елементи.</p>","topicName":"Core-2"},{"id":289,"questionText":"Як перебрати елементи <code>LinkedList</code> в зворотньому порядку, не використовуючи повільний <code>get(index)</code>?","answer":"<p>В <code>LinkedList</code> існує зворотній ітератор, який можна отримати за допомогою методу <code>descendingIterator()</code>. Це дозволяє ефективно проходити список у зворотному порядку без додаткових витрат на пошук елементів за індексом.</p>","topicName":"Core-2"},{"id":290,"questionText":"Що таке \"fail-fast поведінка\"?","answer":"<p><strong>Fail-fast поведінка</strong> означає, що при виникненні помилки або стану, який може призвести до помилки, система негайно припиняє подальшу роботу і повідомляє про це. Це дозволяє уникнути недетермінованої поведінки програми.</p>\n\n<p>У <code>Java Collections API</code> деякі ітератори ведуть себе як fail-fast і викидають <code>ConcurrentModificationException</code>, якщо після їх створення колекція була змінена без використання методів самого ітератора (наприклад, елемент доданий або видалений безпосередньо з колекції).</p>\n\n<p>Реалізація fail-fast поведінки базується на <strong>лічильнику модифікацій</strong> (modification count):</p>\n<ul>\n  <li>При зміні колекції лічильник модифікацій збільшується.</li>\n  <li>При створенні ітератора йому передається поточне значення лічильника.</li>\n  <li>При кожному звертанні до ітератора збережене значення порівнюється з поточним; якщо вони не збігаються, виникає виняток <code>ConcurrentModificationException</code>.</li>\n</ul>","topicName":"Core-2"},{"id":291,"questionText":"Яка різниця між fail-fast і fail-safe?","answer":"<p>На відміну від <strong>fail-fast</strong>, ітератори <strong>fail-safe</strong> не викликають жодних винятків при зміні структури колекції, оскільки вони працюють з <strong>клоном колекції</strong>, а не з оригіналом. Це дозволяє безпечно перебирати елементи навіть під час модифікацій колекції.</p>","topicName":"Core-2"},{"id":292,"questionText":"Приклади ітераторів, що реалізують поведінку fail-safe","answer":"<p>Ітератори, які працюють з копією колекції, не викликають винятків при її модифікації. Приклади:</p>\n<ul>\n  <li>Ітератор колекції <code>CopyOnWriteArrayList</code></li>\n  <li>Ітератор представлення <code>keySet</code> колекції <code>ConcurrentHashMap</code></li>\n</ul>","topicName":"Core-2"},{"id":293,"questionText":"Як веде себе колекція при виклику <code>iterator.remove()</code>?","answer":"<p>Якщо виклик <code>iterator.remove()</code> передував виклику <code>iterator.next()</code>, то буде викинуто <code>IllegalStateException</code>.</p>\n\n<p>Інакше, <code>iterator.remove()</code> видаляє елемент колекції, на який зараз вказує ітератор.</p>","topicName":"Core-2"},{"id":294,"questionText":"Як веде себе вже інстанційований ітератор, якщо викликати <code>collection.remove()</code>?","answer":"<p>Якщо після створення ітератора безпосередньо викликати <code>collection.remove()</code> або інші методи модифікації колекції, то при наступному звертанні до ітератора буде викинуто <code>ConcurrentModificationException</code>.</p>","topicName":"Core-2"},{"id":295,"questionText":"Як уникнути <code>ConcurrentModificationException</code> під час перебору колекції?","answer":"<ul>\n  <li>Вибрати ітератор, який працює за принципом <strong>fail-safe</strong>; наприклад, для <code>List</code> можна використовувати <code>ListIterator</code>.</li>\n  <li>Використовувати колекції, що підтримують паралельний доступ: <code>ConcurrentHashMap</code> або <code>CopyOnWriteArrayList</code>.</li>\n  <li>Перетворити список у масив і перебирати елементи масиву.</li>\n  <li>Заблокувати зміни списку під час перебору за допомогою блоку <code>synchronized</code>, хоча це може знизити продуктивність.</li>\n</ul>","topicName":"Core-2"},{"id":296,"questionText":"Як відрізняються <code>Enumeration</code> та <code>Iterator</code>?","answer":"<p>Хоча обидва інтерфейси призначені для обходу колекцій, між ними є суттєві відмінності:</p>\n<ul>\n  <li>За допомогою <code>Enumeration</code> неможливо додавати або видаляти елементи.</li>\n  <li>В <code>Iterator</code> виправлені назви методів для поліпшення читабельності коду: \n    <code>Enumeration.hasMoreElements()</code> відповідає <code>Iterator.hasNext()</code>, \n    <code>Enumeration.nextElement()</code> відповідає <code>Iterator.next()</code> і так далі.</li>\n  <li><code>Enumeration</code> присутній у застарілих класах, таких як <code>Vector</code> і <code>Stack</code>, тоді як <code>Iterator</code> використовується у всіх сучасних класах-колекціях.</li>\n</ul>","topicName":"Core-2"},{"id":297,"questionText":"Що станеться при виклику <code>Iterator.next()</code> без попереднього виклику <code>Iterator.hasNext()</code>?","answer":"<p>Якщо ітератор вже знаходиться на останньому елементі колекції або колекція порожня, викликається виняток <code>NoSuchElementException</code>. Інакше <code>Iterator.next()</code> поверне наступний елемент колекції.</p>","topicName":"Core-2"},{"id":298,"questionText":"Скільки елементів буде пропущено, якщо <code>Iterator.next()</code> викликати після 10 викликів <code>Iterator.hasNext()</code>?","answer":"<p>Жодного. Метод <code>hasNext()</code> лише перевіряє наявність наступного елемента і не просуває ітератор. Елемент буде отримано лише після виклику <code>next()</code>.</p>","topicName":"Core-2"},{"id":299,"questionText":"Як між собою пов'язані <code>Iterable</code> та <code>Iterator</code>?","answer":"<p>Інтерфейс <code>Iterable</code> має єдиний метод <code>iterator()</code>, який повертає об'єкт <code>Iterator</code>. Це дозволяє перебирати елементи колекції у циклі <code>for-each</code> або за допомогою ітератора.</p>","topicName":"Core-2"},{"id":300,"questionText":"Як між собою пов'язані <code>Iterable</code>, <code>Iterator</code> та «for-each»?","answer":"<p>Класи, які реалізують інтерфейс <code>Iterable</code>, можуть використовуватися в конструкції <code>for-each</code>. Ця конструкція автоматично отримує <code>Iterator</code> через метод <code>iterator()</code> і використовує його для перебору елементів колекції.</p>","topicName":"Core-2"},{"id":301,"questionText":"Comparator проти Comparable","answer":"<p>Інтерфейс <code>Comparable</code> є гарним вибором, коли потрібно визначити порядок за замовчуванням для об'єктів, тобто основний спосіб їх порівняння. Він дозволяє класу самостійно визначати власний природний порядок.</p>","topicName":"Core-2"},{"id":302,"questionText":"Навіщо використовувати <code>Comparator</code>, якщо вже є <code>Comparable</code>?","answer":"<p>Є кілька причин для використання <code>Comparator</code>:</p>\n<ul>\n  <li>Іноді неможливо змінити вихідний код класу, об'єкти якого потрібно відсортувати, що робить використання <code>Comparable</code> неможливим.</li>\n  <li>Використання компараторів дозволяє уникнути додавання додаткового коду в класи домену.</li>\n  <li>Можна визначити кілька різних стратегій порівняння об'єктів, чого не можна зробити з <code>Comparable</code>.</li>\n</ul>","topicName":"Core-2"},{"id":303,"questionText":"Порівняння <code>Iterator</code> та <code>ListIterator</code>","answer":"<ul>\n  <li><code>ListIterator</code> розширює інтерфейс <code>Iterator</code>.</li>\n  <li><code>ListIterator</code> може використовуватися лише для перебору елементів колекції <code>List</code>.</li>\n  <li><code>Iterator</code> дозволяє перебирати елементи лише в одному напрямку за допомогою методу <code>next()</code>, тоді як <code>ListIterator</code> дозволяє перебирати список у обох напрямках за допомогою методів <code>next()</code> і <code>previous()</code>.</li>\n  <li><code>ListIterator</code> не вказує на конкретний елемент: його поточна позиція розташована між елементами, які повертають методи <code>previous()</code> і <code>next()</code>.</li>\n  <li>За допомогою <code>ListIterator</code> можна модифікувати список, додаючи або видаляючи елементи за допомогою методів <code>add()</code> і <code>remove()</code>, тоді як <code>Iterator</code> підтримує лише <code>remove()</code>.</li>\n</ul>","topicName":"Core-2"},{"id":304,"questionText":"Чому додали <code>ArrayList</code>, якщо вже був <code>Vector</code>?","answer":"<ul>\n  <li>Методи класу <code>Vector</code> синхронізовані, тоді як <code>ArrayList</code> – ні, що підвищує продуктивність у однониткових програмах.</li>\n  <li>За замовчуванням <code>Vector</code> подвоює свій розмір при нестачі пам'яті, тоді як <code>ArrayList</code> збільшує розмір лише на половину.</li>\n  <li><code>Vector</code> – застарілий клас, і його використання не рекомендоване.</li>\n</ul>","topicName":"Core-2"},{"id":305,"questionText":"Порівняння інтерфейсів <code>Queue</code> та <code>Deque</code>","answer":"<p><strong>Queue</strong> – це черга, яка зазвичай (але не обов'язково) будується за принципом FIFO (First-In-First-Out). Вилучення елемента відбувається з початку черги, а вставка – у кінець. Наприклад, <code>PriorityQueue</code> порушує цей принцип, використовуючи natural ordering або переданий Comparator при вставці нового елемента.</p>\n\n<p><strong>Deque</strong> (Double Ended Queue) розширює <code>Queue</code> і є лінійною колекцією, яка підтримує вставку та видалення елементів з обох кінців. Реалізації <code>Deque</code> можуть працювати як за принципом FIFO, так і LIFO.</p>\n\n<p>Реалізації <code>Deque</code> та <code>Queue</code> зазвичай не перевизначають методи <code>equals()</code> і <code>hashCode()</code>, використовуючи успадковані методи класу <code>Object</code>, засновані на порівнянні посилань.</p>","topicName":"Core-2"},{"id":306,"questionText":"Що дозволяє робити <code>PriorityQueue</code>?","answer":"<p>Особливістю <code>PriorityQueue</code> є можливість керувати порядком елементів. За замовчуванням елементи сортуються за допомогою \"natural ordering\", але це можна змінити, передавши <code>Comparator</code> при створенні черги. Ця колекція не підтримує <code>null</code> як елемент.</p>\n\n<p>З <code>PriorityQueue</code> можна реалізовувати різні алгоритми, наприклад, алгоритм Дейкстри для пошуку найкоротшого шляху у графі, або зберігати об'єкти у порядку, визначеному певною властивістю.</p>","topicName":"Core-2"},{"id":307,"questionText":"Навіщо потрібен <code>HashMap</code>, якщо є <code>Hashtable</code>?","answer":"<ul>\n  <li>Методи класу <code>Hashtable</code> синхронізовані, що знижує продуктивність, тоді як <code>HashMap</code> – ні.</li>\n  <li><code>Hashtable</code> не може містити <code>null</code> ключів чи значень, тоді як <code>HashMap</code> допускає один <code>null</code> ключ і будь-яку кількість <code>null</code> значень.</li>\n  <li><code>Iterator</code> у <code>HashMap</code> працює за принципом fail-fast, на відміну від <code>Enumeration</code> у <code>Hashtable</code>, який не видає виняток при несумісності даних.</li>\n  <li><code>Hashtable</code> – застарілий клас, і його використання не рекомендоване.</li>\n</ul>","topicName":"Core-2"},{"id":308,"questionText":"Як працює <code>HashMap</code>?","answer":"<p><code>HashMap</code> організований у вигляді \"корзин\" (buckets). Технічно, корзини – це елементи масиву, які зберігають посилання на списки елементів.</p>\n\n<p>При додаванні нової пари \"ключ-значення\":</p>\n<ol>\n  <li>Обчислюється хеш-код ключа.</li>\n  <li>На основі хеш-коду визначається номер корзини (комірки масиву), куди потрапить елемент.</li>\n  <li>Якщо корзина порожня, новий елемент зберігається безпосередньо в ній.</li>\n  <li>Якщо корзина вже містить елементи, виконується перехід по ланцюгу елементів до останнього, після чого новий елемент додається в кінець ланцюга.</li>\n  <li>Якщо в ланцюгу знайдено елемент з таким самим ключем, його значення замінюється на нове.</li>\n</ol>","topicName":"Core-2"},{"id":309,"questionText":"Який метод хеш-таблиці використовується у HashMap і чому? Порівняйте його з відкритою адресацією.","answer":"<p><strong>HashMap</strong> реалізовано з використанням методу ланцюжків. Кожній комірці масиву (корзині) відповідає свій зв'язаний список, і при колізії новий елемент додається в цей список.</p>\n\n<h4>Чому обрано метод ланцюжків?</h4>\n<p>Метод ланцюжків дозволяє зберігати більше елементів, ніж кількість комірок масиву (коефіцієнт заповнення може бути >1). Продуктивність зменшується лінійно зі збільшенням елементів. Цей метод зручний, коли наперед невідомо кількість елементів або їх дуже багато.</p>\n\n<h4>Методи відкритої адресації</h4>\n<ul>\n  <li>Лінійне пробування</li>\n  <li>Квадратичне пробування</li>\n  <li>Подвійне хешування</li>\n</ul>\n\n<h4>Недоліки відкритої адресації</h4>\n<ul>\n  <li>Кількість елементів не може перевищувати розмір масиву; зі збільшенням коефіцієнта заповнення продуктивність різко падає, тому потрібне рехешування.</li>\n  <li>Складно організувати видалення елемента.</li>\n  <li>Лінійне і квадратичне пробування можуть призводити до проблем кластеризації (першої та другої групування).</li>\n</ul>\n\n<h4>Переваги відкритої адресації</h4>\n<ul>\n  <li>Відсутність витрат на створення та зберігання об'єктів списку.</li>\n  <li>Простота організації серіалізації/десеріалізації об'єкта.</li>\n</ul>","topicName":"Core-2"},{"id":310,"questionText":"Як працює HashMap при спробі збереження в ньому двох елементів з однаковими hashCode(), але для яких equals() == false?","answer":"<p>\nЗначення <code>hashCode()</code> визначає індекс комірки масиву, в список якої буде доданий цей елемент. \nПеред додаванням відбувається перевірка наявності елементів у цій комірці. \nЯкщо елементи з таким <code>hashCode()</code> вже присутні, але їхні методи <code>equals()</code> не рівні, \nто елемент буде доданий в кінець списку.\n</p>","topicName":"Core-2"},{"id":311,"questionText":"Яка початкова кількість кошиків в HashMap?","answer":"<p>\nУ конструкторі за замовчуванням кількість кошиків становить 16. \nЗа допомогою конструкторів із параметрами можна встановлювати довільну початкову кількість кошиків.\n</p>","topicName":"Core-2"},{"id":312,"questionText":"Яка оцінка часової складності операцій над елементами в HashMap?","answer":"<p>\nЧасто операції додавання, пошуку та видалення елементів виконуються за константний час O(1).\n</p>","topicName":"Core-2"},{"id":313,"questionText":"Чи гарантує HashMap зазначену складність вибірки елемента?","answer":"<p>\nВ цілому гарантій немає. Якщо хеш-функція рівномірно розподіляє елементи по кошиках, часова складність вибірки може бути не гіршою за логарифмічний час O(log(N)).  \nУ випадку, коли хеш-функція постійно повертає одне й те саме значення, HashMap перетворюється на зв'язний список із складністю O(n).\n</p>","topicName":"Core-2"},{"id":314,"questionText":"Чи можлива ситуація, коли HashMap деградується до списку навіть з ключами, які мають різні hashCode()?","answer":"<p>\nЦе можливо, якщо метод, що визначає номер кошика, повертає однакові значення для різних ключів. У такому випадку всі елементи опиняються в одному кошику і HashMap поводиться як зв'язний список.\n</p>","topicName":"Core-2"},{"id":315,"questionText":"У якому випадку може бути втрачений елемент в HashMap?","answer":"<p>\nЕлемент може бути втрачений, якщо ключ є об'єктом з кількома полями, і після додавання елемента в HashMap змінюється одне з полів, яке використовується для обчислення хеш-коду. У результаті:\n<ul>\n  <li>При пошуку за початковим ключем елемент не буде знайдений, бо equals() не збігається.</li>\n  <li>Якщо відбувається збільшення розміру кошиків і перерахунок хеш-кодів, елемент може потрапити в іншу кошик і взагалі стати недоступним.</li>\n</ul>\n</p>","topicName":"Core-2"},{"id":316,"questionText":"Чому не можна використовувати <code>byte[]</code> як ключ у HashMap?","answer":"<p>\nХеш-код масиву не залежить від його елементів, а визначається при створенні масиву за стандартним <code>Object.hashCode()</code>, тобто на основі адреси масиву. Крім того, для масивів не перевизначений метод <code>equals()</code>, тому порівнюються лише посилання на об'єкти. Через це:\n<ul>\n  <li>При спробі отримати елемент за іншим масивом з тими ж значеннями доступ неможливий.</li>\n  <li>Доступ до елемента можливий тільки якщо використовується точно та сама посилання на масив, що й при збереженні.</li>\n</ul>\n</p>","topicName":"Core-2"},{"id":317,"questionText":"Яка роль <code>equals()</code> та <code>hashCode()</code> в HashMap?","answer":"<p>\nМетод <code>hashCode()</code> визначає, у яку корзину (bucket) потрапить елемент для збереження або пошуку. <code>equals()</code> використовується для порівняння ключів елементів у списку корзини з шуканим ключем, щоб знайти точний збіг.\n</p>","topicName":"Core-2"},{"id":318,"questionText":"Яке максимальне число значень <code>hashCode()</code>?","answer":"<p>\nМетод <code>hashCode()</code> повертає значення типу <code>int</code>, тому максимальна кількість різних значень дорівнює діапазону типу <code>int</code>, тобто 2<sup>32</sup>.\n</p>","topicName":"Core-2"},{"id":319,"questionText":"Яка найгірша часова складність методу <code>get(key)</code> для ключа, який є в HashMap?","answer":"<p>\nНайгірший випадок: <code>O(N)</code>. Це трапляється, якщо HashMap деградує до зв'язаного списку через колізії ключів за <code>hashCode()</code>. У такому випадку для пошуку елемента з певним ключем може знадобитися перебір всього списку.\n</p>","topicName":"Core-2"},{"id":320,"questionText":"Скільки переходів відбувається при виклику <code>HashMap.get(key)</code> за ключем, який є в таблиці?","answer":"<p>\n<ul>\n<li><strong>Ключ дорівнює null:</strong> 1 - виконується єдиний метод <code>getForNullKey()</code>.</li>\n<li><strong>Будь-який ключ, відмінний від null:</strong> 4 переходи:\n  <ol>\n    <li>Обчислення хеш-коду ключа.</li>\n    <li>Визначення номера кошика (bucket).</li>\n    <li>Пошук значення у відповідному списку/ланцюжку.</li>\n    <li>Повернення значення.</li>\n  </ol>\n</li>\n</ul>\n</p>","topicName":"Core-2"},{"id":321,"questionText":"Скільки створюється нових об'єктів при додаванні нового елемента в HashMap?","answer":"<p>При додаванні нового елемента створюється один новий об'єкт статичного вкладеного класу <code>Entry&lt;K, V&gt;</code>.</p>\n\n\n\n\n\n\n\nAsk ChatGPT","topicName":"Core-2"},{"id":322,"questionText":"Як і коли відбувається збільшення кількості кошиків в HashMap?","answer":"<p>У HashMap, крім <code>capacity</code>, існує поле <code>loadFactor</code>, на основі якого обчислюється максимальна кількість зайнятих кошиків: <code>capacity * loadFactor</code>. За замовчуванням <code>loadFactor</code> = 0,75. Коли кількість елементів досягає цього максимуму, кількість кошиків подвоюється, і для всіх наявних елементів обчислюється нове розташування з урахуванням оновленої кількості кошиків.</p>","topicName":"Core-2"},{"id":323,"questionText":"Поясніть сенс параметрів у конструкторі HashMap(int initialCapacity, float loadFactor)","answer":"<ul>\n  <li><strong>initialCapacity</strong> – початковий розмір HashMap, тобто кількість кошиків у хеш-таблиці при її створенні.</li>\n  <li><strong>loadFactor</strong> – коефіцієнт заповнення HashMap. Якщо співвідношення числа збережених елементів до кількості кошиків перевищує цей коефіцієнт, відбувається збільшення кількості кошиків і автоматичне перехешування.</li>\n</ul>","topicName":"Core-2"},{"id":324,"questionText":"Чи буде працювати HashMap, якщо всі додані ключі матимуть однаковий hashCode()?","answer":"<p>Так, HashMap буде працювати, але в такому випадку всі елементи потраплять у одну корзину, утворюючи зв'язний список. Через це колекція втрачає свої переваги швидкого доступу за ключем, і час пошуку, додавання та видалення стає лінійним O(N).</p>","topicName":"Core-2"},{"id":325,"questionText":"Як перебрати всі ключі Map?","answer":"<p>Для перебору всіх ключів у Map використовуйте метод <code>keySet()</code>, який повертає множину <code>Set&lt;K&gt;</code> усіх ключів. Наприклад:</p>\n<pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nfor (String key : map.keySet()) {\n    System.out.println(key);\n}</code></pre>","topicName":"Core-2"},{"id":326,"questionText":"Як перебрати всі значення Map?","answer":"<p>Для перебору всіх значень у Map використовуйте метод <code>values()</code>, який повертає колекцію <code>Collection&lt;V&gt;</code> усіх значень. Наприклад:</p>\n<pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nfor (Integer value : map.values()) {\n    System.out.println(value);\n}</code></pre>","topicName":"Core-2"},{"id":327,"questionText":"Як перебрати всі пари «ключ-значення» в Map?","answer":"<p>Щоб перебрати всі пари «ключ-значення» у Map, використовуйте метод <code>entrySet()</code>, який повертає множину <code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>. Наприклад:</p>\n<pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nfor (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {\n    System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue());\n}</code></pre>","topicName":"Core-2"},{"id":328,"questionText":"Різниця між HashMap та IdentityHashMap та призначення IdentityHashMap","answer":"<p><strong>IdentityHashMap</strong> – це реалізація інтерфейсу <code>Map</code>, яка порівнює ключі та значення за посиланням (<code>==</code>), а не за методом <code>equals()</code>. Тобто два ключі <code>k1</code> і <code>k2</code> вважаються рівними тільки тоді, коли вони вказують на один і той самий об’єкт.</p>\n\n<p>Особливості та відмінності від HashMap:</p>\n<ul>\n  <li>Не використовує <code>hashCode()</code>, а застосовує <code>System.identityHashCode()</code>.</li>\n  <li>Вища продуктивність при роботі з об’єктами, для яких <code>equals()</code> або <code>hashCode()</code> повільні.</li>\n  <li>Не вимагає незмінності ключів, на відміну від HashMap.</li>\n</ul>\n\n<p>Застосування IdentityHashMap:</p>\n<ul>\n  <li>Реалізація серіалізації та клонування об’єктів, коли потрібно відстежувати вже оброблені посилання.</li>\n  <li>Сценарії, де важливо відрізняти об’єкти за їхньою унікальністю в пам’яті, навіть якщо <code>equals()</code> повертає <code>true</code>.</li>\n</ul>","topicName":"Core-2"},{"id":329,"questionText":"В чому різниця між HashMap і WeakHashMap? Для чого\nвикористовується WeakHashMap?","answer":"<p><strong>WeakHashMap</strong> – це реалізація інтерфейсу <code>Map</code>, яка використовує <strong>слабкі посилання</strong> (<code>WeakReference</code>) для зберігання ключів. Якщо для ключа більше немає сильних посилань, об’єкт може бути зібраний збирачем сміття, а відповідна пара «ключ-значення» автоматично видаляється з WeakHashMap.</p>\n\n<h4>Особливості та відмінності від HashMap:</h4>\n<ul>\n  <li>HashMap зберігає сильні посилання на ключі – ключі залишаються в колекції, поки не видалені вручну.</li>\n  <li>WeakHashMap дозволяє автоматично видаляти записи для об’єктів, на які більше немає сильних посилань.</li>\n  <li>Корисна для кешів та тимчасових асоціацій, де не потрібно утримувати об’єкти штучно.</li>\n</ul>\n\n<h4>Приклад використання:</h4>\n<p>Якщо є об’єкти, які не можна змінювати, але потрібно додати до них додаткову інформацію:</p>\n<ul>\n  <li>Об’єкт додається в WeakHashMap як ключ.</li>\n  <li>Значення містить додаткову інформацію про об’єкт.</li>\n  <li>Поки існує сильне посилання на об’єкт, можна отримати інформацію з WeakHashMap.</li>\n  <li>Коли об’єкт зникає, WeakReference ключа потрапляє у <code>ReferenceQueue</code>, і запис автоматично видаляється з WeakHashMap.</li>\n</ul>","topicName":"Core-2"},{"id":330,"questionText":"Чому у WeakHashMap використовуються WeakReferences, а не SoftReferences?","answer":"<p>WeakHashMap використовує <strong>WeakReference</strong> для ключів, щоб забезпечити негайне звільнення пам’яті, як тільки на об’єкт більше немає сильних посилань. Це дозволяє автоматично видаляти записи з мапи без очікування накопичення пам’яті.</p>\n\n<p>Якщо б використовували <strong>SoftReference</strong>, ключі та їх значення зберігалися б до тих пір, поки JVM не відчує нестачу пам’яті. Це призвело б до того, що записи могли б залишатися в пам’яті довше, ніж це потрібно, що не завжди бажано для кешів або тимчасових асоціацій.</p>\n\n<p>Варто зазначити, що <strong>SoftHashMap</strong> існує в сторонніх бібліотеках, наприклад, у <em>Apache Commons</em>, але в стандартній Java його немає.</p>","topicName":"Core-2"},{"id":331,"questionText":"Чому не створюють PhantomHashMap на основі PhantomReferences?","answer":"<p><strong>PhantomReference</strong> завжди повертає <code>null</code> при виклику методу <code>get()</code>, тому немає можливості напряму отримати об’єкт за ключем. Через це важко уявити практичне застосування мапи, де ключі представлені фантомними посиланнями.</p>\n\n<p>PhantomReferences корисні переважно для відстеження моменту остаточного видалення об’єкта збирачем сміття (наприклад, для ресурсів низького рівня), а не для зберігання доступних ключів у мапі.</p>","topicName":"Core-2"},{"id":332,"questionText":"Відмінності між TreeSet і HashSet","answer":"<ul>\n  <li><strong>TreeSet:</strong> забезпечує впорядковане зберігання елементів у вигляді червоно-чорного дерева. Основні операції (додавання, видалення, пошук) виконуються за <code>O(log(N))</code>.</li>\n  <li><strong>HashSet:</strong> базується на підході HashMap, де елемент одночасно є ключем і значенням. Не гарантує впорядкованість елементів, але операції додавання, видалення і пошуку виконуються за константний середній час, аналогічно HashMap.</li>\n</ul>","topicName":"Core-2"},{"id":333,"questionText":"Що буде, якщо додавати елементи в TreeSet за зростанням?","answer":"<p>TreeSet побудований на основі червоно-чорного дерева, яке автоматично підтримує баланс. Тому порядок додавання елементів не впливає на ефективність або властивості структури — елементи завжди залишатимуться впорядкованими, а основні операції виконуються з оптимальною складністю.</p>","topicName":"Core-2"},{"id":334,"questionText":"Чим LinkedHashSet відрізняється від HashSet?","answer":"<p>LinkedHashSet відрізняється від HashSet тим, що в його основі використовується <code>LinkedHashMap</> замість <code>HashMap</>. Це дозволяє зберігати порядок додавання елементів (insertion-order) при обході колекції. Якщо додати елемент, який вже існує в LinkedHashSet, порядок елементів при обході не змінюється.</p>","topicName":"Core-2"},{"id":335,"questionText":"Для чого потрібен EnumSet і чим він кращий за HashSet або TreeSet?","answer":"<p><strong>EnumSet</strong> – це спеціалізована реалізація інтерфейсу <code>Set</code> для роботи з переліками (<code>Enum</code>).</p>\n\n<ul>\n  <li>Зберігає об'єкти лише одного типу <code>Enum</code>, який вказується при створенні.</li>\n  <li>Для зберігання використовується <strong>масив бітів</strong> (bit vector), що забезпечує високу компактність і ефективність.</li>\n  <li>Прохід по <code>EnumSet</code> здійснюється у порядку оголошення елементів переліку.</li>\n  <li>Усі основні операції виконуються за <strong>O(1)</strong> і, як правило, швидше, ніж у <code>HashSet</code>.</li>\n  <li>Масові операції (bulk operations), такі як <code>containsAll()</code> та <code>retainAll()</code>, виконуються ще швидше.</li>\n  <li>Надає зручні статичні методи для ініціалізації екземплярів.</li>\n</ul>\n\n<p>Таким чином, авторів не влаштовували HashSet або TreeSet через більшу витратність пам'яті та нижчу ефективність при роботі з Enum.</p>","topicName":"Core-2"},{"id":336,"questionText":"LinkedHashMap – що в ньому від LinkedList, а що від HashMap?","answer":"<p><strong>LinkedHashMap</strong> поєднує в собі властивості <strong>HashMap</strong> та <strong>LinkedList</strong>:</p>\n\n<ul>\n  <li><strong>Від HashMap:</strong> зберігає пари ключ-значення у хеш-таблиці, що забезпечує швидкий доступ за ключем.</li>\n  <li><strong>Від LinkedList:</strong> підтримує двозв’язний список для відстеження порядку елементів, що дозволяє ітерувати елементи у певному порядку.</li>\n</ul>\n\n<p>За замовчуванням елементи LinkedHashMap ітеруються у порядку їх додавання (<em>insertion-order</em>).</p>\n\n<p>Якщо при створенні вказати <code>accessOrder = true</code>, порядок ітерації змінюється на <em>access-order</em>, тобто при кожному виклику <code>get()</code> або <code>put()</code> елемент переміщується в кінець списку.</p>\n\n<p>Додавання елемента з ключем, що вже існує, не змінює порядок ітерації.</p>","topicName":"Core-2"},{"id":337,"questionText":"Які особливості в NavigableSet?","answer":"<p><strong>NavigableSet</strong> – це інтерфейс, що успадковується від <strong>SortedSet</strong> і додає методи для навігації:</p>\n\n<ul>\n  <li>дозволяє знаходити найближчі співпадіння для заданого значення;</li>\n  <li>як і у SortedSet, не допускає дублікатів елементів.</li>\n</ul>","topicName":"Core-2"},{"id":338,"questionText":"Чим відрізняється процес від потоку?","answer":"<p><strong>Процес</strong> – це екземпляр програми під час виконання, незалежний об'єкт, якому виділені системні ресурси (наприклад, час процесора та пам'ять). Кожен процес працює в <strong>окремому адресному просторі</strong>, тому один процес не може отримати доступ до змінних та структур даних іншого процесу.</p>\n\n<p>Якщо процес хоче отримати доступ до ресурсів іншого, йому необхідно використовувати <strong>міжпроцесову взаємодію</strong>, таку як конвеєри, файли, канали зв'язку між комп'ютерами тощо.</p>\n\n<p>ОС створює для кожного процесу <strong>віртуальний адресний простір</strong>, до якого процес має прямий доступ. Цей простір належить процесу, містить лише його дані та перебуває під його повним контролем. Операційна система відповідає за відображення віртуального простору процесу на фізичну пам'ять.</p>\n\n<p><strong>Потік (thread)</strong> – це спосіб виконання процесу, який визначає послідовність виконання коду в межах процесу. Потоки завжди створюються в контексті якогось процесу, і вся їхня діяльність відбувається лише в його межах.</p>\n\n<p>Потоки можуть:</p>\n<ul>\n  <li>виконувати один і той же код;</li>\n  <li>опрацьовувати одні й ті ж дані;</li>\n  <li>спільно використовувати дескриптори об'єктів ядра, оскільки таблиця дескрипторів створюється на рівні процесу.</li>\n</ul>\n\n<p>Потоки витрачають значно менше ресурсів, ніж процеси, тому у ході виконання роботи вигідніше створювати додаткові потоки замість нових процесів.</p>","topicName":"Багатопотоковість"},{"id":339,"questionText":"Чим відрізняється Thread від Runnable? Коли що використовувати?","answer":"<p><strong>Thread</strong> – це клас, який є надбудовою над фізичним потоком. Він містить методи для управління потоком та його виконанням.</p>\n\n<p><strong>Runnable</strong> – це інтерфейс, який представляє абстракцію виконуваного завдання. Його головна перевага в тому, що він дозволяє відокремити логіку виконання завдання від безпосереднього управління потоком та допомагає вирішити проблему множинного наслідування.</p>\n\n<p>В обох випадках для виконання коду в потоці потрібно реалізувати метод <code>run()</code>:</p>\n<ul>\n  <li>У класі <strong>Thread</strong> можна перевизначити кілька методів, але обов'язковим є лише <code>run()</code>.</li>\n  <li>При реалізації <strong>Runnable</strong> потрібно визначити тільки метод <code>run()</code>.</li>\n</ul>\n\n<p>Рекомендації щодо використання:</p>\n<ul>\n  <li>Створювати підклас від <strong>Thread</strong> варто лише тоді, коли потрібно додати нову функціональність до потоку.</li>\n  <li>Якщо додаткові методи Thread не потрібні, краще реалізувати <strong>Runnable</strong>. Це дозволяє створюваному потоку успадковувати інший клас, відмінний від Thread.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":340,"questionText":"Що таке монітор? Як він реалізований у Java?","answer":"<p><strong>Монітор</strong> – це механізм синхронізації потоків, який забезпечує контрольований доступ до спільних (неділимо змінюваних) ресурсів.</p>\n\n<p>У Java монітор реалізований через <strong>м'ютекс</strong>, який вбудований у кожен об'єкт (клас Object). М'ютекс можна уявити як \"ідентифікатор захоплення\" об'єкта. Коли потік входить у синхронізований блок або метод об'єкта, він \"захоплює\" м'ютекс цього об'єкта. Інші потоки, які намагаються отримати доступ до того самого синхронізованого ресурсу, будуть чекати, поки м'ютекс не звільниться.</p>\n\n<p>Основні деталі реалізації монітора в Java:</p>\n<ul>\n  <li>Кожен об'єкт має власний м'ютекс.</li>\n  <li>Методи <code>synchronized</code> використовують цей м'ютекс для блокування доступу до критичної секції.</li>\n  <li>Можна синхронізувати методи або окремі блоки коду, використовуючи будь-який об'єкт як монітор.</li>\n  <li>Монітор також забезпечує механізми <code>wait()</code>, <code>notify()</code> і <code>notifyAll()</code> для управління чергою потоків, які чекають на звільнення ресурсу.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":341,"questionText":"Що таке синхронізація? Які існують способи синхронізації в Java?","answer":"<p><strong>Синхронізація</strong> – це процес контролю доступу потоків до спільних ресурсів, який дозволяє уникнути конфліктів і пошкодження стану об'єкта. У Java всі об'єкти мають вбудоване блокування (монітор), завдяки якому лише один потік може одночасно виконувати критичний код у цьому об'єкті.</p>\n\n<h4>Способи синхронізації в Java:</h4>\n\n<ol>\n  <li>\n    <strong>Системна синхронізація з використанням <code>wait()</code> / <code>notify()</code></strong><br>\n    Потік, який очікує певних умов, викликає <code>wait()</code> на об'єкті після захоплення його монітора через <code>synchronized</code>. Його виконання призупиняється. Інший потік може викликати <code>notify()</code> на тому ж об'єкті, що \"пробуджує\" очікуючий потік. <br>\n    <em>Важливо:</em> обидва методи потрібно використовувати всередині <code>synchronized</code>-блоку.\n  </li>\n\n  <li>\n    <strong>Системна синхронізація з використанням <code>join()</code></strong><br>\n    Метод <code>join()</code>, викликаний на об'єкті класу <code>Thread</code>, дозволяє поточному потоку призупинитися до завершення роботи потоку, пов'язаного з цим об'єктом.\n  </li>\n\n  <li>\n    <strong>Синхронізація з використанням класів пакета <code>java.util.concurrent.locks</code></strong><br>\n    Альтернатива базовим механізмам <code>synchronized</code>, <code>wait</code>, <code>notify</code>, <code>notifyAll</code>. Наприклад:\n    <ul>\n      <li><code>Lock</code></li>\n      <li><code>Condition</code></li>\n      <li><code>ReadWriteLock</code></li>\n    </ul>\n  </li>\n</ol>","topicName":"Багатопотоковість"},{"id":342,"questionText":"Як працюють методи <code>wait()</code>, <code>notify()</code> і <code>notifyAll()</code>?","answer":"<ul>\n  <li>\n    <strong><code>wait()</code></strong>: \n    вивільняє монітор об'єкта та переводить викликаючий потік у стан <em>очікування</em> (waiting), доки інший потік не викличе <code>notify()</code> або <code>notifyAll()</code>.\n  </li>\n  <li>\n    <strong><code>notify()</code></strong>: \n    відновлює роботу одного з потоків, який раніше викликав <code>wait()</code> на цьому об'єкті. Неможливо визначити, який саме потік буде пробуджено.\n  </li>\n  <li>\n    <strong><code>notifyAll()</code></strong>: \n    відновлює роботу всіх потоків, які чекали на виклик <code>wait()</code> цього об'єкта.\n  </li>\n</ul>\n\n<p>Коли викликається <code>wait()</code>, потік звільняє блокування на об'єкті і переходить із стану <em>running</em> у стан <em>waiting</em>. Метод <code>notify()</code> переводить один з очікуючих потоків у стан <em>runnable</em>, а <code>notifyAll()</code> — усі очікуючі потоки. Якщо на момент виклику <code>notify()</code> або <code>notifyAll()</code> жоден потік не чекає, жодних дій не відбувається.</p>\n\n<p><strong>Важливо:</strong> ці методи слід викликати лише з синхронізованого коду (<code>synchronized</code>).</p>","topicName":"Багатопотоковість"},{"id":343,"questionText":"У яких станах може знаходитися потік?","answer":"<ul>\n  <li>\n    <strong>New</strong> – об'єкт класу <code>Thread</code> створено, але він ще не запущений. Потік не виконується.\n  </li>\n  <li>\n    <strong>Runnable</strong> – потік готовий до виконання, але планувальник ще не обрав його для роботи.\n  </li>\n  <li>\n    <strong>Running</strong> – потік виконується.\n  </li>\n  <li>\n    <strong>Waiting / Blocked / Sleeping</strong> – потік тимчасово заблокований або чекає завершення роботи іншого потоку.\n  </li>\n  <li>\n    <strong>Dead</strong> – потік завершено. Спроба викликати <code>start()</code> для такого потоку призведе до винятку.\n  </li>\n</ul>","topicName":"Багатопотоковість"},{"id":344,"questionText":"Що таке семафор? Як його реалізовано в Java?","answer":"<p>\n  <strong>Semaphore</strong> – це тип синхронізатора з лічильником, який реалізує шаблон \"Семафор\". \n  Він контролює доступ до обмежених ресурсів.\n</p>\n\n<p>\n  <strong>Принцип роботи:</strong>\n  <ul>\n    <li>Початкове значення лічильника встановлюється в конструкторі при створенні семафора.</li>\n    <li>Коли потік входить у захищений блок коду, лічильник зменшується на 1.</li>\n    <li>Коли потік виходить із блоку, лічильник збільшується на 1.</li>\n    <li>Якщо лічильник дорівнює 0, потік блокується до тих пір, поки інший потік не звільнить ресурс.</li>\n  </ul>\n</p>\n\n<p>\n  <strong>Застосування:</strong> Semaphore використовується для захисту дорогих ресурсів, доступних у обмеженій кількості, наприклад, підключень до бази даних у пулі.\n</p>","topicName":"Багатопотоковість"},{"id":345,"questionText":"Що означає ключове слово <code>volatile</code>? Чому операції над <code>volatile</code> змінними не є атомарними?","answer":"<p>\n  <strong>volatile</strong> – це модифікатор змінної, який гарантує, що всі потоки бачать актуальне значення цієї змінної, \n  уникаючи кешування або переупорядкування операцій компілятором чи процесором.\n</p>\n\n<p>\n  <strong>Особливості:</strong>\n  <ul>\n    <li>Читання та запис <code>volatile</code> змінної є атомарними для простих типів (int, boolean тощо).</li>\n    <li>Складні операції, наприклад <code>i++</code>, не є атомарними: відбувається послідовність дій \n      (читання → зміна → запис), і інший потік може втрутитися між цими кроками.</li>\n    <li>Атомарна операція виглядає як єдина і нероздільна команда процесора.</li>\n  </ul>\n</p>\n\n<p>\n  <strong>Додатково:</strong> <code>volatile</code> змінна зберігається в хіпі, а не в кеші стека, що забезпечує видимість змін між потоками.\n</p>","topicName":"Багатопотоковість"},{"id":346,"questionText":"Для чого потрібні атомарні типи даних (Atomic)? Чим вони відрізняються від <code>volatile</code>?","answer":"<p>\n  <strong>Проблема volatile:</strong> модифікатор <code>volatile</code> забезпечує видимість змін між потоками, \n  але не гарантує атомарність складних операцій. Наприклад, <code>count++</code> не стає атомарним, навіть якщо <code>count</code> оголошена <code>volatile</code>.\n</p>\n\n<p>\n  <strong>Рішення – атомарні типи:</strong> класи з пакета <code>java.util.concurrent.atomic</code>, такі як <code>AtomicInteger</code>, \n  надають атомарні методи для складних операцій. Наприклад:\n  <ul>\n    <li><code>getAndIncrement()</code> – атомарний інкремент значення.</li>\n    <li>Існують аналогічні атомарні версії для <code>long</code>, <code>boolean</code> та інших типів.</li>\n  </ul>\n</p>\n\n<p>\n  <strong>Відмінність від volatile:</strong> volatile забезпечує видимість, а атомарні типи забезпечують і видимість, і атомарність операцій. \n  Можна уявити їх як \"обгортку\" над примітивами з додатковими атомарними методами.\n</p>","topicName":"Багатопотоковість"},{"id":347,"questionText":"Що таке потоки-демони? Для чого вони потрібні? Як їх створити?","answer":"<p>\n  <strong>Потоки-демони</strong> – це потоки, які працюють у фоновому режимі разом із програмою, \n  але не є її обов'язковою частиною. Вони виконують допоміжні завдання для основних потоків.\n</p>\n\n<p>\n  <strong>Особливості:</strong>\n  <ul>\n    <li>Якщо всі звичайні потоки завершуються, JVM автоматично зупиняє всі потоки-демони.</li>\n    <li>Потік-демон можна зробити лише до його запуску.</li>\n  </ul>\n</p>\n\n<p>\n  <strong>Методи:</strong>\n  <ul>\n    <li><code>setDaemon(true)</code> – робить потік демоном (необхідно викликати до <code>start()</code>).</li>\n    <li><code>isDaemon()</code> – перевіряє, чи є потік демоном.</li>\n  </ul>\n</p>\n\n<p>\n  <strong>Приклад використання:</strong> збирач сміття (Garbage Collector) працює як демон у JVM, обслуговуючи основні потоки.\n</p>","topicName":"Багатопотоковість"},{"id":348,"questionText":"Що таке пріоритет потоку? На що він впливає? Який пріоритет у потоків за замовчуванням?","answer":"<p>\n  <strong>Пріоритет потоку</strong> визначає, як планувальник потоків у JVM розподіляє час процесора між потоками. \n  Потоки з вищим пріоритетом теоретично отримують більше процесорного часу, ніж потоки з нижчим пріоритетом. \n  Практично обсяг часу процесора залежить і від інших факторів, крім пріоритету.\n</p>\n\n<p>\n  <strong>Встановлення пріоритету:</strong>\n  <ul>\n    <li><code>setPriority(int level)</code> – встановлює пріоритет потоку. Значення <code>level</code> від 1 до 10.</li>\n    <li>Thread.MIN_PRIORITY = 1</li>\n    <li>Thread.NORM_PRIORITY = 5 (за замовчуванням)</li>\n    <li>Thread.MAX_PRIORITY = 10</li>\n    <li><code>getPriority()</code> – повертає поточний пріоритет потоку.</li>\n  </ul>\n</p>\n\n<p>\n  <strong>Метод yield():</strong> дозволяє потоку поступитися процесорним часом іншому потоку, який чекає на виконання.\n</p>","topicName":"Багатопотоковість"},{"id":349,"questionText":"Як працює Thread.join()? На що він потрібен?","answer":"<p>\n  Метод <code>join()</code> дозволяє одному потоку чекати завершення іншого потоку. \n  Потік, який викликає <code>join()</code>, призупиняє своє виконання до тих пір, \n  поки потік, до якого він приєднується, не завершиться або не мине вказаний час очікування.\n</p>\n\n<p><strong>Варіанти методу:</strong></p>\n<ul>\n  <li><code>void join()</code> – чекає до завершення потоку.</li>\n  <li><code>void join(long millis)</code> – чекає максимум <code>millis</code> мілісекунд.</li>\n  <li><code>void join(long millis, int nanos)</code> – чекає <code>millis</code> мілісекунд та <code>nanos</code> наносекунд.</li>\n</ul>\n\n<p><strong>Застосування:</strong> використовується для синхронізації потоків, коли потрібно дочекатися результатів паралельних обчислень, щоб зібрати їх разом і продовжити виконання.</p>","topicName":"Багатопотоковість"},{"id":350,"questionText":"Чим відрізняються методи <code>wait()</code> і <code>sleep()</code>?","answer":"<p><strong>Метод <code>sleep()</code>:</strong></p>\n<ul>\n  <li>Призупиняє виконання потоку на вказаний час.</li>\n  <li>Стан потоку змінюється на <code>WAITING</code>, після завершення очікування повертається в стан <code>RUNNABLE</code>.</li>\n  <li>Монітор об'єкта не вивільняється.</li>\n</ul>\n\n<p><strong>Метод <code>wait()</code>:</strong></p>\n<ul>\n  <li>Переводить потік у стан <code>WAITING</code> до виклику <code>notify()</code> або <code>notifyAll()</code>.</li>\n  <li>Може бути викликаний лише для об'єкта, на якому володієте блокуванням (синхронізованого об'єкта).</li>\n  <li>Якщо викликати без синхронізованого монітора, виникає виняток <code>IllegalMonitorStateException</code>.</li>\n  <li>Вивільняє монітор об'єкта під час очікування.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":351,"questionText":"Чи можна викликати <code>start()</code> для одного потоку двічі?","answer":"<p>Неможливо запустити один і той самий потік більше одного разу. Після завершення виконання потік не можна перезапустити.</p>\n\n<p>Спроба повторного виклику <code>start()</code> призведе до винятку <code>IllegalThreadStateException</code>.</p>","topicName":"Багатопотоковість"},{"id":352,"questionText":"Як правильно зупинити потік? Методи <code>stop()</code>, <code>interrupt()</code>, <code>interrupted()</code>, <code>isInterrupted()</code>","answer":"<p>У Java застарілі методи <code>stop()</code>, <code>suspend()</code> і <code>resume()</code> визнані небезпечними через ризик взаємного блокування. Сьогодні використовується підхід з «уведомленням» потоку про зупинку.</p>\n\n<h4>1. Використання <code>interrupt()</code></h4>\n<ul>\n  <li>Метод <code>interrupt()</code> встановлює прапорець переривання потоку.</li>\n  <li>Перевірка прапорця можлива через <code>isInterrupted()</code> (для будь-якого потоку) або <code>Thread.interrupted()</code> (для поточного потоку).</li>\n  <li>Якщо потік знаходиться в стані <code>sleep()</code> або <code>wait()</code>, виклик <code>interrupt()</code> призведе до викидання <code>InterruptedException</code> і вивільнення монітора або сну.</li>\n  <li>Схема дії:\n    <ol>\n      <li>Періодично перевіряти стан прапорця через <code>isInterrupted()</code>.</li>\n      <li>Якщо прапорець встановлений або спіймано <code>InterruptedException</code>, вирішити, чи завершити роботу потоку, або продовжити.</li>\n    </ol>\n  </li>\n  <li>Можлива проблема: блокування на I/O. Якщо потік чекає на читання даних, <code>interrupt()</code> може не спрацювати. Рішення: використовувати неблокуючий I/O (Java NIO) або очікувати завершення методу read().</li>\n</ul>\n\n<h4>2. Використання власних прапорців для зупинки</h4>\n<ul>\n  <li>Оголосити в класі потоку прапорець, наприклад <code>volatile boolean stopFlag</code>.</li>\n  <li>Ззовні встановлювати прапорець через спеціальний метод, наприклад <code>requestStop()</code>.</li>\n  <li>У коді потоку періодично перевіряти прапорець і завершувати роботу при необхідності.</li>\n  <li>Недоліки:\n    <ul>\n      <li>Потоки в стані очікування не «оживити» без <code>interrupt()</code>.</li>\n      <li>Потрібно оголосити прапорець як <code>volatile</code>, щоб зміни були видимі для всіх потоків.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>Методи <code>stop()</code>, <code>interrupt()</code>, <code>interrupted()</code> та <code>isInterrupted()</code> служать для безпечного керування завершенням потоків.</p>","topicName":"Багатопотоковість"},{"id":353,"questionText":"Чому не рекомендується використовувати метод <code>Thread.stop()</code>?","answer":"<p>Метод <code>stop()</code> примусово зупиняє потік у будь-якому місці виконання, що створює низку проблем:</p>\n\n<ul>\n  <li><strong>Невизначене завершення роботи:</strong> потік може бути зупинений посеред обробки ресурсу, наприклад, мережевого з'єднання або файлу. Невідомо, що робити з незавершеними даними.</li>\n  <li><strong>Порушення цілісності системи:</strong> якщо потік блокує загальнодоступний ресурс, примусове зняття блокування може призвести до неконсистентного стану програми.</li>\n  <li><strong>Небезпека для транзакцій:</strong> у випадку роботи з базою даних потік може бути зупинений посеред транзакції. Хто закриє транзакцію та звільнить ресурси? Це залишає систему у невизначеному стані.</li>\n  <li><strong>Важко передбачити наслідки:</strong> після примусової зупинки неможливо гарантувати, що подальше продовження або повторний запуск потоку пройде коректно.</li>\n</ul>\n\n<p>Через ці ризики метод <code>stop()</code> вважається застарілим і небезпечним. Замість нього рекомендується використовувати <code>interrupt()</code> та контрольні прапорці для безпечного завершення потоків.</p>","topicName":"Багатопотоковість"},{"id":354,"questionText":"Різниця між <code>interrupted()</code> та <code>isInterrupted()</code>","answer":"<p>У Java механізм переривання потоку реалізовано через внутрішній прапорець, що називається <strong>статус переривання</strong>. Він встановлюється методом <code>Thread.interrupt()</code>. Перевірка цього статусу може здійснюватися двома способами:</p>\n\n<ul>\n  <li><strong>Thread.interrupted() (статичний метод):</strong> перевіряє, чи був потік перерваний, і <em>скидає прапорець переривання</em>. Тобто після виклику статус переривання стає false.</li>\n  <li><strong>isInterrupted() (нестатичний метод):</strong> перевіряє статус переривання потоку, <em>не змінюючи прапорець</em>. Використовується, коли потрібно дізнатися стан іншого потоку без його впливу.</li>\n</ul>\n\n<p>Отже, основна різниця полягає в тому, що <code>interrupted()</code> очищає прапорець переривання, а <code>isInterrupted()</code> – ні.</p>","topicName":"Багатопотоковість"},{"id":355,"questionText":"Відмінності між <code>Runnable</code> та <code>Callable</code>","answer":"<ul>\n  <li><strong>Історія:</strong> <code>Runnable</code> з'явився в Java 1.0, а <code>Callable</code> – у Java 5.0 (пакет <code>java.util.concurrent</code>).</li>\n  <li><strong>Методи:</strong> <code>Runnable</code> реалізує метод <code>run()</code>, <code>Callable</code> – метод <code>call()</code>.</li>\n  <li><strong>Повернення значення:</strong> <code>Runnable.run()</code> нічого не повертає, тоді як <code>Callable.call()</code> повертає результат (Object або заданий тип).</li>\n  <li><strong>Викидання виключень:</strong> <code>run()</code> не може викидати перевірені (checked) виключення, а <code>call()</code> може.</li>\n  <li><strong>Параметризація:</strong> <code>Callable</code> є параметризованим функціональним інтерфейсом, що дозволяє повертати конкретний тип даних.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":356,"questionText":"Що таке <code>FutureTask</code>?","answer":"<p><code>FutureTask</code> – це клас для організації асинхронних обчислень у паралельному потоці. Він реалізує інтерфейс <code>Future</code> і надає:</p>\n\n<ul>\n  <li>Методи для запуску та зупинки обчислення.</li>\n  <li>Методи для перевірки стану обчислення.</li>\n  <li>Методи для отримання результату обчислення після завершення.</li>\n</ul>\n\n<p>Таким чином, <code>FutureTask</code> дозволяє виконувати завдання в окремому потоці і контролювати його виконання з іншого потоку.</p>","topicName":"Багатопотоковість"},{"id":357,"questionText":"Особливості роботи <code>FutureTask</code>","answer":"<p>Результат обчислення можна отримати лише після його завершення. Якщо обчислення ще не завершене, метод для отримання результату (<code>get()</code>) буде блокувати потік до завершення обчислення.</p>\n\n<p><code>FutureTask</code> може обгортати як об'єкти <code>Callable</code>, так і <code>Runnable</code>. Оскільки <code>FutureTask</code> реалізує інтерфейс <code>Runnable</code> разом з <code>Future</code>, його можна передавати виконавцю (<code>Executor</code>) для виконання в окремому потоці.</p>","topicName":"Багатопотоковість"},{"id":358,"questionText":"Що таке взаємна блокування (deadlock)?","answer":"<p>Взаємне блокування (deadlock) – це ситуація, коли всі потоки програми перебувають у стані очікування і не можуть продовжити виконання. Воно виникає за наявності одночасно таких умов:</p>\n\n<ul>\n  <li><strong>Взаємне виключення:</strong> принаймні один ресурс може використовувати лише один потік одночасно.</li>\n  <li><strong>Утримання та очікування:</strong> потік утримує хоча б один ресурс і очікує на інші ресурси, зайняті іншими потоками.</li>\n  <li><strong>Відсутність попередньої очистки:</strong> операційна система не примушує потоки звільняти ресурси; потоки повинні віддавати їх добровільно.</li>\n  <li><strong>Циклічне очікування:</strong> потік чекає на ресурс, зайнятий іншим потоком, який у свою чергу очікує ресурс, заблокований першим потоком.</li>\n</ul>\n\n<p>Найпростіший спосіб уникнути deadlock – не допускати циклічного очікування. Це можна зробити, отримуючи монітори спільних ресурсів у певному порядку та звільняючи їх у зворотному порядку.</p>","topicName":"Багатопотоковість"},{"id":359,"questionText":"Що таке livelock?","answer":"<p>Livelock – це тип взаємного блокування, при якому кілька потоків виконують марну роботу, опиняючись у циклі при спробі отримати ресурси. Стани потоків постійно змінюються залежно один від одного, фактичної помилки не виникає, але ефективність системи падає до 0. Часто виникає як наслідок спроб уникнути deadlock.</p>\n\n<p>Виявити livelock можна, наприклад, перевіривши рівень завантаження процесора у стані спокою.</p>\n\n<p>Приклади livelock:</p>\n<ul>\n  <li>Дві людини зустрічаються у вузькому коридорі і, намагаючись бути ввічливими, постійно відходять в сторону, рухаючись з боку в бік без просування вперед.</li>\n  <li>Два робот-пилососи у вузькому коридорі намагаються визначити, хто перший прибере одну і ту ж ділянку.</li>\n  <li>На рівноправному перехресті чотири автомобілі не можуть визначити, хто повинен поступитися дорогою.</li>\n  <li>Одночасний дзвінок двох людей один одному, коли обидва намагаються говорити одночасно.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":360,"questionText":"Що таке гонка стану (race condition)?","answer":"<p><strong>Гонка стану (Race Condition)</strong> – це помилка проектування багатопотокової системи або додатка, при якій робота залежить від порядку виконання потоків. Виникає, коли потік, який мав виконатися першим, програє \"гонку\", і інший потік виконується раніше. Це змінює поведінку коду та призводить до недетермінованих помилок.</p>\n\n<p><strong>Гонка даних (Data Race)</strong> – це властивість виконання програми. Згідно з Java Memory Model (JMM), виконання містить гонку даних, якщо є принаймні два конфліктні доступи (читання або запис однієї й тієї ж змінної), які не впорядковані відносинами \"відбулося до\".</p>\n\n<p><strong>Голодування (Starvation)</strong> – стан, коли потоки не заблоковані, але через нестачу ресурсів вони не можуть виконувати роботу.</p>\n\n<p><strong>Рішення проблеми:</strong></p>\n<ul>\n  <li>Копіювання змінної в локальну змінну для потоку.</li>\n  <li>Синхронізація потоків за допомогою synchronized-блоків або методів.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":361,"questionText":"Що таке фреймворк Fork/Join? Для чого він потрібен?","answer":"<p><strong>Fork/Join</strong> – це фреймворк, представлений у JDK 7, який дозволяє ефективно використовувати багатоядерні процесори для паралельного виконання завдань. Він призначений для роботи з завданнями, які можна рекурсивно розділити на менші підзадачі, що виконуються одночасно.</p>\n\n<h4>Етапи роботи Fork/Join:</h4>\n<ul>\n  <li><strong>Fork:</strong> велике завдання розбивається на менші підзадачі, які також можуть ділитися далі, поки завдання не стане простим для послідовного виконання.</li>\n  <li><strong>Join:</strong> після завершення підзадач відбувається об'єднання результатів, поки не буде отримано кінцевий результат всього завдання. Для деяких завдань Join може бути не потрібен (наприклад, при паралельному QuickSort Join все одно використовується, щоб дочекатися завершення всіх підзадач).</li>\n</ul>\n\n<h4>Переваги фреймворка:</h4>\n<ul>\n  <li>Виконання підзадач паралельно, що прискорює обробку великих завдань.</li>\n  <li>Використання алгоритму <strong>work-stealing</strong>: потоки, які закінчили свої підзадачі, можуть «позичати» підзадачі у інших потоків, що підвищує ефективність.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":362,"questionText":"Що означає ключове слово <code>synchronized</code>? Де і для чого може використовуватися?","answer":"<p><code>synchronized</code> – це зарезервоване слово в Java, яке дозволяє досягати синхронізації потоків у позначених методах або блоках коду. Використовується для захисту критичних секцій, щоб лише один потік одночасно мав доступ до спільних ресурсів.</p>","topicName":"Багатопотоковість"},{"id":363,"questionText":"Що є монітором у статичного <code>synchronized</code>-метода?","answer":"<p>У випадку статичного <code>synchronized</code>-метода монітором виступає об'єкт типу <code>Class</code>, що відповідає класу, у якому визначено цей метод.</p>","topicName":"Багатопотоковість"},{"id":364,"questionText":"Що є монітором у нестатичного <code>synchronized</code>-метода?","answer":"<p>У випадку нестатичного <code>synchronized</code>-метода монітором виступає об'єкт <code>this</code>, тобто екземпляр класу, для якого виконується метод.</p>","topicName":"Багатопотоковість"},{"id":365,"questionText":"Розкажіть про бібліотека <code>java.util.concurrent</code>","answer":"<p>Бібліотека <code>java.util.concurrent</code> складається з класів і інтерфейсів, об'єднаних за функціональним призначенням:</p>\n\n<h4>Collections</h4>\n<p>Набір колекцій, які ефективно працюють у багатопоточному середовищі, наприклад, <code>CopyOnWriteArrayList</code>, <code>CopyOnWriteArraySet</code> та <code>ConcurrentHashMap</code>.</p>\n<ul>\n  <li>Ітератори цих колекцій представляють дані на певний момент часу.</li>\n  <li>Модифікації (додавання, видалення, заміна) створюють нову копію внутрішнього масиву, що запобігає <code>ConcurrentModificationException</code> під час ітерації.</li>\n</ul>\n<p><strong>CopyOnWriteArrayList:</strong></p>\n<ul>\n  <li>Використовує <code>volatile</code> масив всередині.</li>\n  <li>Блокування тільки під час модифікацій, що робить читання дуже швидким.</li>\n  <li>Нова копія масиву створюється при зміні.</li>\n  <li>Fail-fast ітератор.</li>\n  <li>Модифікація через ітератор неможлива – <code>UnsupportedOperationException</code>.</li>\n</ul>\n<p><strong>ConcurrentHashMap:</strong> блокує лише сегмент, у якому відбувається модифікація, не блокуючи інші сегменти.</p>\n\n<h4>Synchronizers</h4>\n<p>Об'єкти синхронізації для керування роботою кількох потоків:</p>\n<ul>\n  <li><strong>Semaphore</strong> – управління доступом до ресурсів за допомогою лічильника.</li>\n  <li><strong>CountDownLatch</strong> – блокує потоки, доки лічильник не зменшиться до нуля. Одноразовий.</li>\n  <li><strong>CyclicBarrier</strong> – зупиняє потоки на бар'єрі, чекаючи всіх учасників. Може використовуватися повторно.</li>\n  <li><strong>Exchanger</strong> – двосторонній обмін даними між двома потоками. Підтримує <code>null</code> як значення.</li>\n  <li><strong>Phaser</strong> – багатофазна синхронізація, де кількість учасників на фазу може змінюватися.</li>\n</ul>\n\n<h4>Atomic</h4>\n<p>Набір класів для виконання атомарних операцій над числами та об'єктами.</p>\n\n<h4>Queues</h4>\n<p>Містить блокуючі та неблокуючі черги для багатопоточних додатків:</p>\n<ul>\n  <li>Неблокуючі черги – орієнтовані на швидкість.</li>\n  <li>Блокуючі черги – призупиняють потоки під час очікування елементів.</li>\n</ul>\n\n<h4>Locks</h4>\n<p>Альтернатива <code>synchronized</code>, <code>wait</code>, <code>notify</code>, <code>notifyAll</code>:</p>\n<ul>\n  <li>Lock</li>\n  <li>Condition</li>\n  <li>ReadWriteLock</li>\n</ul>\n\n<h4>Executors</h4>\n<p>Інструменти для управління потоковими завданнями з можливістю отримання результатів через <code>Future</code> та <code>Callable</code>:</p>\n<ul>\n  <li><strong>Executor</strong> – інтерфейс з методом <code>void execute(Runnable thread)</code>.</li>\n  <li><strong>ExecutorService</strong> – альтернатива <code>Thread</code> для керування потоками.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":366,"questionText":"Stream API та ForkJoinPool: яка зв'язок та що це таке?","answer":"<p><strong>Stream API</strong> дозволяє легко виконувати паралельні обчислення за допомогою методів <code>parallel()</code> або <code>parallelStream()</code>, що дає приріст продуктивності на багатоядерних машинах.</p>\n\n<p>За замовчуванням паралельні потоки використовують <strong>ForkJoinPool.commonPool</strong>. Цей пул:</p>\n<ul>\n  <li>Створюється статично і існує до виклику <code>System.exit()</code>;</li>\n  <li>Використовується для виконання паралельних завдань, якщо не вказано конкретний пул;</li>\n  <li>Розмір пулу за замовчуванням дорівнює кількості доступних ядер мінус 1.</li>\n</ul>\n\n<p>Коли потік відправляє завдання в commonPool, пул може використовувати викликаючий потік (caller-thread) як робочий. ForkJoinPool намагається максимально завантажити потік-викликаючий своїми завданнями, щоб підвищити ефективність паралельного виконання.</p>","topicName":"Багатопотоковість"},{"id":367,"questionText":"Опишіть, як працює Java Memory Model і як synchronized, volatile та final впливають на видимість та порядок операцій у потоках.","answer":"<p>Модель пам'яті Java описує, як потоки взаємодіють через загальну пам'ять і визначає набір дій міжпотокової взаємодії. До таких дій належать:</p>\n<ul>\n  <li>читання та запис змінної;</li>\n  <li>захоплення та вивільнення монітора;</li>\n  <li>читання та запис <code>volatile</code> змінної;</li>\n  <li>запуск нового потоку.</li>\n</ul>\n\n<p>JMM визначає відношення між цими діями, відоме як <strong>\"відбулося перед\" (happens-before)</strong>. Якщо операція X відбувається перед операцією Y, то всі зміни, внесені до X, будуть видимі у Y.</p>\n\n<h4>Основні аспекти моделі пам'яті:</h4>\n\n<h5>1. Видимість (Visibility)</h5>\n<p>Один потік може тимчасово зберігати значення полів у регістрах або локальному кеші, не в основній пам'яті. Інший потік, читаючи з основної пам'яті, може не побачити останніх змін. Ключові слова Java, що впливають на видимість: <code>synchronized</code>, <code>volatile</code>, <code>final</code>.</p>\n\n<h5>2. Переупорядкування (Reordering)</h5>\n<p>Для підвищення продуктивності процесор або компілятор можуть змінювати порядок виконання деяких інструкцій. Наприклад, один потік може записати результат першої операції у регістр або кеш, а результат другої операції – у основну пам'ять. Інший потік може побачити результат другої операції перед першою, доки кеш не синхронізується з основною пам'яттю.</p>\n\n<p>Правила \"відбулося перед\" регулюють переупорядкування:</p>\n<ul>\n  <li>операції читання та запису <code>volatile</code> змінних не можуть бути переупорядковані відносно операцій читання/запису інших <code>volatile</code> або звичайних змінних.</li>\n</ul>","topicName":"Багатопотоковість"},{"id":368,"questionText":"Що таке DDL? Які операції входять до нього?","answer":"<p>DDL (Data Definition Language) – оператори визначення даних, які використовуються для створення та управління об'єктами бази даних.</p>\n\n<ul>\n  <li><strong>CREATE</strong> – створює об'єкт бази даних (базу, таблицю, представлення, користувача тощо).</li>\n  <li><strong>ALTER</strong> – змінює існуючий об'єкт бази даних.</li>\n  <li><strong>DROP</strong> – видаляє об'єкт бази даних.</li>\n  <li><strong>TRUNCATE</strong> – видаляє всі записи в таблиці та створює її порожньою. \n      Якщо в таблиці існують <em>foreign key</em>, створити таблицю не вдасться. Після виконання <code>TRUNCATE</code> rollback неможливий.</li>\n</ul>","topicName":"SQL"},{"id":369,"questionText":"Що таке DML? Які операції входять до нього?","answer":"<p>DML (Data Manipulation Language) – оператори маніпуляції даними, які використовуються для роботи з даними в базі даних.</p>\n\n<ul>\n  <li><strong>SELECT</strong> – вибирає дані, які відповідають заданим умовам.</li>\n  <li><strong>INSERT</strong> – додає нові дані в таблицю.</li>\n  <li><strong>UPDATE</strong> – змінює існуючі дані.</li>\n  <li><strong>DELETE</strong> – видаляє дані при виконанні умови <code>WHERE</code>.</li>\n</ul>","topicName":"SQL"},{"id":370,"questionText":"Що таке TCL? Які операції входять до нього?","answer":"<p>TCL (Transaction Control Language) – оператори управління транзакціями, які дозволяють контролювати зміни в базі даних у межах транзакцій.</p>\n\n<ul>\n  <li><strong>BEGIN</strong> – визначає початок транзакції.</li>\n  <li><strong>COMMIT</strong> – застосовує транзакцію та зберігає зміни.</li>\n  <li><strong>ROLLBACK</strong> – відкатує всі зміни, зроблені в контексті поточної транзакції.</li>\n  <li><strong>SAVEPOINT</strong> – розбиває транзакцію на більш дрібні частини, дозволяючи відкотитися до певної точки.</li>\n</ul>","topicName":"SQL"},{"id":371,"questionText":"Що таке DCL? Які операції входять до нього?","answer":"<p>DCL (Data Control Language) – оператори визначення доступу до даних, які дозволяють керувати правами користувачів у базі даних.</p>\n\n<ul>\n  <li><strong>GRANT</strong> – надає користувачеві або групі дозволи на виконання певних операцій з об'єктом бази даних.</li>\n  <li><strong>REVOKE</strong> – відкликає раніше надані дозволи.</li>\n  <li><strong>DENY</strong> – встановлює заборону на операції, яка має пріоритет над наданими дозволами.</li>\n</ul>","topicName":"SQL"},{"id":372,"questionText":"Які існують нюанси роботи з NULL в SQL ?","answer":"<p><strong>NULL</strong> – спеціальне значення, яке означає «порожнє поле» або відсутність значення в полі таблиці бази даних. NULL не належить жодному типу даних і не є значенням у повному сенсі слова. Тому:</p>\n\n<ul>\n  <li>NULL ≠ FALSE</li>\n  <li>NULL ≠ порожній рядок</li>\n  <li>NULL ≠ 0</li>\n  <li>NULL ≠ NULL</li>\n</ul>\n\n<p>При порівнянні NULL з будь-яким значенням результатом буде NULL, а не TRUE або FALSE.</p>\n\n<h3>Перевірка поля на NULL:</h3>\n<ul>\n  <li><strong>IS NULL</strong> – перевіряє, чи містить поле значення NULL.</li>\n  <li><strong>IS NOT NULL</strong> – перевіряє, чи не містить поле значення NULL.</li>\n</ul>","topicName":"SQL"},{"id":373,"questionText":"Що таке JOIN’и в SQL?","answer":"<p><strong>JOIN</strong> – оператор SQL, який реалізує операцію з'єднання реляційної алгебри. Він дозволяє об’єднувати дані з двох (або більше) таблиць в один результативний набір.</p>\n\n<h3>Особливості JOIN:</h3>\n<ul>\n  <li>Схема результативної таблиці включає стовпці обох таблиць-операндів, тобто це \"зціплення\" їхніх схем.</li>\n  <li>Кожен рядок результату є поєднанням рядка однієї таблиці з рядком другої таблиці.</li>\n  <li>Для з’єднання більше ніж двох таблиць, операція JOIN застосовується послідовно декілька разів.</li>\n</ul>\n\n<h3>Синтаксис:</h3>\n<pre>\nSELECT field_name [, ...n]\nFROM Table1\n{INNER | {LEFT | RIGHT | FULL} OUTER | CROSS} JOIN Table2\n{ON &lt;condition&gt; | USING (field_name [, ...n])}\n</pre>","topicName":"SQL"},{"id":374,"questionText":"Які існують типи JOIN?","answer":"<ul>\n  <li>\n    <strong>(INNER) JOIN:</strong> Повертає записи, які спільні для лівої та правої таблиць. \n    Порядок таблиць не важливий, оскільки оператор симетричний.\n  </li>\n  <li>\n    <strong>LEFT (OUTER) JOIN:</strong> Вибирає всі записи з лівої таблиці та відповідні записи з правої. \n    Якщо записів у правій таблиці немає, підставляється <code>NULL</code>. \n    Порядок таблиць важливий, оператор несиметричний.\n  </li>\n  <li>\n    <strong>RIGHT (OUTER) JOIN:</strong> Аналогічно LEFT JOIN, але з ролями таблиць навпаки. \n    Порядок таблиць важливий, оператор несиметричний.\n  </li>\n  <li>\n    <strong>FULL (OUTER) JOIN:</strong> Повертає всі записи з обох таблиць, включаючи ті, які не мають відповідностей. \n    Порядок таблиць не важливий, оператор симетричний.\n  </li>\n  <li>\n    <strong>CROSS JOIN (декартовий добуток):</strong> Кожен рядок однієї таблиці об'єднується з кожним рядком другої, утворюючи всі можливі комбінації. \n    Порядок таблиць не важливий, оператор симетричний.\n  </li>\n</ul>","topicName":"SQL"},{"id":375,"questionText":"Що краще використовувати – JOIN чи підзапити?","answer":"<p>Зазвичай краще використовувати <strong>JOIN</strong>, оскільки:</p>\n<ul>\n  <li>В більшості випадків JOIN зрозуміліший і легший для читання.</li>\n  <li>База даних зазвичай оптимізує JOIN ефективніше, хоча це не гарантується на 100%.</li>\n  <li>JOIN особливо зручний, коли в SELECT потрібно вибрати стовпці з кількох таблиць.</li>\n</ul>\n\n<p>Підзапити варто використовувати, коли:</p>\n<ul>\n  <li>Потрібно обчислювати агрегатні значення та використовувати їх у зовнішніх запитах для порівняння.</li>\n</ul>","topicName":"SQL"},{"id":376,"questionText":"Що робить UNION?","answer":"<p>У мові SQL <strong>UNION</strong> використовується для об'єднання результатів двох SQL-запитів у єдину таблицю з подібними записами. Важливо, щоб обидва запити повертали однакову кількість стовпців і сумісні типи даних у відповідних стовпцях.</p>\n\n<p>Особливості роботи UNION:</p>\n<ul>\n  <li>Порядок записів у результаті не гарантується. Записи другого запиту можуть з'явитися в будь-якому місці результату.</li>\n  <li>Якщо потрібен певний порядок, слід використовувати <strong>ORDER BY</strong>.</li>\n</ul>\n\n<p>Різниця між UNION та UNION ALL:</p>\n<ul>\n  <li><strong>UNION</strong> пропускає дублікати записів.</li>\n  <li><strong>UNION ALL</strong> включає всі записи, навіть дублікати.</li>\n</ul>","topicName":"SQL"},{"id":377,"questionText":"В чому відмінність між WHERE та HAVING (відповідь про те, що\nвикористовуються в різних частинах запиту недостатньо)?","answer":"<p><strong>WHERE</strong> і <strong>HAVING</strong> обидва використовуються для фільтрації рядків у SQL-запитах, але мають різні області застосування та можливості:</p>\n\n<ul>\n  <li><strong>WHERE</strong> не можна використовувати з агрегатними функціями (SUM, COUNT, AVG тощо). Використовується для фільтрації окремих рядків до групування.</li>\n  <li><strong>HAVING</strong> дозволяє використовувати агрегатні функції та фільтрувати результати вже після групування (GROUP BY).</li>\n  <li>У <strong>HAVING</strong> можна застосовувати псевдоніми лише для агрегатних функцій, тоді як у <strong>WHERE</strong> псевдоніми можна використовувати завжди.</li>\n  <li><strong>HAVING</strong> стоїть після GROUP BY, але його можна використовувати і без GROUP BY. У цьому випадку агрегатні функції застосовуються до всього набору рядків, і результат буде одним рядком, якщо набір не порожній.</li>\n</ul>","topicName":"SQL"},{"id":378,"questionText":"Що таке ORDER BY?","answer":"<p><strong>ORDER BY</strong> – це оператор SQL, який використовується для впорядкування результатів запиту за значеннями одного або декількох стовпців.</p>\n\n<ul>\n  <li>Можна сортувати декілька стовпців, визначаючи порядок їхнього впливу на результат.</li>\n  <li>Для кожного стовпця можна вказати напрямок сортування: <strong>ASC</strong> (зростання) або <strong>DESC</strong> (спадання).</li>\n  <li>За замовчуванням сортування відбувається за зростанням (<strong>ASC</strong>).</li>\n</ul>","topicName":"SQL"},{"id":379,"questionText":"Що таке GROUP BY?","answer":"<p><strong>GROUP BY</strong> – це оператор SQL, який використовується для агрегації записів результату за вказаними стовпцями (атрибутами).</p>\n\n<ul>\n  <li>Створює окрему групу для всіх можливих значень обраного стовпця або стовпців.</li>\n  <li>Всі значення <strong>NULL</strong> вважаються однаковими та потрапляють у одну групу.</li>\n</ul>","topicName":"SQL"},{"id":380,"questionText":"Що таке DISTINCT?","answer":"<p><strong>DISTINCT</strong> – вказує, що для обчислень використовуються лише унікальні значення стовпця.</p>","topicName":"SQL"},{"id":381,"questionText":"Що таке LIMIT?","answer":"<p><strong>LIMIT</strong> – обмежує вибірку вказаною кількістю записів.</p>","topicName":"SQL"},{"id":382,"questionText":"Що таке EXISTS?","answer":"<p><strong>EXISTS</strong> бере підзапит як аргумент і повертає:</p>\n<ul>\n  <li><strong>TRUE</strong>, якщо підзапит повертає хоча б один рядок;</li>\n  <li><strong>FALSE</strong>, якщо підзапит не повертає жодного рядка.</li>\n</ul>","topicName":"SQL"},{"id":383,"questionText":"Розкажіть про оператори IN, BETWEEN, LIKE","answer":"<p>У SQL існують спеціальні оператори для фільтрації даних:</p>\n\n<ul>\n  <li>\n    <strong>IN</strong> – визначає набір конкретних значень.  \n    <em>Приклад:</em>  \n    <code>SELECT * FROM Persons WHERE name IN ('Іван','Петро','Павло');</code>\n  </li>\n\n  <li>\n    <strong>BETWEEN</strong> – визначає діапазон значень. Чутливий до порядку: перше значення повинно бути менше за друге.  \n    <em>Приклад:</em>  \n    <code>SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;</code>\n  </li>\n\n  <li>\n    <strong>LIKE</strong> – використовується для пошуку підрядків у полях типу CHAR або VARCHAR. Підтримує символи шаблонів (wildcards):  \n    <ul>\n      <li><strong>_</strong> – замінює будь-який одиночний символ. Наприклад, 'b_t' відповідатиме 'bat' або 'bit', але не 'brat'.</li>\n      <li><strong>%</strong> – замінює будь-яку послідовність символів. Наприклад, '%p%t' відповідатиме 'put', 'posit', 'opt', але не 'spite'.</li>\n    </ul>\n    <em>Приклад:</em>  \n    <code>SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';</code>\n  </li>\n</ul>","topicName":"SQL"},{"id":384,"questionText":"Що робить оператор MERGE? Які у нього є обмеження?","answer":"<p>Оператор <strong>MERGE</strong> дозволяє здійснити злиття даних однієї таблиці з даними іншої таблиці. Під час злиття:</p>\n\n<ul>\n  <li>Перевіряється умова злиття (ON).</li>\n  <li>Якщо умова істинна – виконується <strong>UPDATE</strong>.</li>\n  <li>Якщо умова хибна – виконується <strong>INSERT</strong>.</li>\n</ul>\n\n<p><strong>Обмеження:</strong> неможливо змінювати поля таблиці в розділі UPDATE, за якими відбувається зв'язування таблиць.</p>\n\n<p><strong>Приклад використання:</strong></p>\n\n<pre><code>MERGE Ships AS t\nUSING (SELECT ...) AS s\nON (t.name = s.ship)\nWHEN MATCHED THEN\n    UPDATE SET t.launched = s.year\nWHEN NOT MATCHED THEN\n    INSERT VALUES (s.ship, s.year);\n</code></pre>","topicName":"SQL"},{"id":385,"questionText":"Які агрегатні функції ви знаєте?","answer":"<p>Агрегатні функції – це функції, які беруть групи значень і зводять їх до одного значення.</p>\n\n<ul>\n  <li><strong>COUNT</strong> – підрахунок записів, що відповідають умові запиту;</li>\n  <li><strong>CONCAT</strong> – з'єднання рядків;</li>\n  <li><strong>SUM</strong> – обчислення арифметичної суми всіх значень стовпця;</li>\n  <li><strong>AVG</strong> – обчислення середнього арифметичного всіх значень;</li>\n  <li><strong>MAX</strong> – визначення найбільшого значення серед обраних;</li>\n  <li><strong>MIN</strong> – визначення найменшого значення серед обраних.</li>\n</ul>","topicName":"SQL"},{"id":386,"questionText":"Що таке обмеження (constraints)? Які ви знаєте?","answer":"<p>Обмеження – це ключові слова, які допомагають встановити правила розміщення даних у базі. Використовуються при створенні бази даних.</p>\n\n<ul>\n  <li><strong>NOT NULL</strong> – значення не може бути порожнім;</li>\n  <li><strong>UNIQUE</strong> – забезпечує відсутність дублікатів;</li>\n  <li><strong>PRIMARY KEY</strong> – комбінація NOT NULL і UNIQUE, позначає кожен запис у базі даних унікальним значенням;</li>\n  <li><strong>CHECK</strong> – перевіряє, чи вписується значення в заданий діапазон (наприклад, <code>s_id int CHECK(s_id &gt; 0)</code>);</li>\n  <li><strong>FOREIGN KEY</strong> – створює зв'язок між двома таблицями і захищає від дій, що можуть порушити ці зв'язки. FOREIGN KEY в одній таблиці вказує на PRIMARY KEY в іншій;</li>\n  <li><strong>DEFAULT</strong> – встановлює значення за замовчуванням, якщо значення не надано (наприклад, <code>name VARCHAR(20) DEFAULT 'noname'</code>).</li>\n</ul>","topicName":"SQL"},{"id":387,"questionText":"Які відмінності між PRIMARY та UNIQUE?","answer":"<ul>\n  <li><strong>PRIMARY KEY</strong> за замовчуванням створює <em>кластерний індекс</em> для стовпця, тоді як <strong>UNIQUE</strong> – <em>некластерний</em>;</li>\n  <li><strong>PRIMARY KEY</strong> <u>не дозволяє NULL</u> записів, тоді як <strong>UNIQUE</strong> допускає одну (а в деяких СУБД навіть кілька) NULL записів;</li>\n  <li>У таблиці може бути <strong>лише один PRIMARY KEY</strong>, але <strong>багато UNIQUE</strong> обмежень.</li>\n</ul>","topicName":"SQL"},{"id":388,"questionText":"Чи може значення в стовпці, на яке налагоджено обмеження <strong>FOREIGN KEY</strong>, дорівнювати <code>NULL</code>?","answer":"<p><strong>Так</strong>, якщо на даний стовпець не налагоджено обмеження <code>NOT NULL</code>.</p>","topicName":"SQL"},{"id":389,"questionText":"Що таке сурогатні ключі?","answer":"<p>\n    <strong>Сурогатний ключ</strong> – це додаткове службове поле, автоматично додане \n    до вже існуючих інформаційних полів таблиці, призначенням якого є служити \n    первинним ключем.\n  </p>","topicName":"SQL"},{"id":390,"questionText":"Що таке індекси? Які вони бувають?","answer":"<p>\n    <strong>Індекси</strong> відносяться до методу налаштування продуктивності, який дозволяє \n    швидше витягти записи з таблиці. Індекс створює структуру для індексованого поля. \n    Просто додається вказівник індексу до таблиці.\n  </p>\n  <h3>Типи індексів:</h3>\n  <ul>\n    <li>\n      <strong>Унікальний індекс (Unique Index)</strong>: цей індекс не дозволяє полю мати \n      повторюючі значення. Якщо первинний ключ визначений, унікальний індекс застосований автоматично.\n    </li>\n    <li>\n      <strong>Кластеризований індекс (Clustered Index)</strong>: сортує і зберігає рядки даних \n      в таблицях або представленнях на основі їх ключових значень. Це прискорює операції читання з БД.\n    </li>\n    <li>\n      <strong>Некластеризований індекс (Non-Clustered Index)</strong>: всередині таблиці є впорядкований список, \n      який містить значення ключа некластеризованого індексу та вказівник на рядок даних, що містить значення ключа. \n      Кожен новий індекс збільшує час, необхідний для створення нових записів через впорядкованість. \n      Кожна таблиця може мати багато некластеризованих індексів.\n    </li>\n  </ul>","topicName":"SQL"},{"id":391,"questionText":"Як створити індекс?","answer":"<ul>\n    <li>\n      За допомогою виразу <code>CREATE INDEX</code>:\n      <pre><code>CREATE INDEX index_name ON table_name (column_name);</code></pre>\n    </li>\n    <li>\n      Вказавши обмеження цілісності у вигляді унікального \n      <code>UNIQUE</code> або первинного ключа <code>PRIMARY KEY</code> \n      в операторі створення таблиці <code>CREATE TABLE</code>.\n    </li>\n  </ul>","topicName":"SQL"},{"id":392,"questionText":"Має сенс індексувати дані, які мають невелику кількість можливих значень?","answer":"<p>\n    Приблизним правилом, яким можна керуватися при створенні індекса, є таке:\n    якщо обсяг інформації (у байтах), що <strong>не відповідає</strong> умові вибірки,\n    менший, ніж розмір індексу (у байтах) за цією умовою вибірки, \n    то у більшості випадків оптимізація призведе до <strong>уповільнення</strong> вибірки.\n  </p>","topicName":"SQL"},{"id":393,"questionText":"Коли повне сканування набору даних вигідніше доступу за індексом?","answer":"<p>\n    Повне сканування виконується <strong>багатоблочним читанням</strong>, \n    тоді як сканування за індексом – <strong>одноблочним</strong>. \n  </p>\n  <p>\n    При доступі за індексом спочатку виконується сканування самого індекса, \n    а потім – читання блоків із набору даних. \n    Кількість блоків, які треба при цьому прочитати, залежить від <em>фактора кластеризації</em>.\n  </p>\n  <p>\n    Якщо сумарна вартість усіх необхідних одноблочних читань \n    більша за вартість повного сканування багатоблочним читанням, \n    то оптимізатор обирає <strong>повне сканування</strong>.\n  </p>\n  <p>\n    Таким чином, повне сканування обирається у таких випадках:\n  </p>\n  <ul>\n    <li>слабка селективність предикатів запиту;</li>\n    <li>слабка кластеризація даних;</li>\n    <li>дуже малі набори даних.</li>\n  </ul>","topicName":"SQL"},{"id":394,"questionText":"Чим TRUNCATE відрізняється від DELETE?","answer":"<ul>\n    <li>\n      <strong>DELETE</strong> – оператор <abbr title=\"Data Manipulation Language\">DML</abbr>, \n      видаляє записи з таблиці, які відповідають умовам <code>WHERE</code>.  \n      <br>Особливості:\n      <ul>\n        <li>повільніший, ніж <code>TRUNCATE</code>;</li>\n        <li>є можливість відновити дані (<code>ROLLBACK</code>).</li>\n      </ul>\n    </li>\n    <li>\n      <strong>TRUNCATE</strong> – оператор <abbr title=\"Data Definition Language\">DDL</abbr>, \n      видаляє <strong>всі рядки</strong> з таблиці.  \n      <br>Особливості:\n      <ul>\n        <li>швидший за <code>DELETE</code>;</li>\n        <li>немає можливості відновити дані – <code>ROLLBACK</code> не спрацює.</li>\n      </ul>\n    </li>\n  </ul>","topicName":"SQL"},{"id":395,"questionText":"Що таке збережені процедури? Для чого вони потрібні?","answer":"<p>\n    Збережені процедури – це об'єкти бази даних, які представляють собою набір SQL-інструкцій, \n    що зберігаються на сервері.\n  </p>\n  <p>\n    Вони схожі на методи мов високого рівня:\n    <ul>\n      <li>можуть мати вхідні та вихідні параметри;</li>\n      <li>можуть містити локальні змінні;</li>\n      <li>проводять числові обчислення та операції над символьними даними;</li>\n      <li>результати можуть присвоюватися змінним та параметрам;</li>\n      <li>підтримують стандартні операції з базами даних (DDL та DML);</li>\n      <li>можливі цикли та умовні гілки для управління процесом виконання.</li>\n    </ul>\n  </p>\n  <p>\n    Переваги збережених процедур:\n    <ul>\n      <li>підвищують продуктивність;</li>\n      <li>розширюють можливості програмування;</li>\n      <li>підтримують функції безпеки даних.</li>\n    </ul>\n    У більшості СУБД при першому запуску процедура компілюється (синтаксичний аналіз та план доступу до даних), \n    і надалі її виконання відбувається швидше.\n  </p>","topicName":"SQL"},{"id":396,"questionText":"Що таке «тригер»?","answer":"<p>\n    Тригер (trigger) – це збережена процедура спеціального типу, виконання якої обумовлене дією по модифікації даних: \n    додаванням, видаленням або зміною даних у зазначеній таблиці реляційної бази даних.\n  </p>\n  <p>\n    Особливості тригера:\n    <ul>\n      <li>Запускається сервером автоматично.</li>\n      <li>Усі модифікації даних, виконані тригером, розглядаються як частина транзакції, \n          у якій сталася подія, що спричинила спрацювання тригера.</li>\n      <li>Момент запуску визначається ключовими словами:\n        <ul>\n          <li><strong>BEFORE</strong> – тригер запускається до виконання події.</li>\n          <li><strong>AFTER</strong> – тригер запускається після події.</li>\n        </ul>\n      </li>\n    </ul>\n  </p>","topicName":"SQL"},{"id":397,"questionText":"Що таке представлення (VIEW)? Для чого вони потрібні?","answer":"<p>\n    View – віртуальна таблиця, яка представляє дані однієї або декількох таблиць альтернативним чином.\n  </p>\n  <p>\n    Особливості представлень:\n    <ul>\n      <li>Представлення – це результат виконання оператора <strong>SELECT</strong>, збережений у структурі пам'яті, схожій на таблицю SQL.</li>\n      <li>Працюють у запитах та операторах DML так само, як і основні таблиці, але не містять власних даних.</li>\n      <li>Дозволяють надавати публічний доступ лише до частини інформації таблиці.</li>\n      <li>Можуть ґрунтуватися на таблицях або інших представленнях (вкладені до 32 рівнів).</li>\n    </ul>\n  </p>","topicName":"SQL"},{"id":398,"questionText":"Що таке тимчасові таблиці? Для чого вони потрібні?","answer":"<p>\n    Тимчасові таблиці зручні для створення проміжних вибірок даних з декількох таблиць.\n  </p>\n  <p>\n    Особливості створення:\n    <ul>\n      <li>Ім'я починається зі знака <strong>#</strong> для локальної таблиці або <strong>##</strong> для глобальної.</li>\n      <li>Локальна таблиця (<strong>#</strong>) доступна лише протягом поточної сесії.</li>\n      <li>Глобальна таблиця (<strong>##</strong>) доступна всім відкритим сесіям бази даних.</li>\n    </ul>\n  </p>\n  <p>Приклад створення тимчасової таблиці:</p>\n  <pre>\nCREATE TABLE #ProductSummary\n(\n  ProdId INT IDENTITY,\n  ProdName NVARCHAR(20),\n  Price MONEY\n)\n  </pre>","topicName":"SQL"},{"id":399,"questionText":"Що таке транзакції? Розкажіть про принципи ACID","answer":"<p>\n    Транзакція – це вплив на базу даних, який переводить її з одного цілісного стану в інший і виражається у зміні даних, що зберігаються в базі даних.\n  </p>\n  <p>Принципи ACID транзакцій:</p>\n  <ul>\n    <li>\n      <strong>Атомарність (Atomicity)</strong> – транзакція виконується повністю або не виконується взагалі. Якщо одна частина транзакції зазнає збою, вся транзакція скасовується, і стан бази даних залишається незмінним.\n    </li>\n    <li>\n      <strong>Співробітність (Consistency)</strong> – після завершення транзакції база даних зберігає цілісність даних.\n    </li>\n    <li>\n      <strong>Ізоляція (Isolation)</strong> – паралельні транзакції не повинні впливати на результат виконання однієї транзакції.\n    </li>\n    <li>\n      <strong>Тривалість (Durability)</strong> – після успішного завершення транзакції її зміни залишаються збереженими, навіть у разі збоїв або втрати живлення.\n    </li>\n  </ul>","topicName":"SQL"},{"id":400,"questionText":"Розкажіть про рівні ізоляції транзакцій","answer":"<p>Існують основні види аномалій при паралельному виконанні транзакцій:</p>\n  <ul>\n    <li>\n      <strong>«Брудне» читання (Dirty Read)</strong>: Транзакція A виконує запис, а транзакція B читає цю зміну до завершення транзакції A. Якщо транзакція A відкотиться, транзакція B вже працювала з некоректними даними. Це відбувається на рівні ізоляції <code>READ_UNCOMMITTED</code>.\n    </li>\n    <li>\n      <strong>Неповторюване читання (Non-Repeatable Read)</strong>: Транзакція A читає записи, потім транзакція B змінює ці записи та фіксує зміни. Коли транзакція A читає ті ж записи знову, вона отримує інші значення. Це неповторюване читання.\n    </li>\n    <li>\n      <strong>Фантомне читання (Phantom Read)</strong>: Транзакція A читає ряд записів. Транзакція B вставляє новий рядок у той самий діапазон, що й транзакція A. При наступному читанні транзакція A бачить новий рядок, що не було під час першого читання. Це фантомне читання.\n    </li>\n  </ul>","topicName":"SQL"},{"id":401,"questionText":"Що таке нормалізація і денормалізація? Розкажіть про нормальні форми","answer":"<p><strong>Нормалізація</strong> – це процес перетворення таблиць бази даних так, щоб вони відповідали нормальним формам, покроково усуваючи надлишковість та потенційні конфлікти в даних.</p>\n  \n  <p><strong>Денормалізація</strong> – це зворотний процес, коли дані навмисно дублюються для підвищення продуктивності вибірок, особливо при частих запитах, що об'єднують дані з різних таблиць.</p>\n  \n  <h3>Нормальні форми:</h3>\n  <ul>\n    <li>\n      <strong>Перша нормальна форма (1NF)</strong>: значення всіх полів атомарні (одне значення в комірці). Таблиця не містить дублюючих рядків, всі стовпці одного типу, відсутні масиви та списки.\n    </li>\n    <li>\n      <strong>Друга нормальна форма (2NF)</strong>: таблиця вже в 1NF, має ключ, а всі неключові поля залежать від повного ключа (не від його частини, якщо ключ складений).\n    </li>\n    <li>\n      <strong>Третя нормальна форма (3NF)</strong>: таблиця вже в 2NF, а неключові поля не залежать одне від одного (немає транзитивних залежностей).\n    </li>\n  </ul>\n  \n  <h3>Інші форми:</h3>\n  <ul>\n    <li><strong>BCNF (нормальна форма Бойса-Кодда)</strong>: кожна нетривіальна залежність має потенційний ключ як детермінант.</li>\n    <li><strong>4NF</strong>: усуває багатозначні залежності між незалежними групами полів.</li>\n    <li><strong>5NF</strong>: кожна нетривіальна залежність з'єднання визначається ключем відношення.</li>\n    <li><strong>DKNF (Доменна-ключова форма)</strong>: всі обмеження таблиці логічно витікають з обмежень доменів та ключів.</li>\n    <li><strong>6NF</strong>: таблиця не може бути далі декомпозована без втрат, застосовується в хронологічних базах даних для зберігання історичних і майбутніх даних.</li>\n  </ul>","topicName":"SQL"},{"id":402,"questionText":"Що таке TIMESTAMP?","answer":"<p><strong>DATETIME</strong> призначений для зберігання дати й часу у вигляді цілого числа: <code>YYYYMMDDHHMMSS</code>. Час не залежить від часового поясу сервера. Розмір: 8 байт.</p>\n  <p><strong>TIMESTAMP</strong> зберігає значення у вигляді кількості секунд, що минули з півночі 1 січня 1970 року за середнім часом Ґрінвіча (Unix-час). При отриманні даних з бази відображається з урахуванням часового поясу. Розмір: 4 байти.</p>","topicName":"SQL"},{"id":403,"questionText":"Що таке шардування БД?","answer":"<p>При великій кількості даних запити починають довго виконуватися, і сервер не впорається з навантаженням. Одним із рішень є масштабування бази даних. Наприклад, шардування або реплікація.</p>\n<p>Шардування буває вертикальним (партиціюванням) та горизонтальним.</p>\n<p>У нас є велика таблиця, наприклад, з користувачами. Партиціювання - це коли ми одну велику таблицю розподіляємо на багато малих за якимось принципом.</p>\n<p>Єдина відмінність горизонтального масштабування від вертикального в тому, що горизонтальне буде розподіляти дані по різних інстанціях у інших базах.</p>\n<pre><code>CREATE TABLE news (\n    id bigint not null,\n    category_id int not null,\n    author character varying not null,\n    rate int not null,\n    title character varying\n);\n</code></pre>\n<p>Є таблиця \"news\", у якій є ідентифікатор, категорія, в якій розташована ця новина, та автор новини.</p>\n<p>Потрібно виконати 2 дії з таблицею:</p>\n<ul>\n    <li>Зробити так, щоб наш шард, наприклад, \"news_1\", успадковував властивості від \"news\". Успадкована таблиця матиме всі стовпці батька, а також може мати свої власні стовпці, які ми додатково додамо туди. Вона не буде мати обмежень, індексів та тригерів від батька. Це важливо.</li>\n    <li>Встановити обмеження. Це буде перевірка, що в цю таблицю будуть потрапляти дані тільки з необхідним позначенням.</li>\n</ul>\n<pre><code>CREATE TABLE news_1 (\n    CHECK ( category_id = 1 )\n) INHERITS (news);\n</code></pre>\n<p>Отже, лише записи s category_id=1 будуть потрапляти в цю таблицю.</p>\n<p>Для створення тригера потрібно додати правило. Кома ми будемо працювати з таблицею \"news\", вставка для запису s category_id = 1 повинна потрапити саме в партіцію \"news_1\". Ми називаємо правило так, як бажаємо.</p>\n<pre><code>CREATE RULE news_insert_to_1 AS ON INSERT TO news\nWHERE ( category_id = 1 )\nDO INSTEAD INSERT INTO news_1 VALUES (NEW.*);\n</code></pre>","topicName":"SQL"},{"id":404,"questionText":"Що таке EXPLAIN?","answer":"<p>Коли ви виконуєте який-небудь запит, оптимізатор запитів MySQL намагається створити оптимальний план виконання цього запиту. Щоб переглянути цей план, можна скористатися запитом з ключовим словом <strong>EXPLAIN</strong> перед оператором <strong>SELECT</strong>.</p>\n\n<pre><code>EXPLAIN SELECT * FROM categories</code></pre>\n\n<p>Після <strong>EXPLAIN</strong> у запиті можна використовувати ключове слово <strong>EXTENDED</strong>, і MySQL відобразить додаткову інформацію про те, як виконується запит. Щоб переглянути цю інформацію, потрібно виконати запит <strong>SHOW WARNINGS</strong> одразу після запиту з <strong>EXTENDED</strong>.</p>\n\n<pre><code>EXPLAIN EXTENDED SELECT City.Name FROM City</code></pre>\n\n<p>Потім</p>\n\n<pre><code>SHOW WARNINGS</code></pre>","topicName":"SQL"},{"id":405,"questionText":"Як виконати запит із двох баз?","answer":"<p>Якщо в запиті таблиця вказується ім’ям бази даних <strong>database1.table1</strong>, то таблиця вибирається з <strong>database1</strong>. Якщо вказано просто <strong>table1</strong>, то з активної бази даних. Важливо, щоб бази були на одному сервері.</p>\n\n<pre><code>SELECT t1.*, t2.*\nFROM database1.table1 AS t1\nINNER JOIN database2.table2 AS t2 ON t1.field1 = t2.field1\n</code></pre>\n\n<h2>Що швидше прибирає дублікати: DISTINCT чи GROUP BY?</h2>\n<ul>\n  <li>Якщо потрібні унікальні значення – <strong>DISTINCT</strong>.</li>\n  <li>Якщо потрібно групувати значення – <strong>GROUP BY</strong>.</li>\n  <li>Якщо завдання полягає саме в пошуку дублікатів – <strong>GROUP BY</strong> буде краще.</li>\n</ul>","topicName":"SQL"},{"id":406,"questionText":"Як виконати запит із двох баз?","answer":"<p>Якщо в запиті таблиця вказується ім’ям бази даних <strong>database1.table1</strong>, то таблиця вибирається з <strong>database1</strong>. Якщо вказано просто <strong>table1</strong>, то з активної бази даних. Важливо, щоб бази були на одному сервері.</p>\n\n<pre><code>SELECT t1.*, t2.*\nFROM database1.table1 AS t1\nINNER JOIN database2.table2 AS t2 ON t1.field1 = t2.field1\n</code></pre>\n\n<h2>Що швидше прибирає дублікати: DISTINCT чи GROUP BY?</h2>\n<ul>\n  <li>Якщо потрібні унікальні значення – <strong>DISTINCT</strong>.</li>\n  <li>Якщо потрібно групувати значення – <strong>GROUP BY</strong>.</li>\n  <li>Якщо завдання полягає саме в пошуку дублікатів – <strong>GROUP BY</strong> буде краще.</li>\n</ul>","topicName":"SQL"},{"id":407,"questionText":"Що таке ORM?","answer":"<p><strong>ORM (Object Relational Mapping)</strong> – це концепція перетворення даних з об'єктно-орієнтованої мови в реляційні бази даних і навпаки.</p>","topicName":"Hibernate"},{"id":408,"questionText":"Що таке JPA?","answer":"<p><strong>JPA (Java Persistence API)</strong> – це стандарт для Java, що описує принципи ORM. JPA сама не працює з об'єктами, а лише визначає правила, які повинен дотримуватися кожен постачальник (Hibernate, EclipseLink), який реалізує стандарт JPA.</p>\n<p>JPA визначає правила для опису метаданих відображення та роботи постачальників. Кожен постачальник повинен реалізовувати все з JPA, визначаючи стандартне отримання, збереження та управління об'єктами. Можна додавати свої класи та інтерфейси.</p>\n<p>Гнучкість – код, написаний з використанням класів та інтерфейсів JPA, дозволяє гнучко змінювати одного постачальника на іншого. Але якщо використовувати класи, анотації та інтерфейси конкретного постачальника, це не буде працювати.</p>\n<p>JDO входить в JPA, NoSQL.</p>","topicName":"Hibernate"},{"id":409,"questionText":"Що таке Hibernate?","answer":"<p><strong>Hibernate</strong> – бібліотека, яка є реалізацією JPA-специфікації, в якій можна використовувати не тільки стандартні API-інтерфейси JPA, але й реалізувати свої класи та інтерфейси.</p>","topicName":"Hibernate"},{"id":410,"questionText":"Які інтерфейси Hibernate ви пам'ятаєте ?","answer":"<h3>Session</h3>\n<p>Забезпечує фізичне з'єднання між додатком та базою даних. Основна функція – пропонувати DML-операції для екземплярів сутностей.</p>\n\n<h3>SessionFactory</h3>\n<p>Фабрика для об'єктів <strong>Session</strong>. Зазвичай створюється під час запуску додатка і зберігається для подальшого використання. Є об'єктом, що не схильний до багатопотоковості, і використовується всіма потоками додатка.</p>\n\n<h3>Transaction</h3>\n<p>Однопоточний короткостроковий об'єкт, використовуваний для атомарних операцій. Це абстракція додатка від основних JDBC-транзакцій.</p>\n\n<h3>Query</h3>\n<p>Інтерфейс, який дозволяє виконувати запити до бази даних. Запити можна написати на HQL або SQL.</p>","topicName":"Hibernate"},{"id":411,"questionText":"Що таке EntityManager? Які функції він виконує?","answer":"<p><strong>EntityManager</strong> – це інтерфейс JPA, який описує API для всіх основних операцій над сутністю, а також для отримання даних та інших сутностей JPA.</p>\n\n<h3>Основні операції:</h3>\n\n<ul>\n  <li><strong>Операції над сутністю:</strong> persist (додавання сутності), merge (оновлення), remove (вилучення), refresh (оновлення даних), detach (вилучення з управління JPA), lock (блокування сутності від змін в інших потоках).</li>\n  <li><strong>Отримання даних:</strong> find (пошук та отримання сутності), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery.</li>\n  <li><strong>Отримання інших сутностей JPA:</strong> getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate.</li>\n  <li><strong>Робота з EntityGraph:</strong> createEntityGraph, getEntityGraph.</li>\n  <li><strong>Загальні операції з EntityManager або всіма сутностями:</strong> close, clear, isOpen, getProperties, setProperty.</li>\n</ul>\n\n<p>Об'єкти <strong>EntityManager</strong> не є потокобезпечними. Це означає, що кожен потік повинен отримати свій екземпляр EntityManager, працювати з ним і закривати його в кінці.</p>","topicName":"Hibernate"},{"id":412,"questionText":"Яким умовам має задовольняти клас, щоб бути Entity?","answer":"<h3>Вимоги до класу entity:</h3>\n<ul>\n  <li>Повинен бути позначений анотацією <strong>@Entity</strong> або описаний в XML-файлі.</li>\n  <li>Повинен містити публічний або захищений конструктор без аргументів (може мати конструктори з аргументами).</li>\n  <li>Повинен бути класом верхнього рівня.</li>\n  <li>Не може бути переліченням або інтерфейсом.</li>\n  <li>Не може бути фінальним класом.</li>\n  <li>Не може містити фінальні поля або методи, якщо вони беруть участь у мапуванні.</li>\n  <li>Якщо об'єкт класу entity буде передаватися за значенням як окремий об'єкт (detached object), наприклад, через віддалений інтерфейс, він повинен реалізовувати інтерфейс <strong>Serializable</strong>.</li>\n  <li>Поля класу entity повинні бути доступні тільки методам самого класу entity і не повинні бути доступні іншим класам, які використовують цей entity. Інші класи повинні звертатися лише до getter/setter методів або інших методів бізнес-логіки в класі entity.</li>\n  <li>Повинен містити первинний ключ, тобто атрибут або групу атрибутів, які унікально визначають запис цього класу entity в базі даних.</li>\n</ul>","topicName":"Hibernate"},{"id":413,"questionText":"Чи може абстрактний клас бути Entity?","answer":"<p>Так, абстрактний клас може бути Entity. Він зберігає всі властивості Entity, за винятком того, що його не можна безпосередньо ініціалізувати.</p>","topicName":"Hibernate"},{"id":414,"questionText":"Чи може клас entity успадковувати від не entity-класів?","answer":"<p>Так, клас entity може успадковувати від звичайного (не entity) класу. У цьому випадку він наслідує всі властивості та методи батьківського класу, а також додає власні поля та поведінку, що визначені для entity.</p>","topicName":"Hibernate"},{"id":415,"questionText":"Чи може клас entity успадковувати від інших entity-класів?","answer":"<p>Так, клас entity може успадковувати від іншого entity-класу. Це дозволяє створювати ієрархію сутностей, де підкласи успадковують поля, первинний ключ та бізнес-логіку батьківського entity. JPA підтримує різні стратегії успадкування, такі як SINGLE_TABLE, JOINED та TABLE_PER_CLASS.</p>","topicName":"Hibernate"},{"id":416,"questionText":"Чи може не entity-клас успадковувати від entity-класу?","answer":"<p>Так, звичайний клас (не entity) може успадковувати від entity-класу. Проте цей клас не буде самостійною сутністю в базі даних і не матиме автоматичного мапування на таблицю, якщо він не позначений як entity. Він може використовувати успадковані поля та методи для бізнес-логіки всередині програми.</p>","topicName":"Hibernate"},{"id":417,"questionText":"Що таке вбудовуваний (embeddable) клас?","answer":"<p><strong>Embeddable клас</strong> – це клас, який сам по собі не є сутністю, а є частиною одного або декількох класів entity. Його використовують для групування спільних атрибутів або повторно використовуваних полів у різних entity-класах.</p>\n\n<p>Клас entity може містити:</p>\n<ul>\n  <li>одиночні вбудовувані класи;</li>\n  <li>колекції таких класів;</li>\n  <li>вбудовувані класи як ключі або значення у <strong>Map</strong>.</li>\n</ul>\n\n<p>Під час виконання кожен embeddable клас належить лише одному об'єкту entity і не може використовуватися для передачі даних між різними entity. Загалом, такі класи слугують для визначення загальних атрибутів для декількох класів entity.</p>\n\n<h3>Вимоги JPA до embeddable класів:</h3>\n<ul>\n  <li>Клас повинен бути позначений анотацією <strong>@Embeddable</strong> або описаний в XML-файлі конфігурації JPA.</li>\n  <li>Поле цього класу в entity має бути позначене анотацією <strong>@Embedded</strong>.</li>\n  <li>Може містити інші вбудовувані класи.</li>\n  <li>Може містити зв’язки з іншими entity або колекціями entity, якщо не використовується як первинний ключ або ключ у <strong>Map</strong>.</li>\n  <li>Повинен дотримуватися тих самих правил, що й класи entity, за винятком того, що не зобов’язаний містити первинний ключ і бути позначеним <strong>@Entity</strong>.</li>\n</ul>","topicName":"Hibernate"},{"id":418,"questionText":"Що таке Mapped Superclass?","answer":"<p><strong>Mapped Superclass</strong> – це клас, від якого успадковуються entity-класи. Він може містити анотації JPA, але сам по собі не є entity. Тому до нього не обов’язково застосовувати всі вимоги, встановлені для entity, наприклад, він може не містити первинного ключа.</p>\n\n<p>Особливості Mapped Superclass:</p>\n<ul>\n  <li>Не може використовуватися безпосередньо в операціях <strong>EntityManager</strong> або <strong>Query</strong>.</li>\n  <li>Повинен бути позначений анотацією <strong>@MappedSuperclass</strong> або описаний у XML-файлі.</li>\n  <li>Служить для визначення спільних властивостей і методів, які успадковуються entity-класами.</li>\n</ul>\n\n<p>Створення такого класу дозволяє скоротити кількість коду в сутностях, забезпечуючи повторне використання загальних полів та методів.</p>","topicName":"Hibernate"},{"id":419,"questionText":"Типи стратегій наслідування мапінга (Inheritance Mapping Strategies) є в JPA?","answer":"<p>Стратегії наслідування мапінга визначають, як JPA буде працювати з класами-нащадками entity.</p>\n\n<h3>1. Одна таблиця на всю ієрархію класів (SINGLE_TABLE)</h3>\n<p>Усі entity та їхні нащадки зберігаються в одній таблиці. Для ідентифікації типу entity використовується спеціальна колонка <strong>discriminator column</strong>.</p>\n<p>Наприклад, є entity <strong>Animals</strong> із класами-нащадками <strong>Cats</strong> і <strong>Dogs</strong>. Всі записи зберігаються в таблиці <strong>Animals</strong>, а в колонці <strong>animalType</strong> зазначається «cat» або «dog».</p>\n<p><strong>Недоліки:</strong></p>\n<ul>\n  <li>У загальній таблиці будуть створені всі поля, унікальні для кожного класу-нащадка, які будуть порожні для інших.</li>\n  <li>Наприклад, швидкість лазання по дереву для <strong>Cats</strong> та вміння приносити тапочки для <strong>Dogs</strong> будуть null для інших типів.</li>\n  <li>Неможливо робити <strong>NOT NULL</strong> constraints; можна використовувати тригери.</li>\n</ul>\n\n<h3>2. Стратегія «сполучення» (JOINED_TABLE)</h3>\n<p>Кожен клас entity зберігає дані в окремій таблиці, але тільки унікальні поля та первинний ключ. Усі успадковані колонки зберігаються у таблиці класу-предка, а між таблицями встановлюється зв’язок.</p>\n<p>Наприклад, для <strong>Animals</strong>, <strong>Cats</strong> і <strong>Dogs</strong> буде три таблиці: <strong>animals</strong>, <strong>cats</strong>, <strong>dogs</strong>. Таблиця <strong>cats</strong> зберігатиме лише ключ і швидкість лазання, <strong>dogs</strong> – ключ і вміння приносити тапочки, а <strong>animals</strong> – спільні дані.</p>\n<p><strong>Недоліки:</strong> втрата продуктивності через об’єднання таблиць (<strong>JOIN</strong>) для будь-яких операцій.</p>\n\n<h3>3. Таблиця для кожного класу (TABLE_PER_CLASS)</h3>\n<p>Кожен окремий клас-нащадок має свою таблицю. Дані зберігаються прямо в таблицях нащадків, ніби вони не мають спільного суперкласу.</p>\n<p><strong>Недоліки:</strong> погана підтримка поліморфізму та необхідність великої кількості SQL-запитів або використання <strong>UNION</strong> для вибірки всіх класів ієрархії.</p>\n\n<p>Для визначення стратегії наслідування використовується анотація <strong>@Inheritance</strong> або відповідні блоки конфігурації.</p>","topicName":"Hibernate"},{"id":420,"questionText":"Як мапляться Enum'и в JPA?","answer":"<p>Існує кілька способів зберігати Enum у базі даних:</p>\n\n<h3>1. Використання @Enumerated</h3>\n<ul>\n  <li><strong>@Enumerated(EnumType.STRING)</strong> – в базі даних зберігаються імена Enum.</li>\n  <li><strong>@Enumerated(EnumType.ORDINAL)</strong> – в базі зберігаються порядкові номери Enum.</li>\n</ul>\n\n<h3>2. Використання методів з @PostLoad та @PrePersist</h3>\n<p>Можна мапити Enum вручну за допомогою допоміжного поля і методів життєвого циклу:</p>\n<ul>\n  <li>Створюємо клас з методами, позначеними <strong>@PostLoad</strong> та <strong>@PrePersist</strong>.</li>\n  <li>У сутності поле Enum позначаємо <strong>@Transient</strong>, а в базі зберігається значення з допоміжного поля.</li>\n  <li>Ідея полягає в тому, щоб мати у сутності поле Enum для логіки додатку та окреме поле для збереження у БД.</li>\n</ul>\n\n<h3>3. Використання Converter (JPA 2.1+)</h3>\n<p>Можна створити клас, який реалізує <strong>javax.persistence.AttributeConverter</strong> для конвертації Enum у значення для БД і назад.</p>\n<ul>\n  <li>Клас анотується <strong>@Converter</strong>.</li>\n  <li>Поле у сутності анотується <strong>@Convert</strong> з посиланням на цей конвертер.</li>\n</ul>","topicName":"Hibernate"},{"id":421,"questionText":"Як мапляться дати в JPA?","answer":"<h3>До Java 8</h3>\n<p>Для мапінгу дат використовувалася анотація <strong>@Temporal</strong>, де потрібно було вказати тип дати:</p>\n<ul>\n  <li><strong>@Temporal(TemporalType.DATE)</strong> – тільки дата (рік, місяць, день)</li>\n  <li><strong>@Temporal(TemporalType.TIME)</strong> – тільки час (години, хвилини, секунди)</li>\n  <li><strong>@Temporal(TemporalType.TIMESTAMP)</strong> – дата і час</li>\n</ul>\n\n<h3>Java 8 і пізніше</h3>\n<p>З Java 8 анотація <strong>@Temporal</strong> не потрібна. JPA автоматично підтримує нові типи дат з <strong>java.time</strong> пакету, такі як <strong>LocalDate</strong>, <strong>LocalTime</strong> та <strong>LocalDateTime</strong>.</p>","topicName":"Hibernate"},{"id":422,"questionText":"Як \"смапити\" колекцію примітивів в JPA?","answer":"<p>Якщо у сутності є поле з колекцією, і ця колекція не містить інших entity, а базові або вбудовані (embeddable) типи, використовуються спеціальні анотації:</p>\n\n<ul>\n  <li><strong>@ElementCollection</strong> – вказує, що поле є колекцією елементів, які не є entity.</li>\n  <li><strong>@OrderBy</strong> – дозволяє автоматично сортувати елементи колекції при отриманні з бази.</li>\n  <li><strong>@OrderColumn</strong> – зберігає порядок елементів у базі, щоб при додаванні нових рядків не очищати всю колекцію.</li>\n  <li><strong>@CollectionTable</strong> – дозволяє налаштовувати таблицю, де зберігатиметься колекція елементів.</li>\n</ul>\n\n<p>У результаті створюються дві таблиці: одна для сутності, інша для колекції елементів. При додаванні нового рядка до колекції без @OrderColumn вона повністю очищається і заповнюється заново, оскільки елементи не мають власного <strong>id</strong>.</p>","topicName":"Hibernate"},{"id":423,"questionText":"Які є види зв'язків в JPA ?","answer":"<p>Існує 4 основні типи зв'язків між сутностями:</p>\n\n<h3>1. OneToOne</h3>\n<p>Один екземпляр entity може бути пов'язаний не більше ніж з одним екземпляром іншого entity.</p>\n<ul>\n  <li>Необхідно встановити <strong>foreign key</strong> на батьківську таблицю.</li>\n  <li>Використовується анотація <strong>@JoinColumn</strong> з атрибутом <strong>name</strong>, що вказує, до якої колонки посилатися в батьківській сутності.</li>\n  <li>Поле в класі містить тип іншої сутності.</li>\n</ul>\n\n<h3>2. OneToMany</h3>\n<p>Один екземпляр entity може бути пов'язаний з кількома екземплярами інших entity.</p>\n<ul>\n  <li>Зберігається колекція об'єктів у батьківській сутності.</li>\n</ul>\n\n<h3>3. ManyToOne</h3>\n<p>Зворотний зв'язок для OneToMany: кілька екземплярів entity можуть бути пов'язані з одним екземпляром іншого entity.</p>\n<ul>\n  <li>В дочірній сутності зберігається посилання на батьківську.</li>\n  <li>Наприклад, кілька машин можуть належати одному користувачу.</li>\n</ul>\n\n<h3>4. ManyToMany</h3>\n<p>Екземпляри entity можуть бути пов'язані з кількома екземплярами один одного.</p>\n<ul>\n  <li>Створюється зведена таблиця з ідентифікаторами обох сутностей.</li>\n  <li>Зберігаються колекції об'єктів для кожної сутності.</li>\n</ul>\n\n<h3>Види посилань</h3>\n\n<ul>\n  <li><strong>Bidirectional</strong> – посилання на зв'язок встановлюється для всіх entity. Наприклад, у OneToOne у сутності A є посилання на B, а в B – на A. Сутність A вважається власником зв'язку, що важливо для каскадного видалення.</li>\n  <li><strong>Unidirectional</strong> – посилання на зв'язок встановлюється лише з одного боку. Наприклад, у OneToOne у сутності A є посилання на B, а в B немає посилання на A.</li>\n</ul>","topicName":"Hibernate"},{"id":424,"questionText":"Що таке власник зв'язку?","answer":"<p>У відносинах між двома сутностями завжди існує одна власна сторона, а залежна сторона може бути відсутня у випадку однонаправлених відносин.</p>\n\n<p><strong>Власник зв'язку</strong> – це сутність, у якої є зовнішній ключ на іншу сутність. Іншими словами:</p>\n<ul>\n  <li>Якщо в таблиці однієї сутності є колонка, що містить зовнішні ключі на іншу сутність, ця сутність є власником зв'язку.</li>\n  <li>Сутність, на яку посилається зовнішній ключ, вважається залежною.</li>\n</ul>\n\n<p>У однонаправлених відносинах власником зв'язку за замовчуванням є та сторона, яка має поле з типом іншої сутності.</p>","topicName":"Hibernate"},{"id":425,"questionText":"Що таке каскади в JPA?","answer":"<p>Каскадування – це процес, при якому дія над цільовою сутністю автоматично застосовується до пов'язаних сутностей.</p>\n\n<h3>Типи CascadeType в JPA</h3>\n<ul>\n  <li><strong>ALL</strong> – гарантує, що всі персистентні події на батьківському об'єкті будуть передані дочірнім об'єктам.</li>\n  <li><strong>PERSIST</strong> – операції <em>save()</em> або <em>persist()</em> каскадно застосовуються до пов'язаних об'єктів.</li>\n  <li><strong>MERGE</strong> – пов'язані сутності об'єднуються разом із сутністю-власником при виконанні <em>merge()</em>.</li>\n  <li><strong>REMOVE</strong> – видаляє всі сутності, пов'язані з видаляємою сутністю.</li>\n  <li><strong>DETACH</strong> – відключає всі пов'язані сутності при \"ручному відключенні\".</li>\n  <li><strong>REFRESH</strong> – повторно зчитує значення даного екземпляра та пов'язаних сутностей з бази даних при виклику <em>refresh()</em>.</li>\n</ul>","topicName":"Hibernate"},{"id":426,"questionText":"Які є відмінності між PERSIST та MERGE в JPA?","answer":"<ul>\n  <li><strong>persist(entity)</strong> – використовується для нових об'єктів, щоб додати їх у базу даних. Якщо об'єкт вже існує в базі, буде викинуто виняток <strong>EntityExistsException</strong>.</li>\n  <li><strong>merge(entity)</strong> – використовується для об'єктів, які вже збережені в базі. Якщо сутність вже управляється в контексті персистентності, вона буде замінена новою сутністю (оновленою), і копія оновленої сутності повернеться назад. Рекомендується застосовувати для оновлення існуючих сутностей.</li>\n</ul>","topicName":"Hibernate"},{"id":427,"questionText":"Які є типи стратегій вибірки в JPA?","answer":"<p>У JPA існують дві основні стратегії завантаження даних:</p>\n\n<h3>1. LAZY</h3>\n<ul>\n  <li>Дані завантажуються не відразу, а при першому звертанні до них.</li>\n  <li>За замовчуванням для колекцій, анотованих <strong>@OneToMany</strong>, <strong>@ManyToMany</strong> та <strong>@ElementCollection</strong>.</li>\n  <li>Об'єкт завантажується у вигляді проксі (proxy). Для колекцій використовується Hibernate-колекція (bag, list, set тощо).</li>\n  <li>Завантаження повинно відбуватися в межах однієї транзакції або поки EntityManager відкритий, інакше виникає <strong>LazyInitializationException</strong>.</li>\n</ul>\n\n<h3>2. EAGER</h3>\n<ul>\n  <li>Дані поля завантажуються негайно при завантаженні сутності.</li>\n  <li>За замовчуванням для полів, анотованих <strong>@Basic</strong>, <strong>@ManyToOne</strong> та <strong>@OneToOne</strong>.</li>\n</ul>\n\n<p>Правило: все, що закінчується на <strong>One</strong> – EAGER, <strong>Many</strong> – LAZY.</p>\n<p>ManyToOne використовується для власника зв'язку.</p>","topicName":"Hibernate"},{"id":428,"questionText":"Які статуси життєвого циклу Entity-об'єкта (Entity Instance’s LifeCycle) існують в JPA ?","answer":"<ul>\n  <li><strong>transient (new)</strong> – свіжозгенерована сутність оператором <code>new()</code>. \n      <ul>\n        <li>Не має зв'язку з базою даних.</li>\n        <li>Не має згенерованого первинного ключа.</li>\n        <li>Не управляється контекстом персистентності.</li>\n        <li>При збереженні переходить у стан <strong>managed</strong>.</li>\n      </ul>\n  </li>\n\n  <li><strong>managed</strong> – об'єкт створено та управляється контекстом персистентності.\n      <ul>\n        <li>Має первинний ключ.</li>\n        <li>Збережений у базі даних.</li>\n        <li>При виклику <code>detach()</code> переходить у стан <strong>detached</strong>.</li>\n      </ul>\n  </li>\n\n  <li><strong>detached</strong> – об'єкт існує в базі даних, але не управляється JPA.\n      <ul>\n        <li>Сутність не прив'язана до свого контексту.</li>\n        <li>Не має активного екземпляра Session, який би нею керував.</li>\n      </ul>\n  </li>\n\n  <li><strong>removed</strong> – об'єкт управляється JPA і буде видалений з бази даних.\n      <ul>\n        <li>При коміті транзакції об'єкт переходить у стан <strong>detached</strong>.</li>\n      </ul>\n  </li>\n</ul>","topicName":"Hibernate"},{"id":429,"questionText":"Як впливає операція persist на Entity-об'єкти кожного з чотирьох статусів?","answer":"<ul>\n  <li><strong>new (transient)</strong> → managed: об'єкт буде збережений у базі при <em>commit</em> транзакції або в результаті <em>flush</em>-операцій.</li>\n  <li><strong>managed</strong> → операція ігнорується, проте залежні entity можуть змінити статус на managed, якщо вони мають анотації каскадних змін.</li>\n  <li><strong>detached</strong> → виникає <strong>exception</strong> одразу або на етапі <em>commit</em> транзакції.</li>\n  <li><strong>removed</strong> → стає managed, але лише в рамках однієї транзакції.</li>\n</ul>","topicName":"Hibernate"},{"id":430,"questionText":"Як впливає операція remove на Entity-об'єкти кожного з чотирьох статусів?","answer":"<ul>\n  <li><strong>new (transient)</strong> → операція ігнорується, проте залежні entity можуть змінити статус на <strong>removed</strong>, якщо вони мають анотації каскадних змін і знаходяться у статусі <strong>managed</strong>.</li>\n  <li><strong>managed</strong> → стає <strong>removed</strong>: запис об'єкта буде видалено з бази при <em>commit</em> транзакції, також відбудуться операції remove для всіх каскадно-залежних об'єктів.</li>\n  <li><strong>detached</strong> → виникає <strong>exception</strong> одразу або на етапі <em>commit</em> транзакції.</li>\n  <li><strong>removed</strong> → операція ігнорується.</li>\n</ul>","topicName":"Hibernate"},{"id":431,"questionText":"Як впливає операція merge на Entity-об'єкти кожного з чотирьох статусів?","answer":"<ul>\n  <li><strong>new (transient)</strong> → створюється новий managed entity, в який копіюються дані попереднього об'єкта.</li>\n  <li><strong>managed</strong> → операція ігнорується, проте merge відбувається для каскадно-залежних entity, якщо їх статус не managed.</li>\n  <li><strong>detached</strong> → дані копіюються в існуючий managed entity з тим же первинним ключем або створюється новий managed entity, куди копіюються дані.</li>\n  <li><strong>removed</strong> → виникає <strong>exception</strong> одразу або на етапі <em>commit</em> транзакції.</li>\n</ul>","topicName":"Hibernate"},{"id":432,"questionText":"Як впливає операція refresh на Entity-об'єкти кожного з чотирьох статусів?","answer":"<ul>\n  <li><strong>managed</strong> → всі зміни з бази даних для даної entity будуть відновлені, також відбудеться refresh для всіх каскадно-залежних об'єктів.</li>\n  <li><strong>new (transient), removed, detached</strong> → виникає <strong>exception</strong>.</li>\n</ul>","topicName":"Hibernate"},{"id":433,"questionText":"Як впливає операція detach на Entity-об'єкти кожного з чотирьох статусів?","answer":"<ul>\n  <li><strong>managed, removed</strong> → переходять у статус <strong>detached</strong>.</li>\n  <li><strong>new (transient), detached</strong> → операція ігнорується.</li>\n</ul>","topicName":"Hibernate"},{"id":434,"questionText":"Для чого потрібна анотація @Basic?","answer":"<p>Анотація <code>@Basic</code> використовується для найпростішого мапування поля entity на колонку таблиці бази даних. Вона дозволяє задати стратегію завантаження поля та визначити, чи обов'язковим є це поле.</p>\n\n<h3>Типи полів, до яких можна застосувати @Basic:</h3>\n<ul>\n  <li>Примітиви та їх обгортки</li>\n  <li><code>java.lang.String</code></li>\n  <li><code>java.math.BigInteger</code>, <code>java.math.BigDecimal</code></li>\n  <li><code>java.util.Date</code>, <code>java.util.Calendar</code></li>\n  <li><code>java.sql.Date</code>, <code>java.sql.Time</code>, <code>java.sql.Timestamp</code></li>\n  <li><code>byte[]</code> або <code>Byte[]</code></li>\n  <li><code>char[]</code> або <code>Character[]</code></li>\n  <li>Enums</li>\n  <li>Будь-які інші типи, що реалізують <code>Serializable</code></li>\n</ul>\n\n<p>Анотацію <code>@Basic</code> можна не вказувати, бо за замовчуванням JPA застосовує базове мапування.</p>\n\n<h3>Основні атрибути анотації @Basic:</h3>\n<ul>\n  <li><strong>optional</strong> – boolean (за замовчуванням <code>true</code>)  \n      <ul>\n        <li>Визначає, чи може поле мати значення <code>null</code>.</li>\n        <li>Ігнорується для примітивних типів.</li>\n        <li>Якщо поле не примітивне і має <code>null</code> при збереженні, буде викинуто виняток.</li>\n      </ul>\n  </li>\n  <li><strong>fetch</strong> – <code>FetchType</code> (за замовчуванням <code>EAGER</code>)  \n      <ul>\n        <li>Визначає, чи поле завантажується негайно (<code>EAGER</code>) або ліниво (<code>LAZY</code>).</li>\n        <li>JPA дозволяє провайдерам завантажувати дані негайно навіть для <code>LAZY</code>-полів.</li>\n      </ul>\n  </li>\n</ul>\n\n<p>Без явного використання <code>@Basic</code> всі базові поля entity завантажуються <strong>eagerly</strong>, і їх значення можуть бути <code>null</code>.</p>","topicName":"Hibernate"},{"id":435,"questionText":"Для чого потрібна анотація @Column?","answer":"<p>Анотація <code>@Column</code> використовується для мапування поля класу на стовпець таблиці бази даних. Вона дозволяє налаштовувати поведінку цього стовпця та використовується під час генерації схеми бази даних.</p>","topicName":"Hibernate"},{"id":436,"questionText":"Яка різниця між @Basic та @Column?","answer":"<p>Ці дві анотації використовуються для мапування полів entity, але мають різне призначення:</p>\n\n<ul>\n  <li><strong>@Basic</strong>\n    <ul>\n      <li>Застосовується до сутностей JPA.</li>\n      <li>Має атрибут <code>optional</code>, який визначає, чи може поле об'єкта бути <code>null</code>.</li>\n      <li>Дозволяє вказати стратегію завантаження поля: <code>LAZY</code> або <code>EAGER</code>.</li>\n      <li>Вказує тип доступу до поля.</li>\n    </ul>\n  </li>\n\n  <li><strong>@Column</strong>\n    <ul>\n      <li>Застосовується до стовпців таблиці бази даних.</li>\n      <li>Має атрибут <code>nullable</code>, який визначає, чи може відповідний стовпець бути <code>null</code>.</li>\n      <li>Дозволяє задати ім'я стовпця, а також інші властивості, такі як:\n        <ul>\n          <li><code>insertable/updatable</code> – чи можна додавати або змінювати дані у стовпці (за замовчуванням <code>true</code>);</li>\n          <li><code>length</code> – довжина для рядкових типів даних (за замовчуванням 255).</li>\n        </ul>\n      </li>\n      <li>Вказує обмеження для стовпця.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>Коротко:</strong> <code>@Column</code> використовується для обмежень і конфігурації стовпця в БД, а <code>@Basic</code> – для типу доступу та поведінки поля у JPA.</p>","topicName":"Hibernate"},{"id":437,"questionText":"Для чого потрібна анотація @Access?","answer":"<p>Анотація <code>@Access</code> визначає спосіб доступу JPA/Hibernate до полів сутності для читання та запису.</p>\n\n<h3>Типи доступу:</h3>\n\n<ul>\n  <li><strong>Field access (доступ за полями)</strong> – анотації мапінгу (<code>@Id</code>, <code>@Column</code> тощо) розміщуються над полями. Hibernate безпосередньо читає та записує значення полів.</li>\n  \n  <li><strong>Property access (доступ за властивостями)</strong> – анотації розміщуються над методами-геттерами (не над сеттерами). Hibernate працює через геттери та сеттери для доступу до значень.</li>\n</ul>\n\n<p><strong>За замовчуванням</strong>, тип доступу визначається місцем розташування анотації <code>@Id</code>:</p>\n<ul>\n  <li>Якщо <code>@Id</code> над полем – <code>AccessType.FIELD</code></li>\n  <li>Якщо <code>@Id</code> над геттером – <code>AccessType.PROPERTY</code></li>\n</ul>\n\n<p>Щоб явно задати тип доступу у сутності, суперкласі (<code>MappedSuperclass</code>) або в <code>Embeddable</code> класі, використовується <code>@Access</code> над класом, полем або методом.</p>\n\n<p>Зауваження:</p>\n<ul>\n  <li>Поля, успадковані від суперкласу, успадковують тип доступу суперкласу.</li>\n  <li>Якщо у сутності використовується різний тип доступу для полів і властивостей, слід позначати дублікати мапінгу анотацією <code>@Transient</code>, щоб уникнути конфліктів.</li>\n</ul>","topicName":"Hibernate"},{"id":438,"questionText":"Для чого потрібна анотація @Cacheable?","answer":"<p>Анотація <code>@Cacheable</code> – необов’язкова анотація JPA, яка вказує, чи повинна сутність зберігатися в кеші другого рівня.</p>\n\n<p>В JPA є п’ять значень <code>shared-cache-mode</code> у <code>persistence.xml</code>, що визначають використання кешу другого рівня:</p>\n\n<ul>\n  <li><strong>ENABLE_SELECTIVE</strong> – тільки сутності з анотацією <code>@Cacheable</code> (еквівалент <code>@Cacheable(true)</code>) зберігатимуться в кеші другого рівня.</li>\n  <li><strong>DISABLE_SELECTIVE</strong> – всі сутності кешуються, окрім тих, які позначені <code>@Cacheable(false)</code> як некешовані.</li>\n  <li><strong>ALL</strong> – всі сутності завжди кешуються, навіть якщо вони позначені як некешовані.</li>\n  <li><strong>NONE</strong> – жодна сутність не кешується, навіть якщо позначена як кешована. Використовується для повного вимкнення кешу другого рівня.</li>\n  <li><strong>UNSPECIFIED</strong> – застосовуються значення за замовчуванням, визначені провайдером (наприклад, Hibernate), зазвичай кеш другого рівня не активується.</li>\n</ul>\n\n<p>Анотація <code>@Cacheable</code> розміщується над класом сутності. Вона поширює свою дію на спадкоємців сутності, якщо ті не визначили інше.</p>","topicName":"Hibernate"},{"id":439,"questionText":"Для чого потрібні анотації @Embedded та @Embeddable?","answer":"<p><strong>@Embeddable</strong> – анотація JPA, яку розміщують над класом, щоб вказати, що цей клас є вбудовуваним і може використовуватися як частина інших класів-сутностей.</p>\n\n<p><strong>@Embedded</strong> – анотація JPA, яку розміщують над полем у класі-сутності, щоб вказати, що це поле містить вбудований клас, позначений <code>@Embeddable</code>.</p>\n\n<p>Іншими словами, <code>@Embeddable</code> визначає «вбудовуваний» клас, а <code>@Embedded</code> – місце його використання в сутності.</p>","topicName":"Hibernate"},{"id":440,"questionText":"Як відобразити складений ключ?","answer":"<p>Складений первинний ключ (composite key) — це комбінація двох або більше стовпців таблиці, які разом утворюють первинний ключ.</p>\n\n<h3>1. Використання @IdClass</h3>\n<p>Приклад: є таблиця <strong>Account</strong> з полями <code>accountNumber</code> та <code>accountType</code>, які разом формують складений ключ.</p>\n<ol>\n  <li>Створюємо клас для ключа, наприклад, <code>ComplexKey</code>, з полями <code>accountNumber</code> та <code>accountType</code>.</li>\n  <li>Анотуємо сутність <code>Account</code> через <code>@IdClass(ComplexKey.class)</code>.</li>\n  <li>Поля класу ключа в сутності оголошуємо з такими самими іменами та анотуємо <code>@Id</code>.</li>\n</ol>\n\n<h3>2. Використання @EmbeddedId</h3>\n<p>Приклад: таблиця <strong>Book</strong> з полями <code>title</code> та <code>language</code> як складений ключ.</p>\n<ol>\n  <li>Створюємо клас первинного ключа, наприклад, <code>BookId</code>, і анотуємо його <code>@Embeddable</code>.</li>\n  <li>Вбудовуємо цей клас у сутність <code>Book</code> через поле, анотоване <code>@EmbeddedId</code>.</li>\n</ol>\n\n<p>Коротко: <code>@IdClass</code> використовується для зовнішнього класу ключа з окремими полями у сутності, а <code>@EmbeddedId</code> — для вбудованого ключа як одного об’єкта.</p>","topicName":"Hibernate"},{"id":441,"questionText":"Для чого потрібна анотація @Id? Які @GeneratedValue ви знаєте?","answer":"<p><strong>@Id</strong> визначає простий (не складений) первинний ключ сутності, що складається з одного поля. Допустимі типи атрибутів для первинного ключа за JPA:</p>\n<ul>\n  <li>примітивні типи та їх обгортки;</li>\n  <li>рядки (String);</li>\n  <li>BigDecimal і BigInteger;</li>\n  <li>java.util.Date та java.sql.Date.</li>\n</ul>\n\n<p>Якщо потрібно, щоб значення первинного ключа генерувалося автоматично, використовується <strong>@GeneratedValue</strong> разом із <strong>@Id</strong>. Існує чотири основні стратегії генерації:</p>\n\n<h3>1. AUTO (за замовчуванням)</h3>\n<p>Hibernate самостійно обирає стратегію для конкретної бази даних, враховуючи її діалект. Використовується тип поля для визначення підходящого способу генерації.</p>\n\n<h3>2. IDENTITY</h3>\n<p>Використовує стовпець IDENTITY у базі даних, значення якого автоматично збільшуються на стороні бази. Кожна вставка отримує новий унікальний ідентифікатор незалежно від транзакцій.</p>\n\n<h3>3. SEQUENCE</h3>\n<p>Hibernate використовує об'єкт бази даних <strong>Sequence</strong> для отримання інкрементних значень ключа. Якщо база даних не підтримує SEQUENCE, Hibernate автоматично перемикається на TABLE. В проміжках транзакцій сутність не буде збережена до отримання нового id.</p>\n\n<h3>4. TABLE</h3>\n<p>Створюється спеціальна таблиця для зберігання значень ключів для всіх сутностей. Потребує використання песимістичних блокувань, що забезпечує послідовне отримання значень, але може уповільнювати роботу додатка.</p>","topicName":"Hibernate"},{"id":442,"questionText":"Розкажіть про анотації @JoinColumn і @JoinTable? Де і для чого вони використовуються?","answer":"<p><strong>@JoinColumn</strong> використовується для вказівки стовпця <em>FOREIGN KEY</em>, який використовується при встановленні зв'язків між сутностями або колекціями. Лише сутність-власник зв'язку може мати зовнішні ключі від іншої сутності. Стовпець із зовнішнім ключем завжди з'являється в таблиці власника зв'язку.</p>\n\n<h3>Особливості використання @JoinColumn:</h3>\n<ul>\n  <li><strong>@OneToOne:</strong> у таблиці сутності-власника з’являється стовпець з зовнішнім ключем, що посилається на первинний ключ іншої сутності.</li>\n  <li><strong>@OneToMany / @ManyToOne:</strong> якщо не вказати <em>mappedBy</em> на стороні власника, створюється <em>joinTable</em> з ключами обох таблиць. Проте у власника все одно створюється стовпець із зовнішніми ключами.</li>\n</ul>\n\n<p><strong>@JoinColumns</strong> використовується для групування кількох анотацій @JoinColumn. Це актуально, коли зв'язок здійснюється через складений первинний ключ і потрібно кілька стовпців для зовнішнього ключа. Кожна анотація @JoinColumn повинна містити атрибути <strong>name</strong> та <strong>referencedColumnName</strong>.</p>\n\n<p><strong>@JoinTable</strong> використовується для визначення сполучувальної (зведеної, третьої) таблиці між двома іншими таблицями. Зазвичай застосовується у зв'язках <em>ManyToMany</em> або у випадках, коли потрібна окрема таблиця для асоціацій між сутностями.</p>","topicName":"Hibernate"},{"id":443,"questionText":"Для чого потрібні анотації @OrderBy і @OrderColumn, чим вони відрізняються?","answer":"<p><strong>@OrderBy</strong> використовується для визначення порядку елементів колекцій сутностей, основних або вбудованих типів під час їх витягування з бази даних. Вона просто додає <em>ORDER BY</em> до SQL-запиту, тому якщо дані беруться з кешу, сортування не застосовується. Використовується з анотаціями <em>@ElementCollection</em>, <em>@OneToMany</em>, <em>@ManyToMany</em>.</p>\n\n<ul>\n  <li>Для колекцій основних типів (@ElementCollection) елементи впорядковуються за їх природним порядком (значенням).</li>\n  <li>Для колекцій вбудованих типів (@Embeddable) можна вказати атрибут через крапку, наприклад <em>@OrderBy(\"address.city\")</em>.</li>\n  <li>Для колекцій сутностей можна вказати поле сутності для сортування. Якщо параметр не вказано, використовується первинний ключ.</li>\n  <li>Зверніть увагу: доступ до вкладених полів сутності через точку не підтримується – приклад <em>@OrderBy(\"supervisor.name\")</em> викличе RuntimeException.</li>\n</ul>\n\n<p><strong>@OrderColumn</strong> створює у таблиці додатковий стовпець з індексами порядку елементів, що дозволяє зберігати постійний порядок у <em>List</em>. Цей стовпець не є частиною стану сутності або вбудованого класу. Hibernate автоматично підтримує порядок елементів як у базі даних, так і при отриманні сутностей, оновлюючи індекси при додаванні, видаленні або зміні порядку елементів у списку.</p>\n\n<p><strong>Ключова відмінність:</strong> <em>@OrderBy</em> лише сортує елементи під час витягування з бази (не зберігає порядок), а <em>@OrderColumn</em> забезпечує постійне збереження порядку елементів у таблиці.</p>","topicName":"Hibernate"},{"id":444,"questionText":"Для чого потрібна анотація @Transient?","answer":"<p><strong>@Transient</strong> використовується для позначення полів у сутності, вбудованому класі або Mapped SuperClass, які не будуть збережені в базі даних.</p>\n\n<p>У JPA є два типи полів:</p>\n\n<ul>\n  <li><strong>Persistent fields</strong> – постійні поля, значення яких за замовчуванням зберігаються в базі даних. Це будь-які поля, які <em>не static</em> і <em>не final</em>.</li>\n  <li><strong>Transient fields</strong> – тимчасові поля, які не зберігаються в базі даних. Це можуть бути:\n    <ul>\n      <li>static і final поля сутностей;</li>\n      <li>інші поля, явно оголошені за допомогою ключового слова <em>transient</em> в Java або анотації <em>@Transient</em> в JPA.</li>\n    </ul>\n  </li>\n</ul>","topicName":"Hibernate"},{"id":445,"questionText":"Які шість видів блокувань (LockModeType) існують у JPA?","answer":"<p>У JPA є шість видів блокувань, від найменш надійного та швидкого до найнадійнішого та повільного:</p>\n\n<ul>\n  <li><strong>NONE</strong> – без блокування.</li>\n\n  <li><strong>OPTIMISTIC</strong> – оптимістичне блокування (синонім READ у JPA 1). Транзакції виконуються паралельно, але при завершенні перевіряється, чи не змінилося поле <em>@Version</em>. Якщо змінилося – транзакція переривається з <em>OptimisticLockException</em>.</li>\n\n  <li><strong>OPTIMISTIC_FORCE_INCREMENT</strong> – працює як OPTIMISTIC, але після commit поле <em>@Version</em> примусово збільшується на 1, навіть якщо сутність не змінювалася.</li>\n\n  <li><strong>PESSIMISTIC_READ</strong> – дані блокуються при читанні, щоб інші транзакції не могли їх змінювати. Інші транзакції можуть читати ці дані паралельно. Може викликати очікування або <em>PessimisticLockException</em>.</li>\n\n  <li><strong>PESSIMISTIC_WRITE</strong> – дані блокуються при записі; ніхто не може читати або писати до завершення транзакції. Може викликати тривале очікування.</li>\n\n  <li><strong>PESSIMISTIC_FORCE_INCREMENT</strong> – як PESSIMISTIC_WRITE, але після завершення транзакції поле <em>@Version</em> збільшується, навіть якщо сутність не змінилася.</li>\n</ul>\n\n<h3>Оптимістичне блокування</h3>\n<p>Передбачає, що транзакції рідко змінюють одні й ті ж дані одночасно. Використовується поле <em>@Version</em>, яке контролює зміни:</p>\n<pre>\n@Version\nprivate long version;\n</pre>\n<p>Якщо значення <em>@Version</em> змінилося під час виконання транзакції, буде викинуто <em>OptimisticLockException</em>. Це дозволяє уникати блокувань на рівні БД і покращує конкурентність.</p>\n\n<h3>Песимістичне блокування</h3>\n<p>Орієнтоване на випадки, коли транзакції часто конкурують за одні й ті ж дані. Доступ блокується при читанні, інші транзакції чекають або отримують виняток.</p>\n\n<h3>Приклад встановлення блокування</h3>\n<pre>\nEntityManager em = entityManagerFactory.createEntityManager();\nem.lock(company1, LockModeType.OPTIMISTIC);\n</pre>","topicName":"Hibernate"},{"id":446,"questionText":"Які два види кешів існують у JPA і для чого вони потрібні?","answer":"<p>У JPA є два види кешів:</p>\n\n<ul>\n  <li><strong>Кеш першого рівня (first-level cache)</strong> – кешує дані в межах однієї транзакції (сесії). Він є обов'язковим і представляє собою <em>PersistenceContext</em>.</li>\n  <li><strong>Кеш другого рівня (second-level cache)</strong> – кешує дані між сесіями від однієї фабрики сесій (SessionFactory). Його використання необов’язкове і вимагає налаштування.</li>\n</ul>\n\n<h3>Особливості кеша першого рівня</h3>\n<ul>\n  <li>Включений за замовчуванням і не може бути вимкнений.</li>\n  <li>Пов'язаний з конкретною сесією; різні сесії не бачать об'єкти один одного.</li>\n  <li>При закритті сесії кеш очищається.</li>\n  <li>При першому запиті сутність завантажується з БД і зберігається в кеші.</li>\n  <li>Подальші запити до тієї ж сутності беруть дані з кешу, без повторного SQL-запиту.</li>\n  <li>Метод <code>evict()</code> видаляє конкретну сутність із кешу, а <code>clear()</code> очищає весь кеш сесії.</li>\n</ul>\n\n<h3>Особливості кеша другого рівня</h3>\n<ul>\n  <li>Прив'язаний до об'єкта фабрики сесій, тому доступний для кількох сесій одночасно.</li>\n  <li>Використання потребує конфігурації: потрібно вибрати реалізацію кешу (наприклад, Ehcache, Infinispan) і дозволити кешування сутностей.</li>\n  <li>Читання з кеша другого рівня відбувається лише якщо сутність не знайдена в кеші першого рівня.</li>\n  <li>Для увімкнення кеша другого рівня в Hibernate додають властивості:</li>\n</ul>\n\n<pre>\nhibernate.cache.use_second_level_cache=true\nhibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory\n</pre>\n\n<p>Також потрібно анотувати сутності:</p>\n<ul>\n  <li><code>@Cacheable</code> – вказує, що сутність може кешуватися.</li>\n  <li><code>@Cache</code> (Hibernate) – налаштовує деталі кешування і стратегію паралельного доступу.</li>\n</ul>","topicName":"Hibernate"},{"id":447,"questionText":"Які стратегії паралельного доступу до об'єктів існують у кеші другого рівня?","answer":"<p>Проблема полягає в тому, що кеш другого рівня доступний з кількох сесій одночасно, і декілька потоків можуть паралельно працювати з одним і тим же об'єктом. Для забезпечення узгодженого представлення об'єкта використовуються різні стратегії паралельного доступу:</p>\n\n<ul>\n  <li><strong>READ_ONLY</strong> – використовується тільки для сутностей, які ніколи не змінюються. Якщо спробувати оновити таку сутність, буде викинуто виняток. Підходить для статичних даних. Проста і продуктивна стратегія.</li>\n  \n  <li><strong>NONSTRICT_READ_WRITE</strong> – кеш оновлюється після завершення транзакції, яка змінила дані в БД. Строга відповідність не гарантується: між оновленням БД і кешу існує невелике вікно, під час якого інші транзакції можуть отримати застарілі дані.</li>\n  \n  <li><strong>READ_WRITE</strong> – забезпечує строгий контроль відповідності через «м'які» блокування. Під час оновлення кешованої сутності на неї накладається блокування, яке знімається після коміту транзакції. Паралельні транзакції не можуть читати або писати ці записи в кеші і надсилають запит безпосередньо в БД. Ця стратегія використовується в Ehcache за замовчуванням.</li>\n  \n  <li><strong>TRANSACTIONAL</strong> – забезпечує повноцінне розділення транзакцій. Кожна сесія бачить об'єкти так, ніби транзакції виконуються послідовно одна за одною. Плата за це – блокування і зниження продуктивності.</li>\n</ul>","topicName":"Hibernate"},{"id":448,"questionText":"Що таке JPQL/HQL і чим він відрізняється від SQL?","answer":"<p><strong>Hibernate Query Language (HQL)</strong> і <strong>Java Persistence Query Language (JPQL)</strong> – це об'єктно-орієнтовані мови запитів, схожі на SQL. JPQL є підмножиною HQL.</p>\n\n<p><strong>Особливості JPQL:</strong></p>\n<ul>\n  <li>Замість імен таблиць і стовпців використовується імена класів <em>Entity</em> та їх атрибутів.</li>\n  <li>Параметри запиту відповідають типам атрибутів Entity, а не полям БД.</li>\n  <li>Є автоматичний поліморфізм: запит до Entity повертає об'єкти цього Entity та всіх його нащадків, незалежно від стратегії наслідування.</li>\n  <li>Запит у JPA представлений у вигляді <code>javax.persistence.Query</code> або <code>javax.persistence.TypedQuery</code>, отриманих від <code>EntityManager</code>.</li>\n</ul>\n\n<p><strong>Особливості HQL у Hibernate:</strong></p>\n<ul>\n  <li>Представлений <code>org.hibernate.query.Query</code>, отриманим від <code>Session</code>.</li>\n  <li>Іменовані запити використовують <code>Session#getNamedQuery</code>, звичайні – <code>Session#createQuery</code>.</li>\n</ul>\n\n<p><strong>Відмінності від SQL:</strong></p>\n<ul>\n  <li>SQL працює з таблицями та стовпцями бази даних, JPQL/HQL – з об'єктами Entity та їх атрибутами.</li>\n  <li>JPQL/HQL підтримує поліморфізм і автоматично включає нащадків Entity у результати запиту.</li>\n</ul>","topicName":"Hibernate"},{"id":449,"questionText":"Що таке Criteria API?","answer":"<p><strong>Hibernate Criteria API</strong> починаючи з версії 5.2 оголошено застарілим. Замість нього рекомендується використовувати <strong>JPA Criteria API</strong>.</p>\n\n<p><strong>JPA Criteria API</strong> – це API для об'єктно-орієнтованого формування <code>select</code>-запитів до бази даних.</p>\n\n<h3>Переваги JPA Criteria API:</h3>\n<ul>\n  <li>Помилки можуть бути виявлені під час компіляції.</li>\n  <li>Дозволяє динамічно формувати запити під час виконання програми.</li>\n</ul>\n\n<h3>Недоліки:</h3>\n<ul>\n  <li>Важко контролювати точний SQL-запит і виявляти помилки.</li>\n  <li>Може впливати на продуктивність через велику кількість класів.</li>\n</ul>\n\n<h3>Області застосування:</h3>\n<ul>\n  <li>Підтримує <strong>проекції</strong> для агрегатних функцій (<code>sum()</code>, <code>min()</code>, <code>max()</code> тощо).</li>\n  <li>Дозволяє вибирати дані лише з обраних стовпців за допомогою <code>ProjectionList</code>.</li>\n  <li>Може виконувати <strong>join-запити</strong> між таблицями через <code>createAlias()</code>, <code>setFetchMode()</code> та <code>setProjection()</code>.</li>\n  <li>Підтримує умови вибірки через <code>add()</code> та обмеження <code>Restrictions</code>.</li>\n  <li>Дозволяє додавати <strong>сортування</strong> результатів через <code>addOrder()</code>.</li>\n</ul>","topicName":"Hibernate"},{"id":450,"questionText":"Що таке проблема N+1 Select і які існують шляхи її вирішення?","answer":"<p><strong>Проблема N+1 Select</strong> виникає, коли отримання даних з бази даних потребує виконання N додаткових SQL-запитів для витягування пов’язаних об’єктів, які можна було б отримати одним основним запитом.</p>\n\n<h3>Способи вирішення:</h3>\n\n<h4>1. JOIN FETCH</h4>\n<p>Дозволяє отримати пов’язані об’єкти одним запитом замість окремих запитів для кожного доступу до лінивих полів:</p>\n<pre>\nselect pc\nfrom PostComment pc\njoin fetch pc.post p\n</pre>\n<p>Працює як з <code>FetchType.EAGER</code>, так і з <code>FetchType.LAZY</code>. Найкраще підходить для простих запитів (1–3 рівні вкладеності).</p>\n\n<h4>2. EntityGraph</h4>\n<p>Дозволяє отримувати багато пов’язаних даних через JPQL-запит, визначаючи граф завантаження сутностей.</p>\n\n<h4>3. @Fetch(FetchMode.SUBSELECT)</h4>\n<p>Анотація Hibernate для колекцій. Виконує один SQL-запит для кореневих сутностей, а потім ще один запит для всіх пов’язаних колекцій:</p>\n<pre>\n@Fetch(value = FetchMode.SUBSELECT)\nprivate Set&lt;Order&gt; orders = new HashSet&lt;&gt;();\n</pre>\n\n<h4>4. Batch fetching (@BatchSize)</h4>\n<p>Анотація Hibernate, що дозволяє завантажувати декілька сутностей або колекцій одним запитом. Застосовується над сутністю або полем колекції:</p>\n<pre>\n@BatchSize(size=5)\nprivate Set&lt;Order&gt; orders = new HashSet&lt;&gt;();\n</pre>\n\n<h4>5. HibernateSpecificMapping / SqlResultSetMapping</h4>\n<p>Рекомендується для нативних SQL-запитів, коли необхідно точно контролювати вибірку даних.</p>","topicName":"Hibernate"},{"id":451,"questionText":"Що таке EntityGraph? Як і для чого їх використовувати?","answer":"<p><strong>EntityGraph</strong> – це механізм JPA, який дозволяє контролювати завантаження сутностей та їхніх пов’язаних об’єктів для підвищення продуктивності.</p>\n\n<h3>Мета використання:</h3>\n<ul>\n  <li>Оптимізувати SELECT-запити, щоб отримати всі необхідні поля та зв’язані сутності в одному запиті.</li>\n  <li>Зменшити проблему N+1 Select при вибірці пов’язаних даних.</li>\n</ul>\n\n<h3>Як працює:</h3>\n<p>Hibernate завантажує весь граф сутностей, вказаний у EntityGraph, одним SELECT-запитом. Для вкладених зв’язків можна використовувати <strong>Subgraph</strong>.</p>\n\n<h3>Приклад створення EntityGraph:</h3>\n<pre>\nEntityGraph&lt;Post&gt; entityGraph = entityManager.createEntityGraph(Post.class);\nentityGraph.addAttributeNodes(\"subject\");\nentityGraph.addAttributeNodes(\"user\");\nentityGraph.addSubgraph(\"comments\").addAttributeNodes(\"user\");\n</pre>\n\n<h3>Стратегії завантаження:</h3>\n<ul>\n  <li><strong>fetchgraph</strong> – всі атрибути з EntityGraph отримують <code>FetchType.EAGER</code>, інші – <code>LAZY</code>.</li>\n  <li><strong>loadgraph</strong> – атрибути з EntityGraph отримують <code>FetchType.EAGER</code>, інші зберігають свій <code>fetchType</code>.</li>\n</ul>\n\n<h3>Способи завантаження EntityGraph:</h3>\n<ol>\n  <li>Через перевантажений метод <code>find()</code>, передаючи Map з налаштуваннями EntityGraph.</li>\n  <li>Через JPQL, передаючи підказку через <code>setHint()</code>.</li>\n  <li>За допомогою <strong>Criteria API</strong>.</li>\n</ol>","topicName":"Hibernate"},{"id":452,"questionText":"Що таке мемоізація (Memoization)?","answer":"<p><strong>Мемоізація</strong> – це техніка кешування результатів функції для прискорення роботи програми. Ідея полягає в тому, що результат обчислення функції для певних параметрів зберігається у таблиці, і при повторному виклику з тими ж параметрами результат береться з таблиці замість повторного обчислення.</p>\n\n<h3>Вимоги до функцій для мемоізації:</h3>\n<ul>\n  <li>Функція повинна бути <strong>детермінованою</strong> – при однакових параметрах завжди повертає однаковий результат.</li>\n  <li>Функція не повинна мати <strong>побічних ефектів</strong> – не змінювати стан системи.</li>\n</ul>\n\n<h3>Реалізація в Java:</h3>\n<p>Для збереження результатів найзручніше використовувати інтерфейс <code>Map</code>, оскільки операції <code>get</code>, <code>put</code> та <code>contains</code> виконуються за O(1), що забезпечує швидкий доступ до кешованих результатів.</p>\n\n<h3>Бібліотеки:</h3>\n<p>Мемоізація реалізована у бібліотеці <strong>Ehcache</strong>, яка дозволяє ефективно зберігати та отримувати кешовані дані.</p>","topicName":"Hibernate"},{"id":453,"questionText":"Що таке інверсія контролю (IoC) і внедрення залежностей (DI)? Як ці принципи реалізовані в Spring?","answer":"<p><strong>Інверсія контролю (IoC)</strong> – це підхід, який дозволяє фреймворку управляти об'єктами Java замість ручного створення та конфігурації. Контейнер IoC відповідає за:</p>\n<ul>\n  <li>створення об'єктів (бінів);</li>\n  <li>виклик методів ініціалізації;</li>\n  <li>зв'язування об'єктів між собою (конфігурація).</li>\n</ul>\n\n<p>Об'єкти, створені контейнером, називаються <strong>бінами</strong>. Конфігурація контейнера може здійснюватися:</p>\n<ul>\n  <li>через анотації у коді;</li>\n  <li>за допомогою XML-файлів, які містять визначення бінів та їх залежностей.</li>\n</ul>\n\n<h3>Dependency Injection (DI)</h3>\n<p><strong>Впровадження залежностей (DI)</strong> – це спосіб реалізації IoC у Spring. Контейнер передає об'єкти іншим об'єктам, забезпечуючи слабке зв'язування:</p>\n<ul>\n  <li>через <strong>конструктор</strong> – залежності передаються під час створення об'єкта;</li>\n  <li>через <strong>setter-методи</strong> – залежності задаються після створення об'єкта.</li>\n</ul>\n\n<p>Завдяки DI код стає більш гнучким, легким для тестування та підтримки.</p>","topicName":"Spring"},{"id":454,"questionText":"Що таке IoC контейнер?","answer":"<p><strong>IoC контейнер</strong> – це компонент Spring, який відповідає за створення, конфігурацію та управління життєвим циклом об'єктів (бінів) у додатку.</p>\n\n<p>У Spring IoC-контейнер представлений такими інтерфейсами:</p>\n<ul>\n  <li><strong>ApplicationContext</strong> – розширює можливості BeanFactory і надає додаткові функції, такі як AOP та підтримка транзакцій.</li>\n  <li><strong>BeanFactory</strong> – базовий контейнер, який забезпечує фабрику для створення бінів та їхнє управління.</li>\n</ul>\n\n<p>Контейнер працює на основі конфігурацій:</p>\n<ul>\n  <li>через анотації у коді;</li>\n  <li>через XML-файли з визначеннями бінів.</li>\n</ul>\n\n<p>Основні функції IoC-контейнера:</p>\n<ul>\n  <li>створює об'єкти на основі конфігурації;</li>\n  <li>впроваджує залежності між об'єктами;</li>\n  <li>керує життєвим циклом бінів – від створення до знищення.</li>\n</ul>","topicName":"Spring"},{"id":455,"questionText":"Розкажіть про ApplicationContext і BeanFactory, чим вони відрізняються? В яких випадках слід використовувати кожне з них?","answer":"<p><strong>BeanFactory</strong> – це базовий IoC-контейнер Spring, який:</p>\n<ul>\n  <li>створює, налаштовує та управляє бін-об'єктами;</li>\n  <li>підтримує залежності між бін-об'єктами;</li>\n  <li>працює з областями видимості singleton та prototype;</li>\n  <li>завантажує біни <strong>за вимогою</strong>, тобто лише при першому зверненні до них;</li>\n  <li>легший за ApplicationContext, тому підходить для ресурсно-обмежених середовищ (мобільні пристрої, маленькі додатки).</li>\n</ul>\n\n<p><strong>ApplicationContext</strong> – розширення BeanFactory, яке додатково надає:</p>\n<ul>\n  <li>автоматичну реєстрацію <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html\">BeanPostProcessor</a>;</li>\n  <li>автоматичну реєстрацію <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html\">BeanFactoryPostProcessor</a>;</li>\n  <li>зручний доступ до <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/MessageSource.html\">MessageSource</a> для інтернаціоналізації;</li>\n  <li>публікацію <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationEvent.html\">ApplicationEvent</a> подій;</li>\n  <li>завантажує всі біни <strong>під час старту</strong>, що дозволяє виявляти помилки конфігурації раніше.</li>\n</ul>\n\n<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n  <tr>\n    <th>Функціонал</th>\n    <th>BeanFactory</th>\n    <th>ApplicationContext</th>\n  </tr>\n  <tr>\n    <td>Ініціалізація / автоматичне зв'язування біна</td>\n    <td>Так</td>\n    <td>Так</td>\n  </tr>\n  <tr>\n    <td>Автоматична реєстрація BeanPostProcessor</td>\n    <td>Ні</td>\n    <td>Так</td>\n  </tr>\n  <tr>\n    <td>Автоматична реєстрація BeanFactoryPostProcessor</td>\n    <td>Ні</td>\n    <td>Так</td>\n  </tr>\n  <tr>\n    <td>Зручний доступ до MessageSource</td>\n    <td>Ні</td>\n    <td>Так</td>\n  </tr>\n  <tr>\n    <td>ApplicationEvent публікація</td>\n    <td>Ні</td>\n    <td>Так</td>\n  </tr>\n</table>\n\n<p><strong>Висновок:</strong> BeanFactory підходить для легких та ресурсно-обмежених додатків, ApplicationContext – для більшості стандартних корпоративних додатків, де потрібні розширені можливості управління бін-об’єктами та інтеграція з іншими сервісами Spring.</p>","topicName":"Spring"},{"id":456,"questionText":"Розкажіть про анотацію @Bean","answer":"<p>Анотація <code>@Bean</code> використовується для вказівки на те, що метод створює, налаштовує та ініціалізує новий об'єкт, керований контейнером IoC. Такі методи можна використовувати як у класах з анотацією <code>@Configuration</code>, так і в класах з анотацією <code>@Component</code> (або її нащадках).</p> <p>Має наступні властивості:</p> <ul> <li><strong>destroyMethod, initMethod</strong> – варіанти перевизначення методів ініціалізації та видалення біна при вказівці їхніх імен в анотації;</li> <li><strong>name</strong> – ім'я біна, за замовчуванням ім'ям біна є ім'я методу;</li> <li><strong>value</strong> – аліас для <code>name()</code>;</li> </ul>","topicName":"Spring"},{"id":457,"questionText":"Розкажіть про анотацію @Component?","answer":"<p><code>@Component</code> використовується для вказівки класу як компонента Spring. Такий клас буде сконфігурований як Spring Bean.</p>","topicName":"Spring"},{"id":458,"questionText":"Чим відрізняються анотації @Bean і @Component?","answer":"<p><code>@Bean</code> ставиться над методом і дозволяє додати бін вже реалізованого класу сторонньої бібліотеки в контейнер, а <code>@Component</code> використовується для вказівки класу, написаного програмістом.</p>","topicName":"Spring"},{"id":459,"questionText":"Розкажіть про анотації @Service і @Repository. Чим вони відрізняються?","answer":"p><code>@Repository</code> вказує, що клас використовується для роботи з пошуком, отриманням і зберіганням даних. Анотація може використовуватися для реалізації шаблону DAO.</p>\n<p><code>@Service</code> вказує, що клас є сервісом для реалізації бізнес-логіки.</p>\n<p><code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> і <code>@Configuration</code> є аліасами <code>@Component</code>, їх також називають стереотипними анотаціями.</p>\n<p>Задача <code>@Repository</code> полягає в тому, щоб ловити певні винятки персистентності і пропускати їх як одне неперевірене виняток у Spring Framework. Для цього в контексті повинен бути доданий клас <code>PersistenceExceptionTranslationPostProcessor</code>.</p>","topicName":"Spring"},{"id":460,"questionText":"Розкажіть про анотацію @Autowired","answer":"<p><code>@Autowired</code> використовується для автоматичного впровадження (injection) відповідного біна у Spring-контейнері.</p>\n\n<h3>Принцип роботи:</h3>\n<ul>\n  <li>Контейнер визначає тип об'єкта для впровадження.</li>\n  <li>Контейнер шукає відповідний бін у контексті (контейнері).</li>\n  <li>Якщо є декілька кандидатів і один з них відмічений як <code>@Primary</code>, то впроваджується він.</li>\n  <li>Якщо використовується <code>@Qualifier</code>, контейнер враховує його, щоб визначити, який компонент впроваджувати.</li>\n  <li>Інакше контейнер намагається впровадити бін за його ім'ям або ID.</li>\n  <li>Якщо жоден з варіантів не підходить — викидається виняток.</li>\n</ul>\n\n<h3>Особливості:</h3>\n<ul>\n  <li>DI (Dependency Injection) обробляється через <code>AutowiredAnnotationBeanPostProcessor</code>, тому анотацію не можна використовувати в BeanFactoryPP або BeanPP.</li>\n  <li>Параметр <code>required</code> (true/false) вказує, чи обов'язково виконувати DI. За замовчуванням — <code>true</code>. Якщо <code>false</code>, поле залишиться <code>null</code>, якщо бін не знайдено.</li>\n  <li>Циклічні залежності не можна впроваджувати через конструктор, але можна через поля.</li>\n</ul>\n\n<h3>Обмеження впровадження через поля:</h3>\n<ul>\n  <li>Об'єкт створюється за допомогою конструктора за замовчуванням, навіть якщо деякі залежності відсутні, що може призвести до <code>NullPointerException</code>.</li>\n  <li>Такий клас не може бути використаний поза DI-контейнером без рефлексії.</li>\n  <li>Не можна впроваджувати залежності в <code>final</code> поля, тому об'єкти стають змінними.</li>\n</ul>","topicName":"Spring"},{"id":461,"questionText":"Розкажіть про анотацію @Resource","answer":"<p><code>@Resource</code> (Java) використовується для отримання залежності. Пошук відбувається у такому порядку: спочатку за іменем, потім за типом, і наостанок з опису через <code>@Qualifier</code>. Ім'я береться з імені анотованого сеттера або поля, або вказується через параметр <code>name</code>.</p>\n\n<h3>Приклади:</h3>\n<pre>\n<code>@Resource\n// За замовчуванням пошук біна за іменем \"context\"\nprivate ApplicationContext context;\n\n@Resource(name=\"greetingService\")\n// Пошук біна за іменем \"greetingService\"\npublic void setGreetingService(GreetingService service) {\n    this.greetingService = service;\n}\n</code>\n</pre>\n\n<h3>Відмінності від @Autowired:</h3>\n<ul>\n  <li>Пошук біна відбувається спочатку за іменем, потім за типом.</li>\n  <li>Не потрібна додаткова анотація для вказівки імені конкретного біна.</li>\n  <li><code>@Autowired</code> дозволяє вказати, що впровадження необов'язкове через <code>@Autowired(required = false)</code>.</li>\n  <li>При заміні Spring Framework на інший фреймворк не потрібно змінювати анотацію <code>@Resource</code>.</li>\n</ul>","topicName":"Spring"},{"id":462,"questionText":"Розкажіть про анотацію @Inject","answer":"<p><code>@Inject</code> входить до пакету <code>javax.inject</code>. Щоб її використовувати, потрібно додати залежність:</p>\n\n<pre>\n<code>&lt;dependency&gt;\n    &lt;groupId&gt;javax.inject&lt;/groupId&gt;\n    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;\n    &lt;version&gt;1&lt;/version&gt;\n&lt;/dependency&gt;\n</code>\n</pre>\n\n<p><code>@Inject</code> – це Java-анотація, аналогічна <code>@Autowired</code> у Spring. Вона намагається підключити залежність у такому порядку:</p>\n<ol>\n  <li>За типом</li>\n  <li>За описом (Qualifier)</li>\n  <li>За іменем</li>\n</ol>\n\n<p>Анотація <code>@Inject</code> не має параметрів. Щоб вказати конкретне ім'я (ID) біна, використовується <code>@Named</code>:</p>\n\n<pre>\n<code>@Inject\n@Named(\"yetAnotherFieldInjectDependency\")\nprivate ArbitraryDependency yetAnotherFieldInjectDependency;\n</code>\n</pre>","topicName":"Spring"},{"id":463,"questionText":"Розкажіть про анотацію @Lookup","answer":"<p>У Spring біни за замовчуванням є сінглтонами, і для впровадження залежностей зазвичай використовуються конструктор або сеттер.</p>\n\n<p>Але іноді потрібна інша поведінка: наприклад, є бін <code>Car</code> – сінглтон, і для нього потрібен новий екземпляр біна <code>Passenger</code> щоразу при виклику певного методу. Тобто <code>Car</code> – сінглтон, а <code>Passenger</code> – бін-прототип.</p>\n\n<p>У цьому випадку використовується анотація <code>@Lookup</code>:</p>\n<ul>\n  <li>Створюється заглушковий метод у біні <code>Car</code>, який повинен повертати <code>Passenger</code>.</li>\n  <li>Метод позначається анотацією <code>@Lookup</code>.</li>\n  <li>Spring під капотом створює підклас <code>Car</code> і перевизначає цей метод так, щоб при кожному виклику повертати новий екземпляр <code>Passenger</code>.</li>\n  <li>Навіть якщо заглушка методу повертає <code>null</code>, це нормально – метод буде перевизначено контейнером.</li>\n</ul>\n\n<p>Таким чином, <code>@Lookup</code> дозволяє отримувати нові екземпляри прототипних бінів у сінглтон-біні під час виконання.</p>","topicName":"Spring"},{"id":464,"questionText":"Чи можна вставити бін в статичне поле? Чому?","answer":"<p>Spring не дозволяє напряму впроваджувати біни у статичні поля. Це пояснюється тим, що під час завантаження класів завантажувачем класів значення статичних полів встановлюються ще до того, як контекст Spring буде завантажений.</p>\n\n<p>Щоб обійти це обмеження, можна використовувати нестатичний метод-сеттер із <code>@Autowired</code>:</p>\n\n<pre>\n<code>private static OrderItemService orderItemService;\n\n@Autowired\npublic void setOrderItemService(OrderItemService orderItemService) {\n    TestDataInit.orderItemService = orderItemService;\n}\n</code>\n</pre>\n\n<p>Таким чином, Spring впроваджує бін через нестатичний метод, а статичне поле отримує значення після ініціалізації контексту.</p>","topicName":"Spring"},{"id":465,"questionText":"Розкажіть про анотації @Primary та @Qualifier","answer":"<h3>@Qualifier</h3>\n<p><code>@Qualifier</code> використовується, коли існує кілька кандидатів для автоматичного зв'язування. Вона дозволяє вказати ім'я конкретного біна, який слід впровадити. Можна застосовувати до поля класу, аргументу методу або конструктора:</p>\n\n<pre>\n<code>public class AutowiredClass {\n    @Autowired\n    @Qualifier(\"main\")\n    private GreetingService greetingService;\n\n    @Autowired\n    public void prepare(@Qualifier(\"main\") GreetingService greetingService) {\n        // щось робимо...\n    }\n}\n</code>\n</pre>\n\n<p>Одній з реалізацій <code>GreetingService</code> слід додати анотацію <code>@Qualifier</code>:</p>\n\n<pre>\n<code>@Component\n@Qualifier(\"main\")\npublic class GreetingServiceImpl implements GreetingService {\n    // ...\n}\n</code>\n</pre>\n\n<h3>@Primary</h3>\n<p><code>@Primary</code> також використовується для визначення переважного біна, коли є кілька бінів одного типу. На відміну від <code>@Qualifier</code>, вона не дозволяє вказати ім'я біна і просто задає бін за замовчуванням.</p>\n\n<p>Якщо обидві анотації присутні, <code>@Qualifier</code> має пріоритет над <code>@Primary</code>.</p>","topicName":"Spring"},{"id":466,"questionText":"Як заінжектити примітив?","answer":"<p>Щоб впровадити примітиви або значення з конфігурацій, використовується анотація <code>@Value</code>. Її можна ставити над полем, конструктором або методом. Значення можна брати з файлів властивостей, інших бінів або обчислювати за допомогою Spring Expression Language (SpEL).</p>\n\n<h3>Приклад:</h3>\n<pre>\n<code>@Value(\"${some.key}\")\npublic String stringWithDefaultValue;\n</code>\n</pre>\n\n<p>У цю змінну буде внесено рядок, наприклад, з файлу властивостей, або обчислене значення через SpEL.</p>","topicName":"Spring"},{"id":467,"questionText":"Як заінжектити колекцію?","answer":"<p>Якщо поле є масивом, колекцією або мапою з дженериком, Spring може автоматично впровадити всі біни відповідного типу за допомогою анотації <code>@Autowired</code>.</p>\n\n<ul>\n  <li>Для масивів або колекцій будуть внесені всі біни, які підходять за типом.</li>\n  <li>Для мап ключем буде ім'я біна.</li>\n  <li>За допомогою <code>@Qualifier</code> можна уточнити, який бін потрібно впровадити.</li>\n  <li>Біни можуть бути впорядковані, якщо вони вставлені у списки або масиви (не у Set або Map). Підтримуються <code>@Order</code> або інтерфейс <code>Ordered</code>.</li>\n</ul>","topicName":"Spring"},{"id":468,"questionText":"Розкажіть про анотацію @Conditional","answer":"<p><code>@Conditional</code> дозволяє включати або виключати реєстрацію бінів або цілих конфігурацій на основі заданих умов. Як параметр передається клас, що реалізує інтерфейс <code>Condition</code>, який має метод:</p>\n\n<pre>\n<code>boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)\n</code>\n</pre>\n\n<p>Для складніших умов можна використовувати класи <code>AnyNestedCondition</code>, <code>AllNestedConditions</code> та <code>NoneNestedConditions</code>. Анотація гарантує, що компонент буде зареєстрований у контексті лише якщо всі умови виконані.</p>\n\n<p>Умови перевіряються перед реєстрацією <code>BeanDefinition</code> компонента. Під час перевірки не можна взаємодіяти з біном, який ще не створений, але можна використовувати його <code>BeanDefinition</code>.</p>\n\n<p>Щоб перевірити кілька умов одночасно, можна передати декілька класів у <code>@Conditional</code>:</p>\n\n<pre>\n<code>@Conditional(HibernateCondition.class, OurConditionClass.class)\n</code>\n</pre>\n\n<p>Якщо клас <code>@Configuration</code> позначений <code>@Conditional</code>, умови поширюються на всі методи <code>@Bean</code>, анотації <code>@Import</code> та <code>@ComponentScan</code>, пов'язані з цим класом.</p>","topicName":"Spring"},{"id":469,"questionText":"Розкажіть про анотацію @Profile","answer":"<p>Профілі у Spring Framework дозволяють групувати біни в логічні групи для різних середовищ, наприклад: <code>dev</code>, <code>local</code>, <code>test</code>, <code>prod</code>. Це дозволяє активувати лише потрібні біни для конкретного середовища.</p>\n\n<p>Анотація <code>@Profile</code> використовується для того, щоб прив’язати бін до певного профілю. Вона може застосовуватися:</p>\n<ul>\n  <li>На рівні класу</li>\n  <li>На рівні методу</li>\n</ul>\n\n<p><code>@Profile</code> приймає як аргумент одне або декілька імен профілів. Під капотом вона реалізована через більш гнучку анотацію <code>@Conditional</code>.</p>\n\n<p>Анотацію <code>@Profile</code> можна використовувати для класів <code>@Configuration</code> та компонентів <code>@Component</code>.</p>","topicName":"Spring"},{"id":470,"questionText":"Розкажіть про життєвий цикл біна","answer":"<p>Життєвий цикл біна у Spring описує всі етапи від створення об'єкта до його знищення в контейнері IoC. Основні етапи:</p>\n\n<ol>\n  <li><strong>Створення екземпляра:</strong> Spring створює бін за допомогою конструктора (за замовчуванням або визначеного користувачем).</li>\n  <li><strong>Впровадження залежностей (Dependency Injection):</strong> Spring встановлює значення полів, методів і конструкторів, позначених анотаціями <code>@Autowired</code>, <code>@Inject</code> або <code>@Value</code>.</li>\n  <li><strong>Попередня ініціалізація (Pre-initialization):</strong> застосовуються <code>BeanPostProcessor</code>, які можуть змінювати або обгортати бін перед викликом ініціалізаційних методів.</li>\n  <li><strong>Ініціалізація:</strong> Spring викликає методи, позначені <code>init-method</code> у конфігурації або <code>@PostConstruct</code>, щоб завершити налаштування біну.</li>\n  <li><strong>Використання біна:</strong> Бін готовий до використання у додатку, його можна викликати з інших компонентів.</li>\n  <li><strong>Знищення:</strong> при завершенні роботи контейнера Spring викликає методи <code>destroy-method</code> або <code>@PreDestroy</code>, щоб звільнити ресурси та виконати очищення.</li>\n</ol>\n\n<p>Таким чином, Spring керує повним життєвим циклом біну, забезпечуючи впровадження залежностей, обробку ініціалізації та очищення після завершення роботи контейнера.</p>","topicName":"Spring"},{"id":471,"questionText":"Розкажіть про області видимості бінів","answer":"<p>Область видимості (scope) біну визначає, скільки екземплярів цього біну створюється і як довго вони існують у контексті Spring. Spring підтримує кілька стандартних областей видимості:</p>\n\n<ul>\n  <li><strong>singleton</strong> (за замовчуванням) – бін існує в одному екземплярі на весь контекст Spring. Усі звернення до цього біну отримують той самий екземпляр.</li>\n  <li><strong>prototype</strong> – при кожному запиті до контейнера створюється новий екземпляр біну. Життєвий цикл керується поза контейнером після створення.</li>\n  <li><strong>request</strong> – бін існує протягом одного HTTP-запиту (для веб-додатків). Для кожного нового запиту створюється новий екземпляр.</li>\n  <li><strong>session</strong> – бін існує протягом однієї HTTP-сесії. Кожна сесія отримує власний екземпляр.</li>\n  <li><strong>application</strong> – бін існує на рівні сервлет-контексту, тобто один екземпляр для всього веб-додатку.</li>\n  <li><strong>websocket</strong> – бін існує протягом одного WebSocket-з’єднання.</li>\n</ul>\n\n<p>Вибір області видимості дозволяє оптимізувати використання ресурсів і правильно керувати життєвим циклом об’єктів у додатку залежно від потреб.</p>","topicName":"Spring"},{"id":472,"questionText":"Розкажіть про аннотацію @ComponentScan","answer":"<p>Анотація <code>@ComponentScan</code> використовується в Spring для автоматичного сканування пакетів і реєстрації бінів у контексті, які позначені анотаціями <code>@Component</code>, <code>@Service</code>, <code>@Repository</code> або <code>@Controller</code>.</p>\n\n<p>Основні особливості:</p>\n<ul>\n  <li>Вказує пакети для сканування через параметр <code>basePackages</code> або <code>basePackageClasses</code>.</li>\n  <li>Дозволяє автоматично знаходити та реєструвати компоненти без ручного створення <code>@Bean</code> у <code>@Configuration</code>.</li>\n  <li>Може бути використана разом із <code>@Configuration</code> для створення повністю автоматизованої конфігурації Spring.</li>\n  <li>Підтримує фільтри <code>includeFilters</code> і <code>excludeFilters</code> для більш тонкого налаштування, які класи враховувати при скануванні.</li>\n</ul>\n\n<p>Таким чином, <code>@ComponentScan</code> значно спрощує конфігурацію додатків, автоматично реєструючи біни та скорочуючи ручну роботу.</p>","topicName":"Spring"},{"id":473,"questionText":"Як Spring працює з транзакціями? Розкажіть про анотацію @Transactional","answer":"<p>Spring забезпечує управління транзакціями на рівні програми за допомогою декларативного або програмного підходу. Найчастіше використовується декларативний метод за допомогою анотації <code>@Transactional</code>.</p>\n\n<h3>Принцип роботи:</h3>\n<ul>\n  <li>Spring створює проксі для бінів, методи яких позначені <code>@Transactional</code>. Проксі перехоплює виклики методів і керує транзакцією.</li>\n  <li>Коли метод викликається, Spring відкриває транзакцію, виконує метод і, залежно від результату, комітить або робить rollback.</li>\n</ul>\n\n<h3>Особливості використання:</h3>\n<ul>\n  <li>Анотація може застосовуватися на методах або на класах (тоді поширюється на всі методи класу).</li>\n  <li>Параметри анотації дозволяють налаштовувати поведінку транзакцій: \n    <ul>\n      <li><code>propagation</code> – режим поширення транзакції (наприклад, REQUIRED, REQUIRES_NEW).</li>\n      <li><code>isolation</code> – рівень ізоляції транзакції.</li>\n      <li><code>timeout</code> – час виконання транзакції.</li>\n      <li><code>readOnly</code> – чи транзакція лише для читання.</li>\n      <li><code>rollbackFor</code> / <code>noRollbackFor</code> – визначають, для яких винятків робити rollback або ні.</li>\n    </ul>\n  </li>\n  <li>Spring інтегрується з різними джерелами даних: JDBC, JPA, Hibernate, JMS та іншими.</li>\n</ul>\n\n<p>Таким чином, <code>@Transactional</code> дозволяє розробникам легко керувати транзакціями, забезпечуючи консистентність даних та автоматичне відкатування у разі помилок.</p>","topicName":"Spring"},{"id":474,"questionText":"Що станеться, якщо один метод з @Transactional викличе інший метод з @Transactional?","answer":"<p>Якщо один транзакційний метод викликає інший метод з <code>@Transactional</code> всередині того самого сервісу, другий метод не створить окрему транзакцію. Він буде виконуватися в рамках уже існуючої транзакції першого методу.</p>\n\n<p>Причина полягає в тому, що Spring використовує проксі для управління транзакціями. Внутрішній виклик методу в межах одного класу обходить проксі, тому другий метод не перехоплюється і не створює нову транзакцію.</p>\n\n<p>Якщо потрібна окрема транзакція для другого методу, його потрібно викликати через проксі, наприклад, із зовнішнього біну або через <code>ApplicationContext.getBean()</code>.</p>","topicName":"Spring"},{"id":475,"questionText":"Що станеться, якщо один метод без @Transactional викличе інший метод з @Transactional?","answer":"<p>Якщо метод без <code>@Transactional</code> викликає метод з <code>@Transactional</code> у межах того самого біну, Spring не створить окрему транзакцію для виклику другого методу. Це відбувається тому, що внутрішній виклик методу обходить проксі, який відповідає за управління транзакціями.</p>\n\n<p>У результаті другий метод буде виконуватися без транзакції, навіть якщо він позначений <code>@Transactional</code>. Щоб транзакція спрацювала, метод потрібно викликати через проксі, наприклад, із іншого біну або через <code>ApplicationContext.getBean()</code>.</p>","topicName":"Spring"},{"id":476,"questionText":"Чи буде транзакція скасована, якщо буде викинуто виключення, яке вказано в контракті методу?","answer":"<p>У Spring транзакція за замовчуванням відкотиться лише для неперевірених виключень (<code>RuntimeException</code> та <code>Error</code>).</p>\n\n<p>Якщо метод викидає перевірене виключення (<code>checked exception</code>), і воно зазначене в сигнатурі методу (контракті), транзакція за замовчуванням <strong>не буде відкотена</strong>.</p>\n\n<p>Неперевірені виключення можна або ловити, або не ловити – Spring автоматично відкотить транзакцію у разі їхньої появи, якщо не змінено налаштування параметрів <code>rollbackFor</code> або <code>noRollbackFor</code> в анотації <code>@Transactional</code>.</p>","topicName":"Spring"},{"id":477,"questionText":"Розкажіть про анотації @Controller та @RestController. Чим вони відрізняються?","answer":"<p>В Spring MVC анотації <code>@Controller</code> та <code>@RestController</code> використовуються для позначення класів, які обробляють HTTP-запити, але між ними є важлива різниця.</p>\n\n<h3>@Controller</h3>\n<ul>\n  <li>Позначає клас як компонент, що відповідає за обробку веб-запитів.</li>\n  <li>Методи за замовчуванням повертають ім’я представлення (view name), яке обробляється за допомогою механізму ViewResolver.</li>\n  <li>Щоб повертати JSON або XML, потрібно використовувати анотацію <code>@ResponseBody</code> над методами.</li>\n</ul>\n\n<h3>@RestController</h3>\n<ul>\n  <li>Комбінує <code>@Controller</code> та <code>@ResponseBody</code>.</li>\n  <li>Всі методи класу автоматично повертають дані у форматі JSON або XML, без необхідності додавати <code>@ResponseBody</code> над кожним методом.</li>\n  <li>Використовується переважно для створення REST API.</li>\n</ul>\n\n<p>Отже, <code>@Controller</code> підходить для веб-додатків із шаблонами (views), а <code>@RestController</code> – для сервісів, що повертають дані у форматі JSON/XML.</p>","topicName":"Spring"},{"id":478,"questionText":"Як повернути відповідь із власним статусом (наприклад 213)?","answer":"<p>У Spring для контролерів можна встановлювати власний HTTP-статус відповіді кількома способами:</p>\n\n<h3>1. Використання <code>@ResponseStatus</code></h3>\n<pre>\n<code>@RestController\npublic class MyController {\n\n    @GetMapping(\"/custom-status\")\n    @ResponseStatus(HttpStatus.valueOf(213))\n    public String customStatus() {\n        return \"Відповідь з статусом 213\";\n    }\n}\n</code>\n</pre>\n<p>Цей спосіб дозволяє фіксовано вказати статус для конкретного методу.</p>\n\n<h3>2. Використання <code>ResponseEntity</code></h3>\n<pre>\n<code>@RestController\npublic class MyController {\n\n    @GetMapping(\"/custom-status\")\n    public ResponseEntity<String> customStatus() {\n        return ResponseEntity\n                 .status(213)\n                 .body(\"Відповідь з статусом 213\");\n    }\n}\n</code>\n</pre>\n<p>Цей спосіб більш гнучкий, дозволяє динамічно змінювати статус та додавати заголовки або тіло відповіді.</p>","topicName":"Spring"},{"id":479,"questionText":"Що таке ViewResolver?","answer":"<p><code>ViewResolver</code> у Spring – це компонент, який відповідає за розпізнавання представлень (view), наприклад HTML-файлів, на основі імені, яке повертає контролер.</p>\n\n<p>Основні особливості:</p>\n<ul>\n  <li>Перетворює логічне ім’я, яке повертає контролер, у конкретне представлення.</li>\n  <li>Підтримує інтеграцію з різними технологіями шаблонів: FreeMarker, Velocity, JasperReports тощо.</li>\n  <li>Більшість реалізацій підтримують інтернаціоналізацію (багатомовність).</li>\n</ul>\n\n<p>Приклади реалізацій:</p>\n<ul>\n  <li><strong>UrlBasedViewResolver</strong> – дозволяє перетворювати логічні імена у URL безпосередньо.</li>\n  <li><strong>InternalResourceViewResolver</strong> – реалізація за замовчуванням; шукає представлення за префіксом, суфіксом і іменем, які повертає контролер.</li>\n  <li><strong>FreeMarkerViewResolver</strong>, <strong>VelocityViewResolver</strong>, <strong>JasperReportsViewResolver</strong> – інтеграція з відповідними технологіями шаблонів.</li>\n</ul>\n\n<p>Таким чином, <code>ViewResolver</code> спрощує роботу з представленнями та дозволяє гнучко налаштовувати їх відображення у веб-додатках Spring.</p>","topicName":"Spring"},{"id":480,"questionText":"Чим відрізняються Model, ModelMap та ModelAndView?","answer":"<h3>Model</h3>\n<p><code>Model</code> – це інтерфейс, який представляє колекцію пар ключ-значення (<code>Map&lt;String, Object&gt;</code>). Він використовується для передачі даних у View. Наприклад, якщо View відображає інформацію про об'єкт <code>Customer</code>, вона може отримувати значення через ключі моделі, наприклад <code>customerName</code> або <code>customerPhone</code>. Об'єкти-значення в моделі можуть містити бізнес-логіку.</p>\n\n<h3>ModelMap</h3>\n<p><code>ModelMap</code> – це клас, який успадкований від <code>LinkedHashMap</code>. Використовується для передачі даних у View. Перевага <code>ModelMap</code> полягає у зручності роботи з колекцією значень як із Map і можливості обробляти ці значення без додаткових конверсій.</p>\n\n<h3>ModelAndView</h3>\n<p><code>ModelAndView</code> – це контейнер, який об'єднує <code>ModelMap</code>, об'єкт <code>View</code> і <code>HttpStatus</code>. Контролер може повертати його як єдиний об'єкт, що дозволяє одночасно передавати дані та визначати, яке представлення відобразити.</p>\n\n<h3>View</h3>\n<p><code>View</code> використовується для відображення даних користувачеві. Spring MVC підтримує різні технології представлень, такі як JSP, JSF, Thymeleaf тощо. Інтерфейс <code>View</code> перетворює об'єкти моделі у звичайні сервлети для відображення.</p>","topicName":"Spring"},{"id":481,"questionText":"Розкажіть про паттерн Front Controller та як він реалізований в Spring?","answer":"<p>Паттерн <strong>Front Controller</strong> забезпечує єдину точку входу для всіх вхідних HTTP-запитів у веб-додатку. Всі запити спочатку обробляються одним компонентом, який виконує загальні завдання (аутентифікацію, авторизацію, логування тощо), а потім передає їх відповідним контролерам для подальшої обробки.</p>\n\n<h3>Реалізація в Spring</h3>\n<ul>\n  <li>У Spring Front Controller реалізований через <code>DispatcherServlet</code>, який налаштований на мапінг “/” – тобто перехоплює всі запити.</li>\n  <li><code>DispatcherServlet</code> аналізує запит і делегує його відповідному контролеру на основі URL.</li>\n  <li>Можна створювати кілька <code>DispatcherServlet</code> для різних частин додатку, кожен з власним дочірнім <code>WebApplicationContext</code>.</li>\n</ul>\n\n<h3>Структура контекстів у Spring</h3>\n<ul>\n  <li>Існує <strong>кореневий контекст</strong> (root context), який містить загальні біни додатку.</li>\n  <li>Дочірні контексти, створені <code>DispatcherServlet</code>, можуть використовувати біни кореневого контексту, але не навпаки.</li>\n  <li>Дочірні контексти можуть перевизначати біни з кореневого контексту.</li>\n  <li><code>WebApplicationContext</code> розширює <code>ApplicationContext</code> і додає метод <code>getServletContext()</code> для доступу до <code>ServletContext</code>.</li>\n</ul>\n\n<h3>ContextLoaderListener</h3>\n<p><code>ContextLoaderListener</code> створює кореневий контекст додатку, який використовується всіма дочірніми контекстами DispatcherServlet. Це дозволяє централізовано керувати бін-об'єктами додатку.</p>","topicName":"Spring"},{"id":482,"questionText":"Розкажіть про паттерн MVC, як він реалізований в Spring?","answer":"<p>Паттерн <strong>Model-View-Controller (MVC)</strong> – це архітектурний підхід, який розділяє додаток на три основні компоненти:</p>\n\n<ul>\n  <li><strong>Model</strong> – відповідає за бізнес-логіку та роботу з даними. У Spring це можуть бути сервіси, DAO або прості об'єкти (POJO), які містять стан додатку.</li>\n  <li><strong>View</strong> – відповідає за представлення даних користувачеві. Spring підтримує різні технології для Views, такі як JSP, Thymeleaf, FreeMarker, Velocity та інші.</li>\n  <li><strong>Controller</strong> – обробляє HTTP-запити, взаємодіє з Model для отримання даних та передає їх у View для відображення. У Spring контролери позначаються анотаціями <code>@Controller</code> або <code>@RestController</code>.</li>\n</ul>\n\n<h3>Реалізація MVC у Spring</h3>\n<ul>\n  <li>Єдиною точкою входу для всіх запитів є <code>DispatcherServlet</code> (реалізація паттерна Front Controller).</li>\n  <li>DispatcherServlet отримує запит і визначає, який контролер має його обробити, використовуючи <code>HandlerMapping</code>.</li>\n  <li>Контролер обробляє логіку додатку та заповнює <code>Model</code> даними.</li>\n  <li>Після цього DispatcherServlet передає дані у <code>ViewResolver</code>, який обирає відповідне представлення.</li>\n  <li>View відображає дані користувачеві.</li>\n</ul>\n\n<p>Таким чином, Spring MVC чітко розділяє логіку обробки даних, представлення та управління запитами, забезпечуючи модульність, зручність тестування та масштабованість додатку.</p>","topicName":"Spring"},{"id":483,"questionText":"Що таке АОП? Як це реалізовано в спрінгу?","answer":"<p><strong>АОП (Aspect-Oriented Programming, програмування аспектів)</strong> – це підхід до програмування, який дозволяє відокремлювати перетинаючу логіку (cross-cutting concerns) від основної бізнес-логіки. До таких перетинаючих аспектів належать:</p>\n\n<ul>\n  <li>Логування</li>\n  <li>Безпека та аутентифікація</li>\n  <li>Транзакції</li>\n  <li>Кешування</li>\n</ul>\n\n<p>Основні поняття АОП:</p>\n<ul>\n  <li><strong>Aspect (Аспект)</strong> – модуль, який містить перетинаючу логіку.</li>\n  <li><strong>Advice (Порада)</strong> – код, який виконується у певний момент часу, наприклад до або після виконання методу.</li>\n  <li><strong>Join point</strong> – точка в програмі, де може бути застосована порада (наприклад, виклик методу).</li>\n  <li><strong>Pointcut</strong> – вираз, який визначає, у яких join point виконувати поради.</li>\n  <li><strong>Weaving</strong> – процес впровадження аспектів у програму.</li>\n</ul>\n\n<h3>Реалізація АОП у Spring</h3>\n<ul>\n  <li>Spring реалізує АОП через <strong>проксі-об’єкти</strong>. Контейнер Spring створює проксі для бінів і додає до них логіку аспектів.</li>\n  <li>Підтримуються як <strong>інтерфейсні проксі</strong> (JDK Dynamic Proxy), так і <strong>проксі на основі підкласів</strong> (CGLIB).</li>\n  <li>Аспекти можна створювати за допомогою анотацій: <code>@Aspect</code>, <code>@Before</code>, <code>@After</code>, <code>@Around</code> тощо.</li>\n  <li>Spring дозволяє легко інтегрувати АОП для реалізації транзакцій, логування, безпеки та інших перетинаючих задач без зміни бізнес-логіки.</li>\n</ul>","topicName":"Spring"},{"id":484,"questionText":"В чому різниця між Filters, Listeners та Interceptors?","answer":"<p>У веб-додатках на Spring та сервлетах існують різні способи обробки запитів до контролерів, серед яких <strong>Filters</strong>, <strong>Listeners</strong> та <strong>Interceptors</strong>. Кожен з них має своє призначення та момент виконання.</p>\n\n<h3>Filters</h3>\n<ul>\n  <li>Реалізуються через інтерфейс <code>javax.servlet.Filter</code>.</li>\n  <li>Мають доступ до HTTP-запиту та відповіді.</li>\n  <li>Виконуються <strong>до та після</strong> проходження запиту контролером.</li>\n  <li>Використовуються для загальних завдань: логування, аутентифікація, модифікація запиту або відповіді, стиснення контенту.</li>\n</ul>\n\n<h3>Listeners</h3>\n<ul>\n  <li>Реалізуються через інтерфейс <code>javax.servlet.ServletContextListener</code> або інші Listener-и.</li>\n  <li>Слухають події життєвого циклу сервлетів та контексту: створення/знищення контексту, сесії, атрибутів.</li>\n  <li>Не взаємодіють безпосередньо із запитами, їх основна мета – реагувати на системні події додатку.</li>\n</ul>\n\n<h3>Interceptors</h3>\n<ul>\n  <li>Реалізуються через Spring MVC <code>HandlerInterceptor</code>.</li>\n  <li>Мають доступ до HTTP-запиту та відповіді, а також до об'єкта контролера.</li>\n  <li>Виконуються <strong>до обробки контролером, після обробки та після рендерингу View</strong>.</li>\n  <li>Дозволяють додавати логіку обробки запитів на рівні Spring MVC без втручання у сервлети (наприклад, логування, перевірка сесії, зміна моделі перед відображенням).</li>\n</ul>\n\n<p><strong>Підсумок:</strong> Filters – працюють на рівні сервлетів, Listeners – реагують на події життєвого циклу, Interceptors – працюють на рівні Spring MVC перед та після контролера.</p>","topicName":"Spring"},{"id":485,"questionText":"Чи можна передавати один і той же параметр у запиті кілька разів? Як це зробити?","answer":"<p>Так, у Spring MVC можна передавати один і той же параметр кілька разів у запиті. Для цього у методі контролера потрібно використовувати масив або колекцію як параметр:</p>\n\n<h3>Приклад з масивом</h3>\n<p>HTTP-запит:</p>\n<pre>http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish</pre>\n<p>Метод контролера:</p>\n<pre>\npublic String method(@RequestParam(value=\"name\") String[] names) {\n    // names = [\"Ranga\", \"Ravi\", \"Sathish\"]\n}\n</pre>\n\n<h3>Приклад зі списком</h3>\n<p>HTTP-запит:</p>\n<pre>http://localhost:8080/api/foos?id=1,2,3</pre>\n<p>Метод контролера:</p>\n<pre>\npublic String getFoos(@RequestParam List<String> id) {\n    // id = [\"1\", \"2\", \"3\"]\n}\n</pre>\n\n<p>Таким чином Spring автоматично конвертує всі значення параметра у масив або список для зручної обробки.</p>","topicName":"Spring"},{"id":486,"questionText":"Що таке  Spring Security? Які задачі він вирішує ?","answer":"<p><strong>Spring Security</strong> – це потужний фреймворк для забезпечення безпеки веб-додатків на базі Spring. Він надає гнучкі та масштабовані засоби для аутентифікації, авторизації та захисту додатків від поширених загроз.</p>\n\n<h3>Основні задачі Spring Security</h3>\n<ul>\n  <li><strong>Аутентифікація (Authentication)</strong> – перевірка, чи дійсно користувач є тим, за кого він себе видає. Підтримуються різні механізми: форми входу, HTTP Basic, OAuth2, JWT тощо.</li>\n  <li><strong>Авторизація (Authorization)</strong> – контроль доступу користувачів до ресурсів додатку на основі ролей або привілеїв. Наприклад, доступ до адміністративної частини лише для користувачів з роллю ADMIN.</li>\n  <li><strong>Захист від атак</strong> – Spring Security допомагає захиститися від CSRF (Cross-Site Request Forgery), XSS (Cross-Site Scripting), Clickjacking та інших типових веб-атак.</li>\n  <li><strong>Управління сесіями</strong> – контроль активних сесій, обмеження кількості одночасних сесій на одного користувача, відстеження неактивних сесій.</li>\n  <li><strong>Шифрування паролів та конфіденційних даних</strong> – використання стандартів шифрування, таких як BCrypt, для безпечного зберігання паролів.</li>\n</ul>\n\n<p>Spring Security інтегрується з Spring Boot і Spring MVC, дозволяючи централізовано налаштовувати безпеку додатка, а також легко розширювати її під специфічні вимоги бізнес-логіки.</p>","topicName":"Spring"},{"id":487,"questionText":"Що таке Spring Boot? Які задачі він вирішує ?","answer":"<p><strong>Spring Boot</strong> – це фреймворк на базі Spring, який спрощує розробку самодостатніх, готових до запуску Java-додатків. Він дозволяє швидко створювати продакшн-додатки без необхідності тривалого налаштування конфігурацій і сервлет-контейнерів.</p>\n\n<h3>Основні задачі Spring Boot</h3>\n<ul>\n  <li><strong>Автоматична конфігурація (Auto-Configuration)</strong> – Spring Boot автоматично налаштовує компоненти додатка залежно від наявних бібліотек у classpath.</li>\n  <li><strong>Мінімальна конфігурація</strong> – значно зменшує кількість XML або Java-конфігурацій, дозволяючи розробникам швидше запускати додаток.</li>\n  <li><strong>Вбудований сервер</strong> – дозволяє запускати веб-додатки без потреби зовнішнього сервлет-контейнера, використовуючи Tomcat, Jetty або Undertow.</li>\n  <li><strong>Менеджмент залежностей</strong> – забезпечує готові \"starter\"-залежності для швидкого підключення баз даних, безпеки, веб-функцій, JPA, тестування тощо.</li>\n  <li><strong>Моніторинг та управління</strong> – інтеграція з Spring Actuator для відстеження стану додатка, метрик, health checks та логування.</li>\n  <li><strong>Швидкий старт проекту</strong> – за допомогою Spring Initializr можна генерувати готову структуру проекту з необхідними залежностями.</li>\n</ul>\n\n<p>Отже, Spring Boot дозволяє розробникам швидко створювати готові до запуску додатки з мінімальними зусиллями, зосереджуючи увагу на бізнес-логіці замість конфігурацій.</p>","topicName":"Spring"},{"id":488,"questionText":"Як відбувається автоконфігурація в Spring Boot ?","answer":"<p>Автоконфігурація (Auto-Configuration) у Spring Boot – це механізм, який автоматично налаштовує компоненти додатку на основі бібліотек, що присутні у classpath, та конфігурацій, визначених у проекті. Це дозволяє значно зменшити кількість ручної конфігурації та прискорити старт проекту.</p>\n\n<h3>Механізм роботи автоконфігурації</h3>\n<ol>\n  <li><strong>Детекція бібліотек:</strong> Spring Boot перевіряє, які залежності додані до classpath, наприклад, база даних, веб-сервер, JPA тощо.</li>\n  <li><strong>Активація автоконфігурацій:</strong> Використовуючи анотацію <code>@EnableAutoConfiguration</code> або <code>@SpringBootApplication</code>, Spring Boot підключає всі класи автоконфігурації, описані у файлі <code>spring.factories</code> пакету <code>spring-boot-autoconfigure</code>.</li>\n  <li><strong>Умовна конфігурація:</strong> Кожна автоконфігурація має умови (<code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code>, <code>@ConditionalOnProperty</code>), які визначають, чи потрібно створювати бін. Наприклад, якщо у classpath є H2 база даних, буде автоматично налаштований DataSource для H2.</li>\n  <li><strong>Створення бінів:</strong> Spring Boot створює потрібні біни для підключених технологій та налаштовує їх залежності без втручання розробника.</li>\n</ol>\n\n<h3>Переваги автоконфігурації</h3>\n<ul>\n  <li>Швидкий старт проекту без зайвої конфігурації.</li>\n  <li>Гнучкість – можна перевизначити будь-який бін вручну при потребі.</li>\n  <li>Зменшення помилок при налаштуванні компонентів.</li>\n</ul>","topicName":"Spring"},{"id":489,"questionText":"Розкажіть про нововведення у Spring 5","answer":"<p>Spring 5 став важливим оновленням фреймворку, яке принесло підтримку сучасних технологій та поліпшення продуктивності. Основні нововведення включають:</p>\n\n<h3>1. Підтримка Java 8+ та функціонального стилю</h3>\n<ul>\n  <li>Використання <code>Optional</code>, <code>Streams</code>, <code>lambda expressions</code> у конфігураціях та API.</li>\n  <li>Підтримка нових типів дати і часу через <code>java.time</code>.</li>\n  <li>Можливість створювати bean-и у функціональному стилі за допомогою <code>Supplier</code>.</li>\n</ul>\n\n<h3>2. Реактивне програмування (Reactive Programming)</h3>\n<ul>\n  <li>Введено проект <strong>Spring WebFlux</strong> – асинхронний та неблокуючий веб-фреймворк для створення реактивних додатків.</li>\n  <li>Підтримка <code>Mono</code> та <code>Flux</code> із проекту <strong>Reactor</strong>.</li>\n  <li>Можливість створювати реактивні REST API, які обробляють велику кількість запитів ефективно.</li>\n</ul>\n\n<h3>3. Підтримка Kotlin</h3>\n<ul>\n  <li>Інтеграція з мовою Kotlin для створення Spring додатків.</li>\n  <li>Дозволяє використовувати Kotlin DSL для конфігурації бінів.</li>\n</ul>\n\n<h3>4. Поліпшення AOP та безпеки</h3>\n<ul>\n  <li>Оптимізація AOP-проксі та спрощена конфігурація для реактивних додатків.</li>\n  <li>Оновлення Spring Security для інтеграції з новими Java та WebFlux функціональностями.</li>\n</ul>\n\n<h3>5. Нові можливості для тестування</h3>\n<ul>\n  <li>Розширена підтримка тестування реактивних компонентів.</li>\n  <li>Покращення Spring TestContext Framework для спрощення інтеграційних тестів.</li>\n</ul>\n\n<p>Таким чином, Spring 5 робить фреймворк сучаснішим, підтримує реактивні та асинхронні підходи, інтеграцію з новими мовами та полегшує використання функціональних можливостей Java 8 і вище.</p>","topicName":"Spring"},{"id":490,"questionText":"Що таке «патерн проектування»?","answer":"<p><strong>Патерн проектування</strong> (Design Pattern) – це перевірене, повторно застосовуване рішення типової проблеми у розробці програмного забезпечення. Патерни не є готовим кодом або бібліотекою, це скоріше шаблон, який описує, як організувати класи, об’єкти та їх взаємодії для вирішення певної задачі.</p>","topicName":"Шаблони проектування"},{"id":491,"questionText":"Назвіть три основні групи патернів","answer":"<h3>Класифікація патернів</h3>\n<ul>\n  <li><strong>Порожні (Creational)</strong> – стосуються створення об’єктів (Singleton, Factory, Builder).</li>\n  <li><strong>Структурні (Structural)</strong> – визначають, як об’єкти та класи поєднуються (Adapter, Decorator, Composite).</li>\n  <li><strong>Поведінкові (Behavioral)</strong> – описують взаємодію та поведінку об’єктів (Observer, Strategy, Command).</li>\n</ul>","topicName":"Шаблони проектування"},{"id":492,"questionText":"Розкажіть про патерн «Одинак» (Singleton)","answer":"<p><strong>Патерн Singleton</strong> – це порожній (creational) патерн проектування, який гарантує, що клас має лише один екземпляр, і надає глобальну точку доступу до цього екземпляра.</p>\n\n<h3>Основні характеристики Singleton</h3>\n<ul>\n  <li>Існує лише один об’єкт класу протягом усього часу виконання програми.</li>\n  <li>Глобальна точка доступу дозволяє іншим класам отримувати цей екземпляр без створення нового.</li>\n  <li>Контролює створення об’єкта, зазвичай через приватний конструктор.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n        // Приватний конструктор запобігає створенню об'єктів зовні\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Гарантія єдиного екземпляра класу.</li>\n  <li>Глобальна точка доступу.</li>\n  <li>Контроль ресурсів, якщо об’єкт керує дорогими ресурсами (підключення до БД, кешування).</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Може ускладнити тестування через глобальний стан.</li>\n  <li>Проблеми з багатопотоковістю, якщо не реалізовано синхронізацію.</li>\n</ul>\n\n<p>У Spring Framework патерн Singleton використовується за замовчуванням для всіх бінів, створюючи лише один екземпляр біна в контексті додатку.</p>","topicName":"Шаблони проектування"},{"id":493,"questionText":"Розкажіть про патерн «Будівельник» (Builder)","answer":"<p><strong>Патерн Builder</strong> – це порожній (creational) патерн проектування, який дозволяє створювати складні об’єкти поетапно, розділяючи процес конструювання та представлення об’єкта. Він особливо корисний, коли клас має багато параметрів, частина з яких необов’язкова.</p>\n\n<h3>Основні характеристики Builder</h3>\n<ul>\n  <li>Дозволяє створювати об’єкт крок за кроком, контролюючи процес побудови.</li>\n  <li>Відокремлює логіку побудови об’єкта від його представлення.</li>\n  <li>Підтримує читабельний та зрозумілий код при створенні об’єктів із багатьма параметрами.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\npublic class User {\n    private String firstName;\n    private String lastName;\n    private int age;\n    private String phone;\n\n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.phone = builder.phone;\n    }\n\n    public static class UserBuilder {\n        private String firstName;\n        private String lastName;\n        private int age;\n        private String phone;\n\n        public UserBuilder setFirstName(String firstName) {\n            this.firstName = firstName;\n            return this;\n        }\n\n        public UserBuilder setLastName(String lastName) {\n            this.lastName = lastName;\n            return this;\n        }\n\n        public UserBuilder setAge(int age) {\n            this.age = age;\n            return this;\n        }\n\n        public UserBuilder setPhone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n\n        public User build() {\n            return new User(this);\n        }\n    }\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Читабельність та зрозумілість коду.</li>\n  <li>Можливість створювати об’єкти з необов’язковими параметрами.</li>\n  <li>Зменшує кількість конструкторів у класі.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Створення додаткових класів (Builder може бути великим для невеликих об’єктів).</li>\n  <li>Може ускладнити структуру коду при простих об’єктах.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":494,"questionText":"Патерн «Фабричний метод» (Factory Method)","answer":"<p><strong>Патерн Factory Method</strong> – це порожній (creational) патерн проектування, який визначає інтерфейс для створення об’єкта, але дозволяє підкласам змінювати тип створюваного об’єкта. Він забезпечує делегування створення об’єкта підкласам замість того, щоб жорстко закодувати його в базовому класі.</p>\n\n<h3>Основні характеристики Factory Method</h3>\n<ul>\n  <li>Визначає метод для створення об’єктів без явного вказування конкретного класу.</li>\n  <li>Дозволяє підкласам вирішувати, який саме об’єкт створювати.</li>\n  <li>Підвищує гнучкість та масштабованість коду.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\ninterface Product {\n    void use();\n}\n\nclass ConcreteProductA implements Product {\n    public void use() {\n        System.out.println(\"Використання Product A\");\n    }\n}\n\nclass ConcreteProductB implements Product {\n    public void use() {\n        System.out.println(\"Використання Product B\");\n    }\n}\n\nabstract class Creator {\n    public abstract Product factoryMethod();\n\n    public void someOperation() {\n        Product product = factoryMethod();\n        product.use();\n    }\n}\n\nclass ConcreteCreatorA extends Creator {\n    public Product factoryMethod() {\n        return new ConcreteProductA();\n    }\n}\n\nclass ConcreteCreatorB extends Creator {\n    public Product factoryMethod() {\n        return new ConcreteProductB();\n    }\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Відокремлює створення об’єктів від їх використання.</li>\n  <li>Зменшує залежність коду від конкретних класів.</li>\n  <li>Полегшує розширення та модифікацію системи.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Збільшує кількість класів у проєкті.</li>\n  <li>Може ускладнити структуру при простих об’єктах.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":495,"questionText":"Розкажіть про патерн «Абстрактна фабрика» (Abstract Factory)","answer":"<p><strong>Патерн Abstract Factory</strong> – це порожній (creational) патерн проектування, який дозволяє створювати родини взаємопов’язаних або залежних об’єктів без зазначення їх конкретних класів. Він надає інтерфейс для створення групи об’єктів, залишаючи підкласам вибір конкретної реалізації.</p>\n\n<h3>Основні характеристики Abstract Factory</h3>\n<ul>\n  <li>Створює об’єкти, які належать до певної родини.</li>\n  <li>Забезпечує узгодженість між взаємопов’язаними об’єктами.</li>\n  <li>Відокремлює код клієнта від конкретних реалізацій об’єктів.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\ninterface GUIFactory {\n    Button createButton();\n    Checkbox createCheckbox();\n}\n\nclass WinFactory implements GUIFactory {\n    public Button createButton() {\n        return new WindowsButton();\n    }\n    public Checkbox createCheckbox() {\n        return new WindowsCheckbox();\n    }\n}\n\nclass MacFactory implements GUIFactory {\n    public Button createButton() {\n        return new MacButton();\n    }\n    public Checkbox createCheckbox() {\n        return new MacCheckbox();\n    }\n}\n\ninterface Button { void paint(); }\ninterface Checkbox { void paint(); }\n\nclass WindowsButton implements Button { public void paint() { System.out.println(\"Windows Button\"); } }\nclass MacButton implements Button { public void paint() { System.out.println(\"Mac Button\"); } }\nclass WindowsCheckbox implements Checkbox { public void paint() { System.out.println(\"Windows Checkbox\"); } }\nclass MacCheckbox implements Checkbox { public void paint() { System.out.println(\"Mac Checkbox\"); } }\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Гарантує узгодженість між об’єктами однієї родини.</li>\n  <li>Зменшує залежність коду клієнта від конкретних класів.</li>\n  <li>Полегшує розширення системи для нових родин об’єктів.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Складна структура коду через велику кількість інтерфейсів та класів.</li>\n  <li>Може бути надлишковим для невеликих систем.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":496,"questionText":"Розкажіть про патерн «Прототип» (Prototype)","answer":"<p><strong>Патерн Prototype</strong> – це порожній (creational) патерн проектування, який дозволяє створювати нові об’єкти шляхом копіювання (клону) існуючих, замість створення їх з нуля. Це особливо корисно, коли створення об’єкта є дорогим або складним процесом.</p>\n\n<h3>Основні характеристики Prototype</h3>\n<ul>\n  <li>Дозволяє створювати нові об’єкти шляхом клонування наявного екземпляра.</li>\n  <li>Зменшує витрати на створення складних об’єктів.</li>\n  <li>Використовує інтерфейс або абстрактний клас з методом <code>clone()</code>.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\nabstract class Prototype implements Cloneable {\n    public Prototype clone() {\n        try {\n            return (Prototype) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\nclass ConcretePrototype extends Prototype {\n    private String field;\n\n    public ConcretePrototype(String field) {\n        this.field = field;\n    }\n\n    public String getField() { return field; }\n    public void setField(String field) { this.field = field; }\n}\n</pre>\n\n<h3>Приклад використання</h3>\n<pre>\nConcretePrototype original = new ConcretePrototype(\"Original\");\nConcretePrototype copy = (ConcretePrototype) original.clone();\ncopy.setField(\"Copy\");\n\nSystem.out.println(original.getField()); // Original\nSystem.out.println(copy.getField());     // Copy\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Швидке створення об’єктів через клонування.</li>\n  <li>Зменшення залежності від конкретних класів.</li>\n  <li>Можливість динамічного створення нових об’єктів на основі прототипів.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Складність реалізації глибокого клонування для об’єктів з вкладеними полями.</li>\n  <li>Проблеми з клонуванням об’єктів з final-полями або складною ієрархією.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":497,"questionText":"Розкажіть про патерн «Адаптер» (Adapter)","answer":"<p><strong>Патерн Adapter</strong> – це структурний патерн проектування, який дозволяє об’єктам з несумісними інтерфейсами працювати разом. Адаптер «обертає» існуючий клас і надає інтерфейс, який очікує клієнт.</p>\n\n<h3>Основні характеристики Adapter</h3>\n<ul>\n  <li>Перетворює інтерфейс одного класу в інтерфейс, очікуваний клієнтом.</li>\n  <li>Дозволяє повторно використовувати існуючий код без його модифікації.</li>\n  <li>Підвищує гнучкість і сумісність системи.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\ninterface Target {\n    void request();\n}\n\nclass Adaptee {\n    public void specificRequest() {\n        System.out.println(\"Виконання специфічного запиту\");\n    }\n}\n\n// Клас-адаптер, який робить Adaptee сумісним з Target\nclass Adapter implements Target {\n    private Adaptee adaptee;\n\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    public void request() {\n        // Переклад виклику Target на специфічний метод Adaptee\n        adaptee.specificRequest();\n    }\n}\n</pre>\n\n<h3>Приклад використання</h3>\n<pre>\nAdaptee adaptee = new Adaptee();\nTarget target = new Adapter(adaptee);\ntarget.request(); // Виконає specificRequest() через адаптер\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Дозволяє використовувати існуючий код з новими інтерфейсами.</li>\n  <li>Підвищує повторне використання коду.</li>\n  <li>Зменшує зв’язність між класами.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Може ускладнити структуру програми через додаткові класи-адаптери.</li>\n  <li>Іноді потрібне створення великої кількості адаптерів для різних інтерфейсів.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":498,"questionText":"Розкажіть про патерн «Декоратор» (Decorator)","answer":"<p><strong>Патерн Decorator</strong> – це структурний патерн проектування, який дозволяє динамічно додавати нові функціональні можливості об’єктам, не змінюючи їх клас. Декоратори обертають оригінальний об’єкт і надають додаткову поведінку.</p>\n\n<h3>Основні характеристики Decorator</h3>\n<ul>\n  <li>Дозволяє розширювати функціональність об’єктів динамічно.</li>\n  <li>Не потребує зміни коду базового класу.</li>\n  <li>Можна комбінувати кілька декораторів для додаткових можливостей.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\ninterface Component {\n    void operation();\n}\n\n// Базовий клас\nclass ConcreteComponent implements Component {\n    public void operation() {\n        System.out.println(\"Основна операція\");\n    }\n}\n\n// Абстрактний декоратор\nabstract class Decorator implements Component {\n    protected Component component;\n\n    public Decorator(Component component) {\n        this.component = component;\n    }\n    public void operation() {\n        component.operation();\n    }\n}\n\n// Конкретний декоратор\nclass ConcreteDecorator extends Decorator {\n    public ConcreteDecorator(Component component) {\n        super(component);\n    }\n\n    @Override\n    public void operation() {\n        super.operation();\n        addedBehavior();\n    }\n\n    private void addedBehavior() {\n        System.out.println(\"Додаткова поведінка декоратора\");\n    }\n}\n</pre>\n\n<h3>Приклад використання</h3>\n<pre>\nComponent component = new ConcreteComponent();\nComponent decorated = new ConcreteDecorator(component);\n\ndecorated.operation();\n// Виведе:\n// Основна операція\n// Додаткова поведінка декоратора\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Динамічне розширення функціональності об’єктів.</li>\n  <li>Відокремлення додаткової поведінки від базового класу.</li>\n  <li>Можливість комбінувати декоратори для різних комбінацій поведінки.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Може ускладнити структуру програми через велику кількість класів-декораторів.</li>\n  <li>Іноді складно відстежувати, які саме декоратори застосовані до об’єкта.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":499,"questionText":"Розкажіть про патерн «Замісник» (Proxy)","answer":"<p><strong>Патерн Proxy</strong> – це структурний патерн проектування, який надає об’єкт-замісник (проксі) для іншого об’єкта, контролюючи доступ до нього. Проксі може виконувати додаткові операції перед або після виклику основного об’єкта.</p>\n\n<h3>Основні характеристики Proxy</h3>\n<ul>\n  <li>Дозволяє контролювати доступ до об’єкта.</li>\n  <li>Може реалізовувати лениве завантаження, кешування, логування, контроль доступу.</li>\n  <li>Прозоро для клієнта – клієнт взаємодіє з проксі так само, як і з реальним об’єктом.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\ninterface Subject {\n    void request();\n}\n\n// Реальний об'єкт\nclass RealSubject implements Subject {\n    public void request() {\n        System.out.println(\"Виконання запиту реальним об’єктом\");\n    }\n}\n\n// Проксі\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        System.out.println(\"Додаткові дії проксі перед викликом\");\n        realSubject.request();\n        System.out.println(\"Додаткові дії проксі після виклику\");\n    }\n}\n</pre>\n\n<h3>Приклад використання</h3>\n<pre>\nSubject subject = new Proxy();\nsubject.request();\n// Виведе:\n// Додаткові дії проксі перед викликом\n// Виконання запиту реальним об’єктом\n// Додаткові дії проксі після виклику\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Контроль доступу до реального об’єкта.</li>\n  <li>Можливість реалізувати відкладене створення об’єкта (lazy loading).</li>\n  <li>Додає додаткову поведінку без зміни реального об’єкта.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Може ускладнити код через додаткові класи проксі.</li>\n  <li>Додаткові рівні викликів можуть зменшити продуктивність.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":500,"questionText":"Розкажіть про патерн «Ітератор» (Iterator)","answer":"<p><strong>Патерн Iterator</strong> – це поведінковий патерн проектування, який надає спосіб послідовного доступу до елементів колекції без розкриття її внутрішньої структури.</p>\n\n<h3>Основні характеристики Iterator</h3>\n<ul>\n  <li>Відокремлює алгоритм перебору від колекції.</li>\n  <li>Дозволяє клієнту перебирати елементи без знання внутрішньої реалізації колекції.</li>\n  <li>Підтримує одночасне використання декількох ітераторів для однієї колекції.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class IteratorExample {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"Перший\");\n        list.add(\"Другий\");\n        list.add(\"Третій\");\n\n        Iterator<String> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            String element = iterator.next();\n            System.out.println(element);\n        }\n    }\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Уніфікований інтерфейс для перебору різних колекцій.</li>\n  <li>Не потребує знання внутрішньої структури колекції.</li>\n  <li>Підтримка одночасних ітераторів.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Може додати невелику накладну витрату через створення об’єктів-ітераторів.</li>\n  <li>Не забезпечує можливість перебору колекцій у зворотному порядку без додаткових реалізацій.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":501,"questionText":"Розкажіть про патерн «Шаблонний метод» (Template Method)","answer":"<p><strong>Патерн Template Method</strong> – це поведінковий патерн проектування, який визначає скелет алгоритму в методі базового класу, дозволяючи підкласам реалізовувати окремі кроки алгоритму без зміни його структури.</p>\n\n<h3>Основні характеристики Template Method</h3>\n<ul>\n  <li>Задає послідовність кроків алгоритму.</li>\n  <li>Дозволяє підкласам реалізовувати конкретні кроки.</li>\n  <li>Забезпечує повторне використання базового алгоритму.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\nabstract class AbstractClass {\n    // Шаблонний метод\n    public void templateMethod() {\n        stepOne();\n        stepTwo();\n        stepThree();\n    }\n\n    protected abstract void stepOne();\n    protected abstract void stepTwo();\n\n    // Конкретна реалізація кроку\n    protected void stepThree() {\n        System.out.println(\"Крок три (спільна реалізація)\");\n    }\n}\n\n// Підклас реалізує абстрактні кроки\nclass ConcreteClass extends AbstractClass {\n    @Override\n    protected void stepOne() {\n        System.out.println(\"Крок один (реалізація підкласу)\");\n    }\n\n    @Override\n    protected void stepTwo() {\n        System.out.println(\"Крок два (реалізація підкласу)\");\n    }\n}\n</pre>\n\n<h3>Приклад використання</h3>\n<pre>\nAbstractClass template = new ConcreteClass();\ntemplate.templateMethod();\n// Виведе:\n// Крок один (реалізація підкласу)\n// Крок два (реалізація підкласу)\n// Крок три (спільна реалізація)\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Повторне використання коду для загального алгоритму.</li>\n  <li>Легко змінювати окремі кроки алгоритму без зміни його структури.</li>\n  <li>Забезпечує контроль над послідовністю виконання кроків.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Обмежує підкласи у виборі структури алгоритму.</li>\n  <li>Може збільшити кількість підкласів при різних реалізаціях кроків.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":502,"questionText":"Розкажіть про патерн «Ланцюг відповідальності» (Chain of Responsibility)","answer":"<p><strong>Патерн Chain of Responsibility</strong> – це поведінковий патерн проектування, який дозволяє передавати запит по ланцюгу об’єктів-обробників, поки його не обробить об’єкт, здатний це зробити. Кожен об’єкт у ланцюзі має посилання на наступний об’єкт, і якщо він не може обробити запит, передає його далі.</p>\n\n<h3>Основні характеристики</h3>\n<ul>\n  <li>Відокремлює відправника запиту від одержувача.</li>\n  <li>Дозволяє динамічно змінювати ланцюг обробки запитів.</li>\n  <li>Кожен обробник вирішує, обробляти запит самостійно або передавати далі.</li>\n</ul>\n\n<h3>Реалізація в Java</h3>\n<pre>\nabstract class Handler {\n    protected Handler next;\n\n    public void setNext(Handler next) {\n        this.next = next;\n    }\n\n    public abstract void handleRequest(String request);\n}\n\nclass ConcreteHandlerA extends Handler {\n    public void handleRequest(String request) {\n        if (\"A\".equals(request)) {\n            System.out.println(\"Оброблено ConcreteHandlerA\");\n        } else if (next != null) {\n            next.handleRequest(request);\n        }\n    }\n}\n\nclass ConcreteHandlerB extends Handler {\n    public void handleRequest(String request) {\n        if (\"B\".equals(request)) {\n            System.out.println(\"Оброблено ConcreteHandlerB\");\n        } else if (next != null) {\n            next.handleRequest(request);\n        }\n    }\n}\n</pre>\n\n<h3>Приклад використання</h3>\n<pre>\nHandler handlerA = new ConcreteHandlerA();\nHandler handlerB = new ConcreteHandlerB();\nhandlerA.setNext(handlerB);\n\nhandlerA.handleRequest(\"B\"); \n// Виведе: Оброблено ConcreteHandlerB\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Зменшує зв’язність між відправником і одержувачем.</li>\n  <li>Додає або видаляє обробники без зміни коду клієнта.</li>\n  <li>Можливість організувати гнучку обробку запитів.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Запит може пройти по всьому ланцюгу без обробки, якщо ніхто не зможе його обробити.</li>\n  <li>Важко налагоджувати, якщо ланцюг довгий або складний.</li>\n</ul>","topicName":"Шаблони проектування"},{"id":503,"questionText":"Які патерни використовуються в Spring Framework?","answer":"<p>Spring Framework широко використовує різні патерни проектування для забезпечення гнучкості, масштабованості та повторного використання коду. Основні з них:</p>\n\n<ul>\n  <li><strong>Singleton</strong> – за замовчуванням всі біни Spring є сінглтонами, що забезпечує єдиний екземпляр біна в контексті.</li>\n  <li><strong>Factory Method</strong> – для створення бінів контейнером IoC через методи конфігурації або анотації <code>@Bean</code>.</li>\n  <li><strong>Abstract Factory</strong> – реалізується через різні конфігурації та ApplicationContext, що дозволяє створювати сімейства взаємопов’язаних об’єктів.</li>\n  <li><strong>Proxy</strong> – активно використовується для реалізації аспектно-орієнтованого програмування (AOP), транзакцій та безпеки.</li>\n  <li><strong>Template Method</strong> – реалізований у класах <code>JdbcTemplate</code>, <code>RestTemplate</code> та інших, щоб визначити скелет алгоритму, залишаючи підкласи реалізовувати деталі.</li>\n  <li><strong>Decorator</strong> – використовується у ланцюгах обробки запитів, наприклад у <code>HandlerInterceptor</code>, <code>Filter</code> та AOP-адвайсах.</li>\n  <li><strong>Front Controller</strong> – реалізований через <code>DispatcherServlet</code>, який обробляє всі HTTP-запити у Spring MVC.</li>\n  <li><strong>Observer</strong> – реалізований через механізм подій Spring (<code>ApplicationEvent</code> і <code>ApplicationListener</code>).</li>\n  <li><strong>Chain of Responsibility</strong> – застосовується у <code>FilterChain</code>, Spring Security та обробці запитів у Spring MVC.</li>\n  <li><strong>Adapter</strong> – використовується для інтеграції сторонніх API та інтерфейсів у Spring (наприклад, <code>HandlerAdapter</code> у MVC).</li>\n  <li><strong>Iterator</strong> – використовується для перебору колекцій бінів у контексті та при обробці залежностей.</li>\n</ul>\n\n<p>Ці патерни дозволяють Spring забезпечувати інверсію керування, аспекти, легке тестування та модульність додатків.</p>","topicName":"Шаблони проектування"},{"id":504,"questionText":"Які патерни використовуються в Hibernate?","answer":"<p>Hibernate активно використовує різні патерни проектування для спрощення роботи з базою даних, управлінням сесіями та ефективною реалізацією ORM. Основні патерни:</p>\n\n<ul>\n  <li><strong>Singleton</strong> – застосовується для <code>SessionFactory</code>, щоб забезпечити єдиний екземпляр фабрики сесій для всього додатка.</li>\n  <li><strong>Factory Method</strong> – використовується для створення об'єктів <code>Session</code> через <code>SessionFactory</code>.</li>\n  <li><strong>Proxy</strong> – реалізується через ліниве завантаження (<code>lazy loading</code>) та об’єкти-заглушки, що дозволяє відкладене завантаження асоціацій.</li>\n  <li><strong>Template Method</strong> – використовується у класах, таких як <code>HibernateTemplate</code>, для стандартизації алгоритмів роботи з сесіями і транзакціями.</li>\n  <li><strong>Decorator</strong> – застосовується для розширення функціональності сесій і транзакцій через проксі та інтерцептори.</li>\n  <li><strong>Observer</strong> – реалізується через механізм подій Hibernate (Listeners), наприклад, для відстеження змін у сутностях.</li>\n  <li><strong>Builder</strong> – використовується у <code>CriteriaBuilder</code> та <code>QueryBuilder</code> для побудови складних запитів у стилі Fluent API.</li>\n  <li><strong>Unit of Work</strong> – шаблон, який забезпечує збереження змін у сутностях і синхронізацію їх з базою даних у межах сесії.</li>\n  <li><strong>Data Mapper</strong> – основний патерн Hibernate, який відділяє доменні об’єкти від способу збереження у базі даних.</li>\n</ul>\n\n<p>Завдяки цим патернам Hibernate забезпечує ефективне управління об'єктами, кешування, транзакційність та гнучку роботу з реляційними базами даних.</p>","topicName":"Шаблони проектування"},{"id":505,"questionText":"Розкажіть про шаблони GRASP: Низька зв'язаність та Висока сплоченість","answer":"<p><strong>GRASP (General Responsibility Assignment Software Patterns)</strong> – це набір принципів, які допомагають визначати, які класи та об'єкти повинні виконувати певні обов'язки у програмному забезпеченні, щоб забезпечити його якість, масштабованість та легкість підтримки.</p>\n\n<h3>Низька зв'язаність (Low Coupling)</h3>\n<p>Принцип низької зв'язаності означає, що клас або модуль має мінімальну залежність від інших класів або модулів. Низька зв'язаність сприяє:</p>\n<ul>\n  <li>легшій підтримці та модифікації коду;</li>\n  <li>зменшенню впливу змін в одному класі на інші;</li>\n  <li>збільшенню повторного використання коду;</li>\n  <li>спрощенню тестування окремих компонентів.</li>\n</ul>\n\n<h3>Висока сплоченість (High Cohesion)</h3>\n<p>Висока сплоченість означає, що клас або модуль виконує лише одну, чітко визначену задачу, а всі його методи та властивості тісно пов’язані між собою для виконання цієї задачі. Висока сплоченість дозволяє:</p>\n<ul>\n  <li>зменшити складність коду;</li>\n  <li>підвищити зрозумілість і передбачуваність поведінки класів;</li>\n  <li>легше виявляти та виправляти помилки;</li>\n  <li>покращити повторне використання класів у різних контекстах.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Поєднання низької зв'язаності та високої сплоченості є ключовим для створення гнучких, масштабованих і підтримуваних систем. GRASP допомагає розробникам правильно розподіляти обов’язки між об’єктами та забезпечувати якісну архітектуру програмного забезпечення.</p>","topicName":"Шаблони проектування"},{"id":506,"questionText":"Розкажіть про патерн Saga","answer":"<p>Патерн <strong>Saga</strong> використовується для управління розподіленими транзакціями у мікросервісній архітектурі. У великих системах з кількома сервісами неможливо забезпечити класичну ACID-транзакцію через різні бази даних та віддалені сервіси. Тут на допомогу приходить Saga.</p>\n\n<h3>Суть патерну</h3>\n<p>Saga розбиває велику транзакцію на серію локальних транзакцій, кожна з яких виконується у своєму мікросервісі. Якщо якась транзакція не вдалася, Saga виконує <em>компенсуючі транзакції</em> для відкату попередніх кроків, щоб система повернулася у консистентний стан.</p>\n\n<h3>Види реалізації</h3>\n<ul>\n  <li><strong>Orchestration-based Saga</strong> – є центральний оркестратор, який контролює виконання локальних транзакцій і викликає компенсаційні дії у разі помилки.</li>\n  <li><strong>Choreography-based Saga</strong> – немає центрального контролю; кожен мікросервіс самостійно публікує події про виконання своєї транзакції, а інші сервіси реагують на ці події, виконуючи свої кроки або компенсуючі дії.</li>\n</ul>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Дозволяє координувати транзакції між мікросервісами без блокування ресурсів;</li>\n  <li>Покращує відмовостійкість системи;</li>\n  <li>Підтримує eventual consistency замість строгого ACID;</li>\n  <li>Гнучкість у масштабуванні та оновленні сервісів.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Патерн Saga є ключовим підходом для забезпечення узгодженості даних у розподілених системах, особливо коли потрібна взаємодія кількох мікросервісів і повна ACID-транзакція неможлива.</p>","topicName":"Шаблони проектування"},{"id":507,"questionText":"Що таке Big O?","answer":"<p><strong>Big O</strong> – це нотація, яка використовується для оцінки складності алгоритмів. Вона показує, як змінюється час виконання або використання пам’яті алгоритму в залежності від розміру вхідних даних (N).</p> <h3>Основна ідея</h3> <p>Big O описує поведінку алгоритму у найгіршому випадку (worst-case scenario). Наприклад, якщо алгоритм перебирає всі елементи списку, його складність буде O(N). Якщо алгоритм виконує вкладені цикли по всім елементам, складність може бути O(N²).</p>","topicName":"Алгоритми"},{"id":508,"questionText":"Що таке асимптотика?","answer":"<p><strong>Асимптотика</strong> – це математичне поняття, яке використовується для опису поведінки функції або алгоритму при зростанні вхідних даних до нескінченності. В інформатиці асимптотика дозволяє оцінити, як змінюється час виконання або використання пам’яті алгоритму в залежності від розміру даних.</p>\n\n<h3>Основна ідея</h3>\n<p>Асимптотичний аналіз концентрується на головному чиннику, який визначає швидкість зростання ресурсоємності алгоритму, і ігнорує константні множники та менш значущі доданки. Це дозволяє порівнювати алгоритми незалежно від конкретного апаратного забезпечення.</p>\n\n<h3>Типи асимптотичної оцінки</h3>\n<ul>\n  <li><strong>O (Big O)</strong> – верхня межа, оцінює найгірший випадок.</li>\n  <li><strong>Ω (Big Omega)</strong> – нижня межа, оцінює найкращий випадок.</li>\n  <li><strong>Θ (Big Theta)</strong> – точна оцінка, коли алгоритм обмежений зверху та знизу однаково.</li>\n</ul>","topicName":"Алгоритми"},{"id":509,"questionText":"Які існують популярні функції складності алгоритма ?","answer":"<ul>\n  <li><strong>O(1)</strong> – константна складність. Час виконання не залежить від розміру вхідних даних.</li>\n  <li><strong>O(log N)</strong> – логарифмічна складність. Наприклад, бінарний пошук у відсортованому масиві.</li>\n  <li><strong>O(N)</strong> – лінійна складність. Алгоритм проходить через всі елементи один раз.</li>\n  <li><strong>O(N log N)</strong> – складність ефективних алгоритмів сортування (наприклад, MergeSort, QuickSort).</li>\n  <li><strong>O(N²)</strong> – квадратична складність. Зазвичай алгоритми з подвійним вкладеним циклом.</li>\n</ul>","topicName":"Алгоритми"},{"id":510,"questionText":"Що таке рекурсія?","answer":"<p><strong>Рекурсія</strong> – це спосіб організації алгоритму, коли функція викликає сама себе для вирішення підзадачі, поки не буде досягнута базова умова (умова завершення).</p>\n\n<h3>Приклад рекурсії</h3>\n<p>Обчислення факторіала числа N:</p>\n<pre>\nint factorial(int n) {\n    if (n == 0) return 1; // базова умова\n    return n * factorial(n - 1);\n}\n</pre>","topicName":"Алгоритми"},{"id":511,"questionText":"Порівняйте рекурсію та ітерацію","answer":"<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n<tr>\n<th>Критерій</th>\n<th>Рекурсія</th>\n<th>Ітерація</th>\n</tr>\n<tr>\n<td>Читабельність</td>\n<td>Код часто коротший і легший для розуміння, особливо для дерев та графів.</td>\n<td>Може бути довший та складніший, особливо для складних структур.</td>\n</tr>\n<tr>\n<td>Використання пам’яті</td>\n<td>Використовує стек викликів; при великій глибині можливий StackOverflow.</td>\n<td>Менше використання пам’яті, стек не розширюється.</td>\n</tr>\n<tr>\n<td>Продуктивність</td>\n<td>Може бути повільнішою через накладні витрати на виклики функцій.</td>\n<td>Зазвичай швидша, оскільки відсутні додаткові виклики функцій.</td>\n</tr>\n<tr>\n<td>Приклад</td>\n<td>Обхід дерева у глибину (DFS), факторіал, Фібоначчі.</td>\n<td>Обчислення факторіала через цикл, сумування елементів масиву, пошук максимуму у масиві.</td>\n</tr>\n</table>\n\n<h3>Висновок</h3>\n<p>Рекурсія зручна для розв’язання задач із природною розбивкою на підзадачі (дерева, графи, розділяй і володарюй), але потребує контролю глибини викликів та може бути менш ефективною. Ітерація зазвичай більш ефективна за пам’яттю та продуктивністю, але іноді складніша для реалізації та розуміння.</p>","topicName":"Алгоритми"},{"id":512,"questionText":"Що таке жадібні алгоритми?","answer":"<p><strong>Жадібні алгоритми</strong> (Greedy algorithms) – це підхід до розв'язання задач, при якому на кожному кроці обирається локально оптимальне рішення з надією, що це призведе до глобально оптимального результату. Жадібні алгоритми не повертаються назад і не переглядають попередні рішення.</p>\n\n<h3>Характеристики жадібних алгоритмів</h3>\n<ul>\n  <li>Обирають найкращий доступний варіант на кожному кроці.</li>\n  <li>Не переглядають попередні кроки.</li>\n  <li>Простота реалізації та висока швидкість.</li>\n  <li>Підходять лише для задач, де локальний оптимум веде до глобального (наприклад, задачі з властивістю оптимальної підструктури).</li>\n</ul>\n\n<h3>Приклади жадібних алгоритмів</h3>\n<ul>\n  <li><strong>Задача про монети:</strong> Обирати найбільшу номінальну монету, що не перевищує залишок суми.</li>\n  <li><strong>Задача про мінімальне покриття відрізками:</strong> Вибирати відрізок, який покриває найбільшу невикористану частину.</li>\n  <li><strong>Алгоритм Крускала для побудови мінімального остовного дерева.</strong></li>\n  <li><strong>Алгоритм Пріма для мінімального остовного дерева.</strong></li>\n</ul>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Проста реалізація.</li>\n  <li>Висока швидкість виконання.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Не завжди гарантує глобально оптимальне рішення.</li>\n  <li>Потребує перевірки властивості оптимальної підструктури задачі.</li>\n</ul>","topicName":"Алгоритми"},{"id":513,"questionText":"Розкажіть про бульбашкове сортування (Bubble Sort)","answer":"<p><strong>Бульбашкове сортування</strong> – це простий алгоритм сортування, який послідовно проходить по масиву, порівнює сусідні елементи і міняє їх місцями, якщо вони знаходяться у неправильному порядку. Процес повторюється до тих пір, поки масив не буде відсортований.</p>\n\n<h3>Принцип роботи</h3>\n<ol>\n  <li>Порівняти перший і другий елементи масиву. Якщо перший більший за другий, обміняти їх місцями.</li>\n  <li>Перейти до наступної пари елементів і повторити порівняння.</li>\n  <li>Пройти весь масив — найбільший елемент \"спливає\" до кінця масиву.</li>\n  <li>Повторювати процес для всіх елементів, крім останніх, які вже відсортовані.</li>\n</ol>\n\n<h3>Приклад коду на Java</h3>\n<pre>\nvoid bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Простий для розуміння та реалізації.</li>\n  <li>Не потребує додаткової пам’яті (сортування на місці).</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Низька ефективність на великих масивах — час виконання O(n²).</li>\n  <li>Занадто багато порівнянь і обмінів, навіть якщо масив майже відсортований.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Бульбашкове сортування добре підходить для навчання та невеликих масивів, але для великих даних краще використовувати швидші алгоритми сортування, наприклад, QuickSort або MergeSort.</p>","topicName":"Алгоритми"},{"id":514,"questionText":"Розкажіть про швидке сортування (Quick Sort)","answer":"<p><strong>Швидке сортування</strong> – це ефективний алгоритм сортування, який використовує підхід \"розділяй і володарюй\". Масив ділиться на підмасиви навколо обраного опорного елемента (pivot), і елементи менші за pivot розташовуються ліворуч, а більші — праворуч. Процес рекурсивно повторюється для підмасивів.</p>\n\n<h3>Принцип роботи</h3>\n<ol>\n  <li>Вибрати опорний елемент (pivot).</li>\n  <li>Розділити масив: всі елементи менші за pivot зліва, більші — справа.</li>\n  <li>Рекурсивно застосувати алгоритм до лівого та правого підмасивів.</li>\n  <li>Об’єднати відсортовані підмасиви разом.</li>\n</ol>\n\n<h3>Приклад коду на Java</h3>\n<pre>\nvoid quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return i + 1;\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>В середньому має високу швидкість — час виконання O(n log n).</li>\n  <li>Рекурсивна структура підходить для великих масивів.</li>\n  <li>Сортування на місці, додаткова пам’ять практично не потрібна.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>У найгіршому випадку (масив вже відсортований або вибір pivot невдалий) час виконання O(n²).</li>\n  <li>Рекурсія може призвести до StackOverflow для дуже великих масивів.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Quick Sort – один з найефективніших загальних алгоритмів сортування для середніх та великих масивів, особливо якщо правильно вибирати опорний елемент.</p>","topicName":"Алгоритми"},{"id":515,"questionText":"Розкажіть про сортування злиттям (Merge Sort)","answer":"<p><strong>Сортування злиттям</strong> – це ефективний алгоритм сортування, який працює за принципом \"розділяй і володарюй\". Масив рекурсивно ділиться на дві половини до тих пір, поки підмасиви не стануть однеелементними. Потім ці підмасиви поступово зливаються в правильному порядку, утворюючи відсортований масив.</p>\n\n<h3>Принцип роботи</h3>\n<ol>\n  <li>Розділити масив навпіл.</li>\n  <li>Рекурсивно відсортувати кожну половину.</li>\n  <li>Злити дві відсортовані половини у відсортований масив.</li>\n</ol>\n\n<h3>Приклад коду на Java</h3>\n<pre>\nvoid mergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = (left + right) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nvoid merge(int[] arr, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int[] L = new int[n1];\n    int[] R = new int[n2];\n\n    for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}\n</pre>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Гарантований час виконання O(n log n) для будь-якого масиву.</li>\n  <li>Стабільне сортування – зберігає порядок рівних елементів.</li>\n  <li>Добре підходить для сортування великих обсягів даних.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Потребує додаткової пам’яті для тимчасових масивів (O(n)).</li>\n  <li>Менш ефективне для маленьких масивів порівняно з простими алгоритмами, наприклад, бульбашковим.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Merge Sort – надійний алгоритм сортування, особливо корисний для великих масивів і зовнішнього сортування, коли дані не поміщаються в оперативну пам’ять.</p>","topicName":"Алгоритми"},{"id":516,"questionText":"Розкажіть про бінарне дерево","answer":"<p><strong>Бінарне дерево</strong> – це структура даних, у якій кожен вузол має не більше двох нащадків: лівого та правого. Кожен вузол містить значення (ключ) і посилання на лівого та правого нащадка. Бінарні дерева використовуються для зберігання впорядкованих даних і забезпечують ефективний доступ, пошук, вставку та видалення елементів.</p>\n\n<h3>Типи бінарних дерев</h3>\n<ul>\n  <li><strong>Бінарне дерево пошуку (Binary Search Tree, BST):</strong> для кожного вузла всі значення в лівому піддереві менші за значення вузла, а всі значення в правому піддереві більші.</li>\n  <li><strong>Повне бінарне дерево:</strong> усі рівні заповнені, а останній рівень заповнений зліва направо.</li>\n  <li><strong>Досконале бінарне дерево:</strong> усі рівні повністю заповнені.</li>\n  <li><strong>Балансоване бінарне дерево:</strong> висота лівого та правого піддерева будь-якого вузла відрізняється не більше ніж на 1.</li>\n</ul>\n\n<h3>Операції над бінарним деревом</h3>\n<ul>\n  <li>Пошук: знаходження вузла з певним ключем.</li>\n  <li>Вставка: додавання нового вузла, зберігаючи властивості дерева.</li>\n  <li>Видалення: видалення вузла і реорганізація дерева.</li>\n  <li>Обхід дерева: <em>in-order</em> (ліве – вузол – праве), <em>pre-order</em> (вузол – ліве – праве), <em>post-order</em> (ліве – праве – вузол).</li>\n</ul>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Швидкий пошук, вставка та видалення для збалансованого дерева: O(log n).</li>\n  <li>Структура підтримує впорядковані дані.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Для незбалансованого дерева операції можуть стати повільними: O(n).</li>\n  <li>Складність реалізації порівняно з масивами або списками.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Бінарне дерево є основою для багатьох ефективних структур даних, таких як AVL-дерева, червоно-чорні дерева та бінарні дерева пошуку, і широко використовується в алгоритмах пошуку та сортування.</p>","topicName":"Алгоритми"},{"id":517,"questionText":"Розкажіть про червоно-чорне дерево (Red-Black Tree)","answer":"<p><strong>Черво́но-чорне дерево</strong> – це самобалансуюче бінарне дерево пошуку, яке забезпечує логарифмічний час виконання основних операцій: пошуку, вставки та видалення. Кожен вузол дерева має додатковий атрибут — колір, який може бути <strong>червоним</strong> або <strong>чорним</strong>.</p>\n\n<h3>Властивості червоно-чорного дерева</h3>\n<ol>\n  <li>Кожен вузол має колір — червоний або чорний.</li>\n  <li>Корінь дерева завжди чорний.</li>\n  <li>Всі листові вузли (NULL-вузли) вважаються чорними.</li>\n  <li>Якщо вузол червоний, то обидва його нащадки чорні (немає двох червоних підряд).</li>\n  <li>Для кожного вузла всі шляхи від нього до листових вузлів містять однакову кількість чорних вузлів (black-height).</li>\n</ol>\n\n<h3>Операції</h3>\n<ul>\n  <li><strong>Пошук:</strong> здійснюється як у звичайному бінарному дереві пошуку, O(log n).</li>\n  <li><strong>Вставка:</strong> вставляється новий вузол як червоний, після чого виконується перевірка і при необхідності відбуваються переворот (rotation) і змінення кольорів, щоб зберегти властивості дерева.</li>\n  <li><strong>Видалення:</strong> після видалення вузла може знадобитися повторне балансування і перевстановлення кольорів.</li>\n</ul>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Гарантована висота дерева O(log n), що забезпечує ефективні операції.</li>\n  <li>Використовується у багатьох структурах даних, наприклад, TreeMap і TreeSet у Java.</li>\n  <li>Самобалансування незначно впливає на продуктивність вставки/видалення.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Складніша реалізація порівняно з простим бінарним деревом пошуку.</li>\n  <li>Додаткові витрати пам’яті на зберігання кольору вузла.</li>\n</ul>\n\n<h3>Висновок</h3>\n<p>Черво́но-чорне дерево є ефективною самобалансуючою структурою даних, яка забезпечує стабільну продуктивність навіть для великих наборів даних і широко використовується у сучасних бібліотеках та фреймворках.</p>","topicName":"Алгоритми"},{"id":518,"questionText":"Розкажіть про лінійний пошук (Linear Search)","answer":"<p><strong>Лінійний пошук</strong> – це простий алгоритм пошуку елемента у списку або масиві. Він полягає в послідовному перегляді всіх елементів до тих пір, поки не буде знайдено потрібне значення або поки не завершиться весь список.</p>\n\n<h3>Алгоритм роботи</h3>\n<ol>\n  <li>Почати з першого елемента масиву чи списку.</li>\n  <li>Порівняти поточний елемент з шуканим значенням.</li>\n  <li>Якщо елемент знайдено, повернути його позицію або індекс.</li>\n  <li>Якщо ні, перейти до наступного елемента.</li>\n  <li>Якщо досягнуто кінця списку, повернути, що елемент не знайдено.</li>\n</ol>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Простота реалізації.</li>\n  <li>Працює з будь-яким типом даних та невпорядкованими масивами.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Неефективний для великих масивів – час виконання O(n).</li>\n  <li>Не використовує інформацію про порядок елементів.</li>\n</ul>\n\n<h3>Приклад коду на Java</h3>\n<pre><code>\npublic int linearSearch(int[] arr, int target) {\n    for (int i = 0; i &lt; arr.length; i++) {\n        if (arr[i] == target) {\n            return i; // елемент знайдено\n        }\n    }\n    return -1; // елемент не знайдено\n}\n</code></pre>\n\n<h3>Висновок</h3>\n<p>Лінійний пошук підходить для невеликих або невпорядкованих масивів. Для великих впорядкованих структур даних краще використовувати більш ефективні алгоритми, наприклад, бінарний пошук.</p>","topicName":"Алгоритми"},{"id":519,"questionText":"Розкажіть про бінарний пошук (Binary Search)","answer":"<p><strong>Бінарний пошук</strong> – це ефективний алгоритм пошуку елемента у впорядкованому масиві або списку. Він працює за принципом \"ділення навпіл\": на кожному кроці порівнює шукане значення з середнім елементом підмасиву і звужує область пошуку наполовину.</p>\n\n<h3>Алгоритм роботи</h3>\n<ol>\n  <li>Визначити початкові межі пошуку: <em>ліву</em> та <em>праву</em> границі масиву.</li>\n  <li>Знайти середній елемент підмасиву.</li>\n  <li>Порівняти середній елемент з шуканим значенням:\n    <ul>\n      <li>Якщо значення знайдено, повернути його індекс.</li>\n      <li>Якщо шукане значення менше середнього, повторити пошук у лівій половині.</li>\n      <li>Якщо шукане значення більше середнього, повторити пошук у правій половині.</li>\n    </ul>\n  </li>\n  <li>Продовжувати, поки підмасив не стане порожнім.</li>\n</ol>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Висока ефективність для великих масивів: час виконання O(log n).</li>\n  <li>Менше порівнянь у порівнянні з лінійним пошуком.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Працює тільки з впорядкованими масивами або списками.</li>\n  <li>Складніша реалізація, ніж у лінійного пошуку.</li>\n</ul>\n\n<h3>Приклад коду на Java</h3>\n<pre><code>\npublic int binarySearch(int[] arr, int target) {\n    int left = 0;\n    int right = arr.length - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid; // елемент знайдено\n        } else if (arr[mid] &lt; target) {\n            left = mid + 1; // шукаємо в правій половині\n        } else {\n            right = mid - 1; // шукаємо в лівій половині\n        }\n    }\n    return -1; // елемент не знайдено\n}\n</code></pre>\n\n<h3>Висновок</h3>\n<p>Бінарний пошук – це швидкий і ефективний алгоритм для впорядкованих даних. Він значно зменшує кількість порівнянь у порівнянні з лінійним пошуком, особливо для великих структур даних.</p>","topicName":"Алгоритми"},{"id":520,"questionText":"Розкажіть про чергу (Queue)","answer":"<p><strong>Черга</strong> – це структура даних, яка реалізує принцип <em>FIFO (First In, First Out)</em>, тобто перший елемент, який був доданий, буде першим видалений. Черги широко використовуються для організації потоків обробки, черг повідомлень та задач.</p>\n\n<h3>Основні операції черги</h3>\n<ul>\n  <li><strong>enqueue(element)</strong> – додати елемент у кінець черги.</li>\n  <li><strong>dequeue()</strong> – видалити та повернути елемент із початку черги.</li>\n  <li><strong>peek() або front()</strong> – отримати значення першого елемента без видалення.</li>\n  <li><strong>isEmpty()</strong> – перевірити, чи порожня черга.</li>\n  <li><strong>size()</strong> – отримати кількість елементів у черзі.</li>\n</ul>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Простий спосіб організації обробки даних у порядку надходження.</li>\n  <li>Корисна для багатопоточних задач і потоків повідомлень.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Доступ до елементів, окрім першого, обмежений.</li>\n  <li>Відносно повільні операції, якщо реалізація не оптимізована (наприклад, масивне зміщення елементів при dequeue).</li>\n</ul>\n\n<h3>Приклад коду на Java</h3>\n<pre><code>\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nQueue&lt;Integer&gt; queue = new LinkedList<>();\n\n// Додати елементи\nqueue.add(10);\nqueue.add(20);\nqueue.add(30);\n\n// Отримати перший елемент без видалення\nint first = queue.peek(); // 10\n\n// Видалити елемент з початку\nint removed = queue.remove(); // 10\n\n// Перевірити, чи порожня\nboolean empty = queue.isEmpty(); // false\n</code></pre>\n\n<h3>Висновок</h3>\n<p>Черга – це базова структура даних, яка забезпечує обробку елементів у порядку їх надходження. Вона корисна для задач синхронізації, потоків даних і планування виконання.</p>","topicName":"Алгоритми"},{"id":521,"questionText":"Розкажіть про стек (Stack)","answer":"<p><strong>Стек</strong> – це структура даних, яка реалізує принцип <em>LIFO (Last In, First Out)</em>, тобто останній доданий елемент буде першим видалений. Стек використовується для збереження проміжних результатів, викликів функцій, відкату дій (undo) та багатьох інших задач.</p>\n\n<h3>Основні операції стеку</h3>\n<ul>\n  <li><strong>push(element)</strong> – додати елемент на верх стеку.</li>\n  <li><strong>pop()</strong> – видалити та повернути елемент з вершини стеку.</li>\n  <li><strong>peek() або top()</strong> – отримати значення вершини без видалення.</li>\n  <li><strong>isEmpty()</strong> – перевірити, чи порожній стек.</li>\n  <li><strong>size()</strong> – отримати кількість елементів у стеку.</li>\n</ul>\n\n<h3>Переваги</h3>\n<ul>\n  <li>Швидкий доступ до останнього доданого елемента.</li>\n  <li>Проста реалізація та ефективне використання пам’яті.</li>\n</ul>\n\n<h3>Недоліки</h3>\n<ul>\n  <li>Обмежений доступ: можна працювати лише з вершиною стеку.</li>\n  <li>Може переповнитися при великій кількості push-операцій, якщо реалізація обмежена розміром масиву.</li>\n</ul>\n\n<h3>Приклад коду на Java</h3>\n<pre><code>\nimport java.util.Stack;\n\nStack&lt;Integer&gt; stack = new Stack<>();\n\n// Додати елементи\nstack.push(10);\nstack.push(20);\nstack.push(30);\n\n// Отримати верхній елемент без видалення\nint top = stack.peek(); // 30\n\n// Видалити елемент з вершини\nint removed = stack.pop(); // 30\n\n// Перевірити, чи порожній\nboolean empty = stack.isEmpty(); // false\n</code></pre>\n\n<h3>Висновок</h3>\n<p>Стек – це базова структура даних, яка дозволяє ефективно працювати з останнім доданим елементом. Він широко застосовується у рекурсії, парсингу, реалізації undo/redo та алгоритмах обробки виразів.</p>","topicName":"Алгоритми"},{"id":522,"questionText":"Порівняйте складність вставки, видалення, пошуку та доступу за індексом в різних струкутрах даних","answer":"<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n  <tr>\n    <th>Data Structure</th>\n    <th>Add</th>\n    <th>Contains</th>\n    <th>Next</th>\n    <th>Underlying Implementation</th>\n  </tr>\n  <tr>\n    <td>HashSet</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(h/n)</td>\n    <td>Hash Table</td>\n  </tr>\n  <tr>\n    <td>LinkedHashSet</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Hash Table + Linked List</td>\n  </tr>\n  <tr>\n    <td>EnumSet</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Bit Vector</td>\n  </tr>\n  <tr>\n    <td>TreeSet</td>\n    <td>O(log n)</td>\n    <td>O(log n)</td>\n    <td>O(log n)</td>\n    <td>Red-black Tree</td>\n  </tr>\n  <tr>\n    <td>CopyOnWriteArraySet</td>\n    <td>O(n)</td>\n    <td>O(n)</td>\n    <td>O(1)</td>\n    <td>Array</td>\n  </tr>\n  <tr>\n    <td>ConcurrentSkipListSet</td>\n    <td>O(log n)</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>Skip List</td>\n  </tr>\n</table>\n\n<h2>List Data Structures Complexity</h2>\n<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n  <tr>\n    <th>Data Structure</th>\n    <th>Add</th>\n    <th>Remove</th>\n    <th>Get</th>\n    <th>Contains</th>\n    <th>Underlying Implementation</th>\n  </tr>\n  <tr>\n    <td>ArrayList</td>\n    <td>O(1)</td>\n    <td>O(n)</td>\n    <td>O(1)</td>\n    <td>O(n)</td>\n    <td>Array</td>\n  </tr>\n  <tr>\n    <td>LinkedList</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(n)</td>\n    <td>O(n)</td>\n    <td>Linked List</td>\n  </tr>\n  <tr>\n    <td>CopyOnWriteArrayList</td>\n    <td>O(n)</td>\n    <td>O(n)</td>\n    <td>O(1)</td>\n    <td>O(n)</td>\n    <td>Array</td>\n  </tr>\n</table>\n\n<h2>Queue Data Structures Complexity</h2>\n<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n  <tr>\n    <th>Data Structure</th>\n    <th>Offer</th>\n    <th>Peek</th>\n    <th>Poll</th>\n    <th>Size</th>\n    <th>Underlying Implementation</th>\n  </tr>\n  <tr>\n    <td>PriorityQueue</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>Priority Heap</td>\n  </tr>\n  <tr>\n    <td>LinkedList</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Array</td>\n  </tr>\n  <tr>\n    <td>ArrayDeque</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Linked List</td>\n  </tr>\n  <tr>\n    <td>ConcurrentLinkedQueue</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(n)</td>\n    <td>Linked List</td>\n  </tr>\n  <tr>\n    <td>ArrayBlockingQueue</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Array</td>\n  </tr>\n  <tr>\n    <td>PriorityBlockingQueue</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>Priority Heap</td>\n  </tr>\n  <tr>\n    <td>SynchronousQueue</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>-</td>\n  </tr>\n  <tr>\n    <td>DelayQueue</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>LinkedBlockingQueue</td>\n  </tr>\n</table>\n\n<h2>Map Data Structures Complexity</h2>\n<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n  <tr>\n    <th>Data Structure</th>\n    <th>Get</th>\n    <th>ContainsKey</th>\n    <th>Next</th>\n    <th>Underlying Implementation</th>\n  </tr>\n  <tr>\n    <td>HashMap</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(h/n)</td>\n    <td>Hash Table</td>\n  </tr>\n  <tr>\n    <td>LinkedHashMap</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Hash Table + Linked List</td>\n  </tr>\n  <tr>\n    <td>IdentityHashMap</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(h/n)</td>\n    <td>Array</td>\n  </tr>\n  <tr>\n    <td>WeakHashMap</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(h/n)</td>\n    <td>Hash Table</td>\n  </tr>\n  <tr>\n    <td>EnumMap</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>Array</td>\n  </tr>\n  <tr>\n    <td>TreeMap</td>\n    <td>O(log n)</td>\n    <td>O(log n)</td>\n    <td>O(log n)</td>\n    <td>Red-black Tree</td>\n  </tr>\n  <tr>\n    <td>ConcurrentHashMap</td>\n    <td>O(1)</td>\n    <td>O(1)</td>\n    <td>O(h/n)</td>\n    <td>Hash Table</td>\n  </tr>\n  <tr>\n    <td>ConcurrentSkipListMap</td>\n    <td>O(log n)</td>\n    <td>O(log n)</td>\n    <td>O(1)</td>\n    <td>Skip List</td>\n  </tr>\n</table>","topicName":"Алгоритми"}]